var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"AYON Applications","text":"<p>Applications addon does care about launch of applications in AYON workspace. It defines and provides API to launch applications.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_applications<ul> <li>addon</li> <li>constants</li> <li>defs</li> <li>exceptions</li> <li>hooks<ul> <li>prelaunch_shell_windows</li> </ul> </li> <li>manager</li> <li>plugins<ul> <li>publish<ul> <li>collect_app_name</li> <li>collect_farm_env_variables</li> <li>integrate_app_name</li> </ul> </li> </ul> </li> <li>process</li> <li>ui<ul> <li>ansi_parser</li> <li>debug_terminal_launch</li> <li>launch_failed_dialog</li> <li>process_monitor</li> </ul> </li> <li>utils</li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>_backwards</li> <li>actions</li> <li>addon</li> <li>constants</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_applications/index.html","title":"ayon_applications","text":""},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.Application","title":"<code>Application</code>","text":"<p>Hold information about application.</p> <p>Object by itself does nothing special.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data for the version containing information about executables, variant label or if is enabled. Only required key is <code>executables</code>.</p> required <code>group</code> <code>ApplicationGroup</code> <p>App group object that created the application and under which application belongs.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class Application:\n    \"\"\"Hold information about application.\n\n    Object by itself does nothing special.\n\n    Args:\n        data (dict): Data for the version containing information about\n            executables, variant label or if is enabled.\n            Only required key is `executables`.\n        group (ApplicationGroup): App group object that created the application\n            and under which application belongs.\n\n    \"\"\"\n    def __init__(self, data: dict[str, Any], group: ApplicationGroup):\n        self._data = data\n        name = data[\"name\"]\n        label = data[\"label\"] or name\n        enabled = False\n        if group.enabled:\n            enabled = data.get(\"enabled\", True)\n\n        if group.label:\n            full_label = \" \".join((group.label, label))\n        else:\n            full_label = label\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n\n        arguments = data[\"arguments\"]\n        if isinstance(arguments, dict):\n            arguments = arguments.get(platform.system().lower())\n\n        if not arguments:\n            arguments = []\n\n        _executables = data[\"executables\"].get(platform.system().lower(), [])\n        executables = [\n            ApplicationExecutable(executable)\n            for executable in _executables\n        ]\n\n        self.group = group\n\n        self.name = name\n        self.label = label\n        self.enabled = enabled\n        self.use_python_2 = data.get(\"use_python_2\", False)\n\n        self.full_name = f\"{group.name}/{name}\"\n        self.full_label = full_label\n        self.arguments = arguments\n        self.executables = executables\n        self._environment = env\n        self.redirect_output = data.get(\"redirect_output\", True)\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.full_name}\"\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n\n    @property\n    def manager(self) -&gt; \"ApplicationManager\":\n        return self.group.manager\n\n    @property\n    def host_name(self) -&gt; Optional[str]:\n        return self.group.host_name\n\n    @property\n    def icon(self) -&gt; Optional[str]:\n        return self.group.icon\n\n    @property\n    def is_host(self) -&gt; bool:\n        return self.group.is_host\n\n    def find_executable(self) -&gt; Optional[ApplicationExecutable]:\n        \"\"\"Try to find existing executable for application.\n\n        Returns (str): Path to executable from `executables` or None if any\n            exists.\n        \"\"\"\n        for executable in self.executables:\n            if executable.exists():\n                return executable\n        return None\n\n    def launch(self, *args, **kwargs) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Launch the application.\n\n        For this purpose is used manager's launch method to keep logic at one\n        place.\n\n        Arguments must match with manager's launch method. That's why *args\n        **kwargs are used.\n\n        Returns:\n            subprocess.Popen: Return executed process as Popen object.\n\n        \"\"\"\n        return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.Application.find_executable","title":"<code>find_executable()</code>","text":"<p>Try to find existing executable for application.</p> <p>Returns (str): Path to executable from <code>executables</code> or None if any     exists.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def find_executable(self) -&gt; Optional[ApplicationExecutable]:\n    \"\"\"Try to find existing executable for application.\n\n    Returns (str): Path to executable from `executables` or None if any\n        exists.\n    \"\"\"\n    for executable in self.executables:\n        if executable.exists():\n            return executable\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.Application.launch","title":"<code>launch(*args, **kwargs)</code>","text":"<p>Launch the application.</p> <p>For this purpose is used manager's launch method to keep logic at one place.</p> <p>Arguments must match with manager's launch method. That's why args *kwargs are used.</p> <p>Returns:</p> Type Description <code>Optional[Popen]</code> <p>subprocess.Popen: Return executed process as Popen object.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def launch(self, *args, **kwargs) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Launch the application.\n\n    For this purpose is used manager's launch method to keep logic at one\n    place.\n\n    Arguments must match with manager's launch method. That's why *args\n    **kwargs are used.\n\n    Returns:\n        subprocess.Popen: Return executed process as Popen object.\n\n    \"\"\"\n    return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationExecutable","title":"<code>ApplicationExecutable</code>","text":"<p>Representation of executable loaded from settings.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationExecutable:\n    \"\"\"Representation of executable loaded from settings.\"\"\"\n\n    def __init__(self, executable: str):\n        # Try to format executable with environments\n        try:\n            executable = executable.format(**os.environ)\n        except Exception:\n            pass\n\n        # On MacOS check if exists path to executable when ends with `.app`\n        # - it is common that path will lead to \"/Applications/Blender\" but\n        #   real path is \"/Applications/Blender.app\"\n        if platform.system().lower() == \"darwin\":\n            executable = self.macos_executable_prep(executable)\n\n        self.executable_path = executable\n\n    def __str__(self) -&gt; str:\n        return self.executable_path\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; {self.executable_path}\"\n\n    @staticmethod\n    def macos_executable_prep(executable: str) -&gt; str:\n        \"\"\"Try to find full path to executable file.\n\n        Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n        Having path to '*.app' gives ability to read it's plist info and\n        use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n        Plist is stored in '*.app/Contents/Info.plist'.\n\n        This is because some '*.app' directories don't have same permissions\n        as real executable.\n        \"\"\"\n        # Try to find if there is `.app` file\n        if not os.path.exists(executable):\n            _executable = executable + \".app\"\n            if os.path.exists(_executable):\n                executable = _executable\n\n        # Try to find real executable if executable has `Contents` subfolder\n        contents_dir = os.path.join(executable, \"Contents\")\n        if os.path.exists(contents_dir):\n            executable_filename = None\n            # Load plist file and check for bundle executable\n            plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n            if os.path.exists(plist_filepath):\n                import plistlib\n\n                if hasattr(plistlib, \"load\"):\n                    with open(plist_filepath, \"rb\") as stream:\n                        parsed_plist = plistlib.load(stream)\n                else:\n                    parsed_plist = plistlib.readPlist(plist_filepath)\n                executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n            if executable_filename:\n                executable = os.path.join(\n                    contents_dir, \"MacOS\", executable_filename\n                )\n\n        return executable\n\n    def as_args(self) -&gt; list[str]:\n        return [self.executable_path]\n\n    def _realpath(self) -&gt; Optional[str]:\n        \"\"\"Check if path is valid executable path.\"\"\"\n        # Check for executable in PATH\n        result = find_executable(self.executable_path)\n        if result is not None:\n            return result\n\n        # This is not 100% validation but it is better than remove ability to\n        #   launch .bat, .sh or extentionless files\n        if os.path.exists(self.executable_path):\n            return self.executable_path\n        return None\n\n    def exists(self) -&gt; bool:\n        if not self.executable_path:\n            return False\n        return bool(self._realpath())\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationExecutable.macos_executable_prep","title":"<code>macos_executable_prep(executable)</code>  <code>staticmethod</code>","text":"<p>Try to find full path to executable file.</p> <p>Real executable is stored in '*.app/Contents/MacOS/'. <p>Having path to '*.app' gives ability to read it's plist info and use \"CFBundleExecutable\" key from plist to know what is \"executable.\"</p> <p>Plist is stored in '*.app/Contents/Info.plist'.</p> <p>This is because some '*.app' directories don't have same permissions as real executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>@staticmethod\ndef macos_executable_prep(executable: str) -&gt; str:\n    \"\"\"Try to find full path to executable file.\n\n    Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n    Having path to '*.app' gives ability to read it's plist info and\n    use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n    Plist is stored in '*.app/Contents/Info.plist'.\n\n    This is because some '*.app' directories don't have same permissions\n    as real executable.\n    \"\"\"\n    # Try to find if there is `.app` file\n    if not os.path.exists(executable):\n        _executable = executable + \".app\"\n        if os.path.exists(_executable):\n            executable = _executable\n\n    # Try to find real executable if executable has `Contents` subfolder\n    contents_dir = os.path.join(executable, \"Contents\")\n    if os.path.exists(contents_dir):\n        executable_filename = None\n        # Load plist file and check for bundle executable\n        plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n        if os.path.exists(plist_filepath):\n            import plistlib\n\n            if hasattr(plistlib, \"load\"):\n                with open(plist_filepath, \"rb\") as stream:\n                    parsed_plist = plistlib.load(stream)\n            else:\n                parsed_plist = plistlib.readPlist(plist_filepath)\n            executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n        if executable_filename:\n            executable = os.path.join(\n                contents_dir, \"MacOS\", executable_filename\n            )\n\n    return executable\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationExecutableNotFound","title":"<code>ApplicationExecutableNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Defined executable paths are not available on the machine.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationExecutableNotFound(Exception):\n    \"\"\"Defined executable paths are not available on the machine.\"\"\"\n\n    def __init__(self, application):\n        self.application = application\n        details = None\n        if not application.executables:\n            msg = (\n                \"Executable paths for application \\\"{}\\\"({}) are not set.\"\n            )\n        else:\n            msg = (\n                \"Defined executable paths for application \\\"{}\\\"({})\"\n                \" are not available on this machine.\"\n            )\n            details = \"Defined paths:\"\n            for executable in application.executables:\n                details += \"\\n- \" + executable.executable_path\n\n        self.msg = msg.format(application.full_label, application.full_name)\n        self.details = details\n\n        exc_mgs = str(self.msg)\n        if details:\n            # Is good idea to pass new line symbol to exception message?\n            exc_mgs += \"\\n\\n\" + details\n        self.exc_msg = exc_mgs\n        super().__init__(exc_mgs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationGroup","title":"<code>ApplicationGroup</code>","text":"<p>Hold information about application group.</p> <p>Application group wraps different versions(variants) of application. e.g. \"maya\" is group and \"maya_2020\" is variant.</p> <p>Group hold <code>host_name</code> which is implementation name used in AYON. Also holds <code>enabled</code> if whole app group is enabled or <code>icon</code> for application icon path in resources.</p> <p>Group has also <code>environment</code> which hold same environments for all variants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Groups' name.</p> required <code>data</code> <code>dict</code> <p>Group defying data loaded from settings.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that created the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationGroup:\n    \"\"\"Hold information about application group.\n\n    Application group wraps different versions(variants) of application.\n    e.g. \"maya\" is group and \"maya_2020\" is variant.\n\n    Group hold `host_name` which is implementation name used in AYON. Also\n    holds `enabled` if whole app group is enabled or `icon` for application\n    icon path in resources.\n\n    Group has also `environment` which hold same environments for all variants.\n\n    Args:\n        name (str): Groups' name.\n        data (dict): Group defying data loaded from settings.\n        manager (ApplicationManager): Manager that created the group.\n\n    \"\"\"\n    def __init__(\n        self,\n        name: str,\n        data: dict[str, Any],\n        manager: \"ApplicationManager\",\n    ):\n        icon = ICONS_BY_GROUP_NAME.get(name)\n        if not icon:\n            icon = data.get(\"icon\")\n\n        label = LABELS_BY_GROUP_NAME.get(name)\n        if not label:\n            label = data.get(\"label\")\n\n        self.name = name\n        self.manager = manager\n        self._data = data\n\n        self.enabled = data[\"enabled\"]\n        self.label = label\n        self.icon = icon\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = env\n\n        host_name = data[\"host_name\"] or None\n        self.is_host = host_name is not None\n        self.host_name = host_name\n\n        settings_variants = data[\"variants\"]\n        variants = {}\n        for variant_data in settings_variants:\n            app_variant = Application(variant_data, self)\n            variants[app_variant.name] = app_variant\n\n        self.variants = variants\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.name}\"\n\n    def __iter__(self) -&gt; Generator[\"Application\", None, None]:\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext","title":"<code>ApplicationLaunchContext</code>","text":"<p>Context of launching application.</p> <p>Main purpose of context is to prepare launch arguments and keyword arguments for new process. Most important part of keyword arguments preparations are environment variables.</p> <p>During the whole process is possible to use <code>data</code> attribute to store object usable in multiple places.</p> <p>Launch arguments are strings in list. It is possible to \"chain\" argument when order of them matters. That is possible to do with adding list where order is right and should not change. NOTE: This is recommendation, not requirement. e.g.: <code>[\"nuke.exe\", \"--NukeX\"]</code> -&gt; In this case any part of process may insert argument between <code>nuke.exe</code> and <code>--NukeX</code>. To keep them together it is better to wrap them in another list: <code>[[\"nuke.exe\", \"--NukeX\"]]</code>.</p> Notes <p>It is possible to use launch context only to prepare environment     variables. In that case <code>executable</code> may be None and can be used     'run_prelaunch_hooks' method to run prelaunch hooks which prepare     them.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Application</code> <p>Application definition.</p> required <code>executable</code> <code>ApplicationExecutable</code> <p>Object with path to executable.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment variable group. If not set 'DEFAULT_ENV_SUBGROUP' is used.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type. If not set 'local' is used.</p> <code>None</code> <code>**data</code> <code>dict</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationLaunchContext:\n    \"\"\"Context of launching application.\n\n    Main purpose of context is to prepare launch arguments and keyword\n    arguments for new process. Most important part of keyword arguments\n    preparations are environment variables.\n\n    During the whole process is possible to use `data` attribute to store\n    object usable in multiple places.\n\n    Launch arguments are strings in list. It is possible to \"chain\" argument\n    when order of them matters. That is possible to do with adding list where\n    order is right and should not change.\n    NOTE: This is recommendation, not requirement.\n    e.g.: `[\"nuke.exe\", \"--NukeX\"]` -&gt; In this case any part of process may\n    insert argument between `nuke.exe` and `--NukeX`. To keep them together\n    it is better to wrap them in another list: `[[\"nuke.exe\", \"--NukeX\"]]`.\n\n    Notes:\n        It is possible to use launch context only to prepare environment\n            variables. In that case `executable` may be None and can be used\n            'run_prelaunch_hooks' method to run prelaunch hooks which prepare\n            them.\n\n    Args:\n        application (Application): Application definition.\n        executable (ApplicationExecutable): Object with path to executable.\n        env_group (Optional[str]): Environment variable group. If not set\n            'DEFAULT_ENV_SUBGROUP' is used.\n        launch_type (Optional[str]): Launch type. If not set 'local' is used.\n        **data (dict): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n    \"\"\"\n\n    def __init__(\n        self,\n        application: Application,\n        executable: ApplicationExecutable,\n        env_group: Optional[str] = None,\n        launch_type: Optional[str] = None,\n        **data,\n    ):\n        from .process import ProcessManager\n\n        # Application object\n        self.application: Application = application\n\n        self.addons_manager: AddonsManager = AddonsManager()\n        self.process_manager: ProcessManager = ProcessManager()\n        self.redirect_output: bool = application.redirect_output\n\n        # Logger\n        self.log: logging.Logger = Logger.get_logger(\n            f\"{self.__class__.__name__}-{application.full_name}\"\n        )\n\n        self.executable: ApplicationExecutable = executable\n\n        if launch_type is None:\n            launch_type = LaunchTypes.local\n        self.launch_type: str = launch_type\n\n        if env_group is None:\n            env_group = DEFAULT_ENV_SUBGROUP\n\n        self.env_group: str = env_group\n\n        self.data: dict[str, Any] = dict(data)\n\n        launch_args = []\n        if executable is not None:\n            launch_args = executable.as_args()\n        # subprocess.Popen launch arguments (first argument in constructor)\n        self.launch_args: list[str] = launch_args\n        self.launch_args.extend(application.arguments)\n        if self.data.get(\"app_args\"):\n            self.launch_args.extend(self.data.pop(\"app_args\"))\n\n        # Handle launch environemtns\n        src_env = self.data.pop(\"env\", None)\n        if src_env is not None and not isinstance(src_env, dict):\n            self.log.warning(\n                f\"Passed `env` kwarg has invalid type: {type(src_env)}.\"\n                \" Expected: `dict`. Using `os.environ` instead.\"\n            )\n            src_env = None\n\n        if src_env is None:\n            src_env = os.environ\n\n        ignored_env = {\"QT_API\", }\n        env = {\n            key: str(value)\n            for key, value in src_env.items()\n            if key not in ignored_env\n        }\n        # subprocess.Popen keyword arguments\n        self.kwargs: dict[str, Any] = {\"env\": env}\n\n        if platform.system().lower() == \"windows\":\n            # Detach new process from currently running process on Windows\n            flags = (\n                subprocess.CREATE_NEW_PROCESS_GROUP\n                | subprocess.DETACHED_PROCESS\n            )\n            self.kwargs[\"creationflags\"] = flags\n\n        if not sys.stdout:\n            self.kwargs[\"stdout\"] = subprocess.DEVNULL\n            self.kwargs[\"stderr\"] = subprocess.DEVNULL\n\n        # TODO: add type hints\n        # note that these need to be None in order to trigger discovery\n        # when 'discover_launch_hooks' is called\n        self.prelaunch_hooks = None\n        self.postlaunch_hooks = None\n\n        self.process: Optional[Popen] = None\n        self._prelaunch_hooks_executed = False\n\n    @property\n    def env(self) -&gt; dict[str, str]:\n        if (\n            \"env\" not in self.kwargs\n            or self.kwargs[\"env\"] is None\n        ):\n            self.kwargs[\"env\"] = {}\n        return self.kwargs[\"env\"]\n\n    @env.setter\n    def env(self, value: dict[str, str]) -&gt; None:\n        if not isinstance(value, dict):\n            raise TypeError(\n                f\"'env' attribute expect 'dict' object. Got: {type(value)}\"\n            )\n        self.kwargs[\"env\"] = value\n\n    @property\n    def modules_manager(self) -&gt; AddonsManager:\n        \"\"\"\n        Deprecated:\n            Use 'addons_manager' instead.\n\n        \"\"\"\n        return self.addons_manager\n\n    def _collect_addons_launch_hook_paths(self) -&gt; list[str]:\n        \"\"\"Helper to collect application launch hooks from addons.\n\n        Module have to have implemented 'get_launch_hook_paths' method which\n        can expect application as argument or nothing.\n\n        Returns:\n            list[str]: Paths to launch hook directories.\n\n        \"\"\"\n        expected_types = (list, tuple, set)\n\n        output = []\n        for module in self.addons_manager.get_enabled_addons():\n            # Skip module if does not have implemented 'get_launch_hook_paths'\n            func = getattr(module, \"get_launch_hook_paths\", None)\n            if func is None:\n                continue\n\n            func = module.get_launch_hook_paths\n            if hasattr(inspect, \"signature\"):\n                sig = inspect.signature(func)\n                expect_args = len(sig.parameters) &gt; 0\n            else:\n                expect_args = len(inspect.getargspec(func)[0]) &gt; 0\n\n            # Pass application argument if method expect it.\n            try:\n                if expect_args:\n                    hook_paths = func(self.application)\n                else:\n                    hook_paths = func()\n            except Exception:\n                self.log.warning(\n                    \"Failed to call 'get_launch_hook_paths'\",\n                    exc_info=True\n                )\n                continue\n\n            if not hook_paths:\n                continue\n\n            # Convert string to list\n            if isinstance(hook_paths, str):\n                hook_paths = [hook_paths]\n\n            # Skip invalid types\n            if not isinstance(hook_paths, expected_types):\n                self.log.warning(\n                    \"Result of `get_launch_hook_paths` has invalid\"\n                    f\" type {type(hook_paths)}. Expected {expected_types}\"\n                )\n                continue\n\n            output.extend(hook_paths)\n        return output\n\n    def paths_to_launch_hooks(self) -&gt; list[str]:\n        \"\"\"Directory paths where to look for launch hooks.\"\"\"\n        # This method has potential to be part of application manager (maybe).\n        paths = []\n\n        # TODO load additional studio paths from settings\n        global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n        hooks_dirs = [\n            global_hooks_dir\n        ]\n        if self.host_name:\n            # If host requires launch hooks and is module then launch hooks\n            #   should be collected using 'collect_launch_hook_paths'\n            #   - module have to implement 'get_launch_hook_paths'\n            host_module = self.addons_manager.get_host_addon(self.host_name)\n            if not host_module:\n                hooks_dirs.append(os.path.join(\n                    AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n                ))\n\n        for path in hooks_dirs:\n            if (\n                os.path.exists(path)\n                and os.path.isdir(path)\n                and path not in paths\n            ):\n                paths.append(path)\n\n        # Load modules paths\n        paths.extend(self._collect_addons_launch_hook_paths())\n\n        return paths\n\n    def discover_launch_hooks(self, force: bool = False) -&gt; None:\n        \"\"\"Load and prepare launch hooks.\"\"\"\n        if (\n            self.prelaunch_hooks is not None\n            or self.postlaunch_hooks is not None\n        ):\n            if not force:\n                self.log.info(\"Launch hooks were already discovered.\")\n                return\n\n            self.prelaunch_hooks.clear()\n            self.postlaunch_hooks.clear()\n\n        self.log.debug(\"Discovery of launch hooks started.\")\n\n        paths = self.paths_to_launch_hooks()\n        self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n            \"\\n\".join(f\"- {path}\" for path in paths)\n        ))\n\n        all_classes: dict[str, list[Type[Union[PreLaunchHook, PostLaunchHook]]]] = {  # noqa: E501\n            \"pre\": [],\n            \"post\": []\n        }\n        for path in paths:\n            if not os.path.exists(path):\n                self.log.info(\n                    f\"Path to launch hooks does not exist: \\\"{path}\\\"\"\n                )\n                continue\n\n            modules, _crashed = modules_from_path(path)\n            for _filepath, module in modules:\n                all_classes[\"pre\"].extend(\n                    classes_from_module(PreLaunchHook, module)\n                )\n                all_classes[\"post\"].extend(\n                    classes_from_module(PostLaunchHook, module)\n                )\n\n        for launch_type, classes in all_classes.items():\n            hooks_with_order = []\n            hooks_without_order = []\n            for klass in classes:\n                try:\n                    hook = klass(self)\n                    if not hook.is_valid:\n                        self.log.debug(\n                            \"Skipped hook invalid for current launch context:\"\n                            f\" {klass.__name__}\"\n                        )\n                        continue\n\n                    if inspect.isabstract(hook):\n                        self.log.debug(\n                            f\"Skipped abstract hook: {klass.__name__}\"\n                        )\n                        continue\n\n                    # Separate hooks by pre/post class\n                    if hook.order is None:\n                        hooks_without_order.append(hook)\n                    else:\n                        hooks_with_order.append(hook)\n\n                except Exception:\n                    self.log.warning(\n                        f\"Initialization of hook failed: {klass.__name__}\",\n                        exc_info=True\n                    )\n\n            # Sort hooks with order by order\n            ordered_hooks = list(sorted(\n                hooks_with_order, key=lambda obj: obj.order\n            ))\n            # Extend ordered hooks with hooks without defined order\n            ordered_hooks.extend(hooks_without_order)\n\n            if launch_type == \"pre\":\n                self.prelaunch_hooks = ordered_hooks\n            else:\n                self.postlaunch_hooks = ordered_hooks\n\n        self.log.debug(\n            f\"Found {len(self.prelaunch_hooks)} prelaunch\"\n            f\" and {len(self.postlaunch_hooks)} postlaunch hooks.\"\n        )\n\n    @property\n    def app_name(self) -&gt; str:\n        return self.application.name\n\n    @property\n    def host_name(self) -&gt; str:\n        return self.application.host_name\n\n    @property\n    def app_group(self) -&gt; ApplicationGroup:\n        return self.application.group\n\n    @property\n    def manager(self) -&gt; ApplicationManager:\n        return self.application.manager\n\n    def _run_process(self) -&gt; subprocess.Popen:\n        \"\"\"Run the process with the given launch arguments and keyword args.\n\n        This method will handle the process differently based on the platform\n        it is running on. It will create a temporary file for output on\n        Windows and macos, while on Linux it will use a mid-process to launch\n        the application with the provided arguments and environment variables.\n\n        It will pass file paths to temporary files to the mid-process where\n        the process output and pid will be stored.\n\n        Returns:\n            subprocess.Popen: The process object created by Popen.\n\n        \"\"\"\n        # Windows and macOS have easier process start\n        low_platform = platform.system().lower()\n        if low_platform in (\"windows\", \"darwin\"):\n            return self._execute_with_stdout()\n        # Linux uses mid-process\n        # - it is possible that the mid-process executable is not\n        #   available for this version of AYON in that case use standard\n        #   launch\n        launch_args = get_linux_launcher_args()\n        if launch_args is None:\n            return subprocess.Popen(self.launch_args, **self.kwargs)\n\n        # Prepare data that will be passed to mid-process\n        # - store arguments to a json and pass path to json as last argument\n        # - pass environments to set\n        app_env = self.kwargs.pop(\"env\", {})\n        # create temporary file path passed to mid-process\n\n        output_file = None\n        if self.redirect_output:\n            with tempfile.NamedTemporaryFile(\n                mode=\"w\",\n                prefix=f\"ayon_{self.application.host_name}_output_\",\n                suffix=\".txt\",\n                delete=False,\n                encoding=\"utf-8\",\n            ) as temp_file:\n                output_file = temp_file.name\n        # create temporary file to read back pid\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\",\n            prefix=\"ayon_pid_\",\n            suffix=\".txt\",\n            delete=False,\n            encoding=\"utf-8\",\n        ) as pid_temp_file:\n            pid_file = pid_temp_file.name\n\n        json_data = {\n            \"args\": self.launch_args,\n            \"env\": app_env,\n            \"pid_file\": pid_file,\n        }\n        if output_file:\n            json_data[\"stdout\"] = output_file\n            json_data[\"stderr\"] = output_file\n\n        if app_env:\n            # Filter environments of subprocess\n            self.kwargs[\"env\"] = {\n                key: value\n                for key, value in os.environ.items()\n                if key in app_env\n            }\n\n        # Create the temp file\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ay_app_args\", suffix=\".json\", delete=False\n        ) as json_temp:\n            json_temp_filepath = json_temp.name\n            json.dump(json_data, json_temp)\n\n        launch_args.append(json_temp_filepath)\n\n        # Create mid-process which will launch application\n        process = subprocess.Popen(launch_args, **self.kwargs)\n        # Wait until the process finishes\n        #   - This is important! The process would stay in \"open\" state.\n        process.wait()\n\n        # read back pid from the json file\n        try:\n            with open(json_temp_filepath, encoding=\"utf-8\") as stream:\n                json_data = json.load(stream)\n\n                try:\n                    import psutil\n                except ImportError:\n                    psutil = None\n\n                pid_from_mid = json_data.get(\"pid\")\n                executable = Path(str(self.executable))\n                start_time = None\n                if pid_from_mid and psutil:\n                    start_time = (\n                        self.process_manager.get_process_start_time_by_pid(\n                            pid_from_mid)\n                    )\n                    executable = (\n                        self.process_manager.get_executable_path_by_pid(\n                            pid_from_mid)\n                    ) or executable\n\n                from .process import ProcessInfo\n\n                process_info = ProcessInfo(\n                    name=self.application.full_name,\n                    executable=executable,\n                    args=self.launch_args,\n                    env=app_env,\n                    cwd=self.kwargs.get(\"cwd\") or os.getcwd(),\n                    pid=pid_from_mid,\n                    output=Path(output_file) if self.redirect_output else None,\n                    start_time=start_time,\n                )\n                # Store process info to the database\n                self.process_manager.store_process_info(process_info)\n        except OSError:\n            self.log.exception(\n                \"Failed to read process info from JSON file: %s\"\n            )\n\n        # Remove the temp file\n        os.remove(json_temp_filepath)\n        # Return process which is already terminated\n        return process\n\n    def run_prelaunch_hooks(self) -&gt; None:\n        \"\"\"Run prelaunch hooks.\n\n        This method will be executed only once, any future calls will skip\n        the processing.\n\n        Raises:\n            RuntimeError: When prelaunch hooks were already executed.\n\n        \"\"\"\n        if self._prelaunch_hooks_executed:\n            self.log.warning(\"Prelaunch hooks were already executed.\")\n            return\n        # Discover launch hooks\n        self.discover_launch_hooks()\n\n        # Execute prelaunch hooks\n        for hook in self.prelaunch_hooks:\n            self.log.debug(\n                f\"Executing prelaunch hook: {hook.__class__.__name__}\"\n            )\n            hook.execute()\n        self._prelaunch_hooks_executed = True\n\n    def launch(self) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Collect data for new process and then create it.\n\n        This method must not be executed more than once.\n\n        Returns:\n            subprocess.Popen: Created process as Popen object.\n\n        \"\"\"\n        if self.process is not None:\n            self.log.warning(\"Application was already launched.\")\n            return None\n\n        if not self._prelaunch_hooks_executed:\n            self.run_prelaunch_hooks()\n\n        self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n        # Prepare subprocess args\n        args_len_str = \"\"\n        if isinstance(self.launch_args, str):\n            args = self.launch_args\n        else:\n            args = self.clear_launch_args(self.launch_args)\n            args_len_str = f\" ({len(args)})\"\n        self.log.info(\n            f'Launching \"{self.application.full_name}\"'\n            f\" with args{args_len_str}: {args}\"\n        )\n        self.launch_args = args\n\n        # Run process\n        self.process = self._run_process()\n\n        # Process post launch hooks\n        for hook in self.postlaunch_hooks:\n            self.log.debug(\n                f\"Executing postlaunch hook: {hook.__class__.__name__}\"\n            )\n\n            # TODO how to handle errors?\n            # - store to variable to let them accessible?\n            try:\n                hook.execute()\n\n            except Exception:\n                self.log.warning(\n                    \"After launch procedures were not successful.\",\n                    exc_info=True,\n                )\n\n        self.log.debug(f\"Launch of {self.application.full_name} finished.\")\n\n        return self.process\n\n    @staticmethod\n    def clear_launch_args(args: list) -&gt; list[str]:\n        \"\"\"Collect launch arguments to final order.\n\n        Launch argument should be a list that may contain another lists this\n        function will upack inner lists and keep ordering.\n\n        ```\n        # source\n        [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n        # result\n        [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n        Args:\n            args (list): Source arguments in list may contain inner lists.\n\n        Returns:\n            list: Unpacked arguments.\n\n        \"\"\"\n        all_cleared = False\n        while not all_cleared:\n            all_cleared = True\n            new_args = []\n            for arg in args:\n                if isinstance(arg, (list, tuple, set)):\n                    all_cleared = False\n                    for _arg in arg:\n                        new_args.append(_arg)\n                else:\n                    new_args.append(arg)\n            args = new_args\n\n        return args\n\n    def _execute_with_stdout(self) -&gt; subprocess.Popen:\n        \"\"\"Run the process with stdout and stderr redirected to a file.\n\n        Stores process information to the database.\n\n        Returns:\n            subprocess.Popen: The process object created by Popen.\n        \"\"\"\n        from .process import ProcessInfo\n\n        process_info = ProcessInfo(\n            name=self.application.full_name,\n            executable=Path(str(self.executable)),\n            args=self.launch_args,\n            env=self.kwargs.get(\"env\", {}),\n            cwd=self.kwargs.get(\"cwd\") or os.getcwd(),\n            output=None,\n            pid=None,\n            start_time=None,\n        )\n\n        if self.redirect_output:\n            with tempfile.NamedTemporaryFile(\n                mode=\"w\",\n                prefix=f\"ayon_{self.application.host_name}_output_\",\n                suffix=\".txt\",\n                delete=False,\n                encoding=\"utf-8\",\n            ) as temp_file:\n                temp_file_path = temp_file.name\n\n            with open(temp_file_path, \"wb\") as tmp_file:\n                self.kwargs[\"stdout\"] = tmp_file\n                self.kwargs[\"stderr\"] = tmp_file\n                process = subprocess.Popen(self.launch_args, **self.kwargs)\n                process_info.output = Path(temp_file_path)\n        else:\n            process = subprocess.Popen(self.launch_args, **self.kwargs)\n\n        start_time = self.process_manager.get_process_start_time(process)\n        process_info.pid = process.pid\n        process_info.start_time = start_time\n        # Store process info to the database\n        self.process_manager.store_process_info(process_info)\n\n        return process\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.modules_manager","title":"<code>modules_manager</code>  <code>property</code>","text":"Deprecated <p>Use 'addons_manager' instead.</p>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.clear_launch_args","title":"<code>clear_launch_args(args)</code>  <code>staticmethod</code>","text":"<p>Collect launch arguments to final order.</p> <p>Launch argument should be a list that may contain another lists this function will upack inner lists and keep ordering.</p> <p>```</p>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.clear_launch_args--source","title":"source","text":"<p>[ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]</p>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.clear_launch_args--result","title":"result","text":"<p>[ arg1, arg2, arg3, arg4, arg5, arg6]</p> <p>Args:     args (list): Source arguments in list may contain inner lists.</p> <p>Returns:     list: Unpacked arguments.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>@staticmethod\ndef clear_launch_args(args: list) -&gt; list[str]:\n    \"\"\"Collect launch arguments to final order.\n\n    Launch argument should be a list that may contain another lists this\n    function will upack inner lists and keep ordering.\n\n    ```\n    # source\n    [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n    # result\n    [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n    Args:\n        args (list): Source arguments in list may contain inner lists.\n\n    Returns:\n        list: Unpacked arguments.\n\n    \"\"\"\n    all_cleared = False\n    while not all_cleared:\n        all_cleared = True\n        new_args = []\n        for arg in args:\n            if isinstance(arg, (list, tuple, set)):\n                all_cleared = False\n                for _arg in arg:\n                    new_args.append(_arg)\n            else:\n                new_args.append(arg)\n        args = new_args\n\n    return args\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.discover_launch_hooks","title":"<code>discover_launch_hooks(force=False)</code>","text":"<p>Load and prepare launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def discover_launch_hooks(self, force: bool = False) -&gt; None:\n    \"\"\"Load and prepare launch hooks.\"\"\"\n    if (\n        self.prelaunch_hooks is not None\n        or self.postlaunch_hooks is not None\n    ):\n        if not force:\n            self.log.info(\"Launch hooks were already discovered.\")\n            return\n\n        self.prelaunch_hooks.clear()\n        self.postlaunch_hooks.clear()\n\n    self.log.debug(\"Discovery of launch hooks started.\")\n\n    paths = self.paths_to_launch_hooks()\n    self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n        \"\\n\".join(f\"- {path}\" for path in paths)\n    ))\n\n    all_classes: dict[str, list[Type[Union[PreLaunchHook, PostLaunchHook]]]] = {  # noqa: E501\n        \"pre\": [],\n        \"post\": []\n    }\n    for path in paths:\n        if not os.path.exists(path):\n            self.log.info(\n                f\"Path to launch hooks does not exist: \\\"{path}\\\"\"\n            )\n            continue\n\n        modules, _crashed = modules_from_path(path)\n        for _filepath, module in modules:\n            all_classes[\"pre\"].extend(\n                classes_from_module(PreLaunchHook, module)\n            )\n            all_classes[\"post\"].extend(\n                classes_from_module(PostLaunchHook, module)\n            )\n\n    for launch_type, classes in all_classes.items():\n        hooks_with_order = []\n        hooks_without_order = []\n        for klass in classes:\n            try:\n                hook = klass(self)\n                if not hook.is_valid:\n                    self.log.debug(\n                        \"Skipped hook invalid for current launch context:\"\n                        f\" {klass.__name__}\"\n                    )\n                    continue\n\n                if inspect.isabstract(hook):\n                    self.log.debug(\n                        f\"Skipped abstract hook: {klass.__name__}\"\n                    )\n                    continue\n\n                # Separate hooks by pre/post class\n                if hook.order is None:\n                    hooks_without_order.append(hook)\n                else:\n                    hooks_with_order.append(hook)\n\n            except Exception:\n                self.log.warning(\n                    f\"Initialization of hook failed: {klass.__name__}\",\n                    exc_info=True\n                )\n\n        # Sort hooks with order by order\n        ordered_hooks = list(sorted(\n            hooks_with_order, key=lambda obj: obj.order\n        ))\n        # Extend ordered hooks with hooks without defined order\n        ordered_hooks.extend(hooks_without_order)\n\n        if launch_type == \"pre\":\n            self.prelaunch_hooks = ordered_hooks\n        else:\n            self.postlaunch_hooks = ordered_hooks\n\n    self.log.debug(\n        f\"Found {len(self.prelaunch_hooks)} prelaunch\"\n        f\" and {len(self.postlaunch_hooks)} postlaunch hooks.\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.launch","title":"<code>launch()</code>","text":"<p>Collect data for new process and then create it.</p> <p>This method must not be executed more than once.</p> <p>Returns:</p> Type Description <code>Optional[Popen]</code> <p>subprocess.Popen: Created process as Popen object.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Collect data for new process and then create it.\n\n    This method must not be executed more than once.\n\n    Returns:\n        subprocess.Popen: Created process as Popen object.\n\n    \"\"\"\n    if self.process is not None:\n        self.log.warning(\"Application was already launched.\")\n        return None\n\n    if not self._prelaunch_hooks_executed:\n        self.run_prelaunch_hooks()\n\n    self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n    # Prepare subprocess args\n    args_len_str = \"\"\n    if isinstance(self.launch_args, str):\n        args = self.launch_args\n    else:\n        args = self.clear_launch_args(self.launch_args)\n        args_len_str = f\" ({len(args)})\"\n    self.log.info(\n        f'Launching \"{self.application.full_name}\"'\n        f\" with args{args_len_str}: {args}\"\n    )\n    self.launch_args = args\n\n    # Run process\n    self.process = self._run_process()\n\n    # Process post launch hooks\n    for hook in self.postlaunch_hooks:\n        self.log.debug(\n            f\"Executing postlaunch hook: {hook.__class__.__name__}\"\n        )\n\n        # TODO how to handle errors?\n        # - store to variable to let them accessible?\n        try:\n            hook.execute()\n\n        except Exception:\n            self.log.warning(\n                \"After launch procedures were not successful.\",\n                exc_info=True,\n            )\n\n    self.log.debug(f\"Launch of {self.application.full_name} finished.\")\n\n    return self.process\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.paths_to_launch_hooks","title":"<code>paths_to_launch_hooks()</code>","text":"<p>Directory paths where to look for launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def paths_to_launch_hooks(self) -&gt; list[str]:\n    \"\"\"Directory paths where to look for launch hooks.\"\"\"\n    # This method has potential to be part of application manager (maybe).\n    paths = []\n\n    # TODO load additional studio paths from settings\n    global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n    hooks_dirs = [\n        global_hooks_dir\n    ]\n    if self.host_name:\n        # If host requires launch hooks and is module then launch hooks\n        #   should be collected using 'collect_launch_hook_paths'\n        #   - module have to implement 'get_launch_hook_paths'\n        host_module = self.addons_manager.get_host_addon(self.host_name)\n        if not host_module:\n            hooks_dirs.append(os.path.join(\n                AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n            ))\n\n    for path in hooks_dirs:\n        if (\n            os.path.exists(path)\n            and os.path.isdir(path)\n            and path not in paths\n        ):\n            paths.append(path)\n\n    # Load modules paths\n    paths.extend(self._collect_addons_launch_hook_paths())\n\n    return paths\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.run_prelaunch_hooks","title":"<code>run_prelaunch_hooks()</code>","text":"<p>Run prelaunch hooks.</p> <p>This method will be executed only once, any future calls will skip the processing.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>When prelaunch hooks were already executed.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def run_prelaunch_hooks(self) -&gt; None:\n    \"\"\"Run prelaunch hooks.\n\n    This method will be executed only once, any future calls will skip\n    the processing.\n\n    Raises:\n        RuntimeError: When prelaunch hooks were already executed.\n\n    \"\"\"\n    if self._prelaunch_hooks_executed:\n        self.log.warning(\"Prelaunch hooks were already executed.\")\n        return\n    # Discover launch hooks\n    self.discover_launch_hooks()\n\n    # Execute prelaunch hooks\n    for hook in self.prelaunch_hooks:\n        self.log.debug(\n            f\"Executing prelaunch hook: {hook.__class__.__name__}\"\n        )\n        hook.execute()\n    self._prelaunch_hooks_executed = True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchFailed","title":"<code>ApplicationLaunchFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application launch failed due to known reason.</p> <p>Message should be self explanatory as traceback won't be shown.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationLaunchFailed(Exception):\n    \"\"\"Application launch failed due to known reason.\n\n    Message should be self explanatory as traceback won't be shown.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager","title":"<code>ApplicationManager</code>","text":"<p>Load applications and tools and store them by their full name.</p> <p>Parameters:</p> Name Type Description Default <code>studio_settings</code> <code>dict</code> <p>Preloaded studio settings. When passed manager will always use these values. Gives ability to create manager using different settings.</p> <code>None</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationManager:\n    \"\"\"Load applications and tools and store them by their full name.\n\n    Args:\n        studio_settings (dict): Preloaded studio settings. When passed manager\n            will always use these values. Gives ability to create manager\n            using different settings.\n    \"\"\"\n\n    def __init__(self, studio_settings: Optional[dict[str, Any]] = None):\n        self.log = Logger.get_logger(self.__class__.__name__)\n\n        self.app_groups: dict[str, ApplicationGroup] = {}\n        self.applications: dict[str, Application] = {}\n        self.tool_groups: dict[str, EnvironmentToolGroup] = {}\n        self.tools: dict[str, EnvironmentTool] = {}\n\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def set_studio_settings(self, studio_settings: dict[str, Any]) -&gt; None:\n        \"\"\"Ability to change init system settings.\n\n        This will trigger refresh of manager.\n        \"\"\"\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refresh applications from settings.\"\"\"\n        self.app_groups.clear()\n        self.applications.clear()\n        self.tool_groups.clear()\n        self.tools.clear()\n\n        if self._studio_settings is not None:\n            settings = copy.deepcopy(self._studio_settings)\n        else:\n            settings = get_studio_settings(\n                clear_metadata=False, exclude_locals=False\n            )\n\n        applications_addon_settings = settings[\"applications\"]\n\n        # Prepare known applications\n        app_defs = applications_addon_settings[\"applications\"]\n        additional_apps = app_defs.pop(\"additional_apps\")\n        for additional_app in additional_apps:\n            app_name = additional_app.pop(\"name\")\n            if app_name in app_defs:\n                self.log.warning(\n                    f\"Additional application '{app_name}' is already\"\n                    \" in built-in applications.\"\n                )\n            app_defs[app_name] = additional_app\n\n        for group_name, variant_defs in app_defs.items():\n            group = ApplicationGroup(group_name, variant_defs, self)\n            self.app_groups[group_name] = group\n            for app in group:\n                self.applications[app.full_name] = app\n\n        tools_definitions = applications_addon_settings[\"tool_groups\"]\n        for tool_group_data in tools_definitions:\n            group = EnvironmentToolGroup(tool_group_data, self)\n            self.tool_groups[group.name] = group\n            for tool in group:\n                self.tools[tool.full_name] = tool\n\n    def find_latest_available_variant_for_group(\n        self, group_name: str\n    ) -&gt; Optional[ApplicationGroup]:\n        group = self.app_groups.get(group_name)\n        if group is None or not group.enabled:\n            return None\n\n        output = None\n        for _, variant in reversed(sorted(group.variants.items())):\n            executable = variant.find_executable()\n            if executable:\n                output = variant\n                break\n        return output\n\n    def create_launch_context(\n        self, app_name: str, **data\n    ) -&gt; \"ApplicationLaunchContext\":\n        \"\"\"Prepare launch context for application.\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n\n        Returns:\n            ApplicationLaunchContext: Launch context for application.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered name.\n        \"\"\"\n\n        app = self.applications.get(app_name)\n        if not app:\n            raise ApplicationNotFound(app_name)\n\n        executable = app.find_executable()\n\n        return ApplicationLaunchContext(\n            app, executable, **data\n        )\n\n    def launch_with_context(\n        self, launch_context: \"ApplicationLaunchContext\"\n    ) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Launch application using existing launch context.\n\n        Args:\n            launch_context (ApplicationLaunchContext): Prepared launch\n                context.\n        \"\"\"\n\n        if not launch_context.executable:\n            raise ApplicationExecutableNotFound(launch_context.application)\n        return launch_context.launch()\n\n    def launch(self, app_name, **data) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Launch procedure.\n\n        For host application it's expected to contain \"project_name\",\n        \"folder_path\" and \"task_name\".\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n                preparation to store objects usable in multiple places.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered\n                argument `app_name`.\n            ApplicationExecutableNotFound: Executables in application\n                definition were not found on this machine.\n            ApplicationLaunchFailed: Something important for application launch\n                failed. Exception should contain an explanation message,\n                traceback should not be needed.\n\n        \"\"\"\n        context = self.create_launch_context(app_name, **data)\n        return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.create_launch_context","title":"<code>create_launch_context(app_name, **data)</code>","text":"<p>Prepare launch context for application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ApplicationLaunchContext</code> <code>'ApplicationLaunchContext'</code> <p>Launch context for application.</p> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered name.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def create_launch_context(\n    self, app_name: str, **data\n) -&gt; \"ApplicationLaunchContext\":\n    \"\"\"Prepare launch context for application.\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n\n    Returns:\n        ApplicationLaunchContext: Launch context for application.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered name.\n    \"\"\"\n\n    app = self.applications.get(app_name)\n    if not app:\n        raise ApplicationNotFound(app_name)\n\n    executable = app.find_executable()\n\n    return ApplicationLaunchContext(\n        app, executable, **data\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.launch","title":"<code>launch(app_name, **data)</code>","text":"<p>Launch procedure.</p> <p>For host application it's expected to contain \"project_name\", \"folder_path\" and \"task_name\".</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered argument <code>app_name</code>.</p> <code>ApplicationExecutableNotFound</code> <p>Executables in application definition were not found on this machine.</p> <code>ApplicationLaunchFailed</code> <p>Something important for application launch failed. Exception should contain an explanation message, traceback should not be needed.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self, app_name, **data) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Launch procedure.\n\n    For host application it's expected to contain \"project_name\",\n    \"folder_path\" and \"task_name\".\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered\n            argument `app_name`.\n        ApplicationExecutableNotFound: Executables in application\n            definition were not found on this machine.\n        ApplicationLaunchFailed: Something important for application launch\n            failed. Exception should contain an explanation message,\n            traceback should not be needed.\n\n    \"\"\"\n    context = self.create_launch_context(app_name, **data)\n    return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.launch_with_context","title":"<code>launch_with_context(launch_context)</code>","text":"<p>Launch application using existing launch context.</p> <p>Parameters:</p> Name Type Description Default <code>launch_context</code> <code>ApplicationLaunchContext</code> <p>Prepared launch context.</p> required Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch_with_context(\n    self, launch_context: \"ApplicationLaunchContext\"\n) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Launch application using existing launch context.\n\n    Args:\n        launch_context (ApplicationLaunchContext): Prepared launch\n            context.\n    \"\"\"\n\n    if not launch_context.executable:\n        raise ApplicationExecutableNotFound(launch_context.application)\n    return launch_context.launch()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.refresh","title":"<code>refresh()</code>","text":"<p>Refresh applications from settings.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh applications from settings.\"\"\"\n    self.app_groups.clear()\n    self.applications.clear()\n    self.tool_groups.clear()\n    self.tools.clear()\n\n    if self._studio_settings is not None:\n        settings = copy.deepcopy(self._studio_settings)\n    else:\n        settings = get_studio_settings(\n            clear_metadata=False, exclude_locals=False\n        )\n\n    applications_addon_settings = settings[\"applications\"]\n\n    # Prepare known applications\n    app_defs = applications_addon_settings[\"applications\"]\n    additional_apps = app_defs.pop(\"additional_apps\")\n    for additional_app in additional_apps:\n        app_name = additional_app.pop(\"name\")\n        if app_name in app_defs:\n            self.log.warning(\n                f\"Additional application '{app_name}' is already\"\n                \" in built-in applications.\"\n            )\n        app_defs[app_name] = additional_app\n\n    for group_name, variant_defs in app_defs.items():\n        group = ApplicationGroup(group_name, variant_defs, self)\n        self.app_groups[group_name] = group\n        for app in group:\n            self.applications[app.full_name] = app\n\n    tools_definitions = applications_addon_settings[\"tool_groups\"]\n    for tool_group_data in tools_definitions:\n        group = EnvironmentToolGroup(tool_group_data, self)\n        self.tool_groups[group.name] = group\n        for tool in group:\n            self.tools[tool.full_name] = tool\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.set_studio_settings","title":"<code>set_studio_settings(studio_settings)</code>","text":"<p>Ability to change init system settings.</p> <p>This will trigger refresh of manager.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def set_studio_settings(self, studio_settings: dict[str, Any]) -&gt; None:\n    \"\"\"Ability to change init system settings.\n\n    This will trigger refresh of manager.\n    \"\"\"\n    self._studio_settings = studio_settings\n\n    self.refresh()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationNotFound","title":"<code>ApplicationNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application was not found in ApplicationManager by name.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationNotFound(Exception):\n    \"\"\"Application was not found in ApplicationManager by name.\"\"\"\n\n    def __init__(self, app_name):\n        self.app_name = app_name\n        super().__init__(\n            f\"Application \\\"{app_name}\\\" was not found.\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IPluginPaths</code>, <code>ITrayAction</code></p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>class ApplicationsAddon(AYONAddon, IPluginPaths, ITrayAction):\n\n    name = \"applications\"\n    version = __version__\n    admin_action = True\n\n    def tray_init(self) -&gt; None:\n        \"\"\"Initialize the tray action.\"\"\"\n        self._process_monitor_window: Optional[ProcessMonitorWindow] = None\n\n    @property\n    def label(self) -&gt; str:\n        return \"Process Monitor\"\n\n    def on_action_trigger(self) -&gt; None:\n        \"\"\"Action triggered when the tray icon is clicked.\"\"\"\n        from ayon_applications.ui.process_monitor import (\n            ProcessMonitorWindow,\n        )\n        if self._process_monitor_window is None:\n            self._process_monitor_window = ProcessMonitorWindow()\n\n        self._process_monitor_window.show()\n        self._process_monitor_window.raise_()\n        self._process_monitor_window.activateWindow()\n\n    def get_app_environments_for_context(\n        self,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        full_app_name: str,\n        env_group: Optional[str] = None,\n        launch_type: Optional[str] = None,\n        env: Optional[dict[str, str]] = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Calculate environment variables for launch context.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            full_app_name (str): Full application name.\n            env_group (Optional[str]): Environment group.\n            launch_type (Optional[str]): Launch type.\n            env (Optional[dict[str, str]]): Environment variables to update.\n\n        Returns:\n            dict[str, str]: Environment variables for context.\n\n        \"\"\"\n        from ayon_applications.utils import get_app_environments_for_context\n\n        if not full_app_name:\n            return {}\n\n        return get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=launch_type,\n            env=env,\n            addons_manager=self.manager\n        )\n\n    def get_farm_publish_environment_variables(\n        self,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        full_app_name: Optional[str] = None,\n        env_group: Optional[str] = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Calculate environment variables for farm publish.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            env_group (Optional[str]): Environment group.\n            full_app_name (Optional[str]): Full application name. Value from\n                environment variable 'AYON_APP_NAME' is used if 'None' is\n                passed.\n\n        Returns:\n            dict[str, str]: Environment variables for farm publish.\n\n        \"\"\"\n        if full_app_name is None:\n            full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n        return self.get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=LaunchTypes.farm_publish\n        )\n\n    def get_applications_manager(\n        self, settings: Optional[dict[str, Any]] = None\n    ) -&gt; \"ApplicationManager\":\n        \"\"\"Get applications manager.\n\n        Args:\n            settings (Optional[dict]): Studio/project settings.\n\n        Returns:\n            ApplicationManager: Applications manager.\n\n        \"\"\"\n        return ApplicationManager(settings)\n\n    def get_plugin_paths(self) -&gt; dict[str, list[str]]:\n        return {}\n\n    def get_publish_plugin_paths(self, host_name: str) -&gt; list[str]:\n        return [\n            os.path.join(APPLICATIONS_ADDON_ROOT, \"plugins\", \"publish\")\n        ]\n\n    def get_launch_hook_paths(self, app: \"Application\") -&gt; list[str]:\n        return [\n            os.path.join(APPLICATIONS_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_app_icon_path(self, icon_filename: str) -&gt; str:\n        \"\"\"Get icon path.\n\n        Args:\n            icon_filename (str): Icon filename.\n\n        Returns:\n            Optional[str]: Icon path or None if not found.\n\n        \"\"\"\n        return get_app_icon_path(icon_filename)\n\n    def get_app_icon_url(\n        self, icon_filename: str, server: bool = False\n    ) -&gt; Optional[str]:\n        \"\"\"Get icon path.\n\n        Method does not validate if icon filename exist on server.\n\n        Args:\n            icon_filename (str): Icon name.\n            server (Optional[bool]): Return url to AYON server.\n\n        Returns:\n            Union[str, None]: Icon path or None is server url is not\n                available.\n\n        \"\"\"\n        if not icon_filename:\n            return None\n        icon_name = os.path.basename(icon_filename)\n        if server:\n            base_url = ayon_api.get_base_url()\n            return (\n                f\"{base_url}/addons/{self.name}/{self.version}\"\n                f\"/public/icons/{icon_name}\"\n            )\n        server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n        if not server_url:\n            return None\n        return \"/\".join([\n            server_url, \"addons\", self.name, \"icons\", icon_name\n        ])\n\n    def launch_application(\n        self,\n        app_name: str,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        workfile_path: Optional[str] = None,\n        use_last_workfile: Optional[bool] = None,\n    ):\n        \"\"\"Launch application.\n\n        Args:\n            app_name (str): Full application name e.g. 'maya/2024'.\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            workfile_path (Optional[str]): Workfile path to use.\n            use_last_workfile (Optional[bool]): Explicitly tell to use or\n                not use last workfile. Ignored if 'workfile_path' is passed.\n\n        \"\"\"\n        ensure_addons_are_process_ready(\n            addon_name=self.name,\n            addon_version=self.version,\n            project_name=project_name,\n        )\n        headless = is_headless_mode_enabled()\n\n        data = {\n            \"project_name\": project_name,\n            \"folder_path\": folder_path,\n            \"task_name\": task_name,\n        }\n        # Backwards compatibility 'workfile_path' was added\n        #   before 'use_last_workfile'\n        if isinstance(workfile_path, bool):\n            use_last_workfile = workfile_path\n            workfile_path = None\n            warnings.warn(\n                \"Passed 'use_last_workfile' as positional argument.\"\n                \" Use explicit 'use_last_workfile' keyword argument instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        if workfile_path:\n            data[\"workfile_path\"] = workfile_path\n            # Backwards compatibility to be able to use 'workfile_path'\n            #   argument with older ayon-core\n            # use_last_workfile = False\n            data[\"last_workfile_path\"] = workfile_path\n            data[\"start_last_workfile\"] = True\n\n        elif use_last_workfile is not None:\n            data[\"start_last_workfile\"] = use_last_workfile\n\n        # TODO handle raise errors\n        failed = True\n        message = None\n        detail = None\n        try:\n            app_manager = self.get_applications_manager()\n            app_manager.launch(app_name, **data)\n            failed = False\n\n        except (\n            ApplicationLaunchFailed,\n            ApplicationExecutableNotFound,\n            ApplicationNotFound,\n        ) as exc:\n            message = str(exc)\n            self.log.warning(f\"Application launch failed: {message}\")\n\n        except Exception as exc:\n            message = \"An unexpected error happened\"\n            detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n            self.log.warning(\n                f\"Application launch failed: {str(exc)}\",\n                exc_info=True\n            )\n\n        if not failed:\n            return\n\n        if not headless:\n            self._show_launch_error_dialog(message, detail)\n        sys.exit(1)\n\n    def webserver_initialization(self, manager: \"WebServerManager\") -&gt; None:\n        \"\"\"Initialize webserver.\n\n        Args:\n            manager (WebServerManager): Webserver manager.\n\n        \"\"\"\n        static_prefix = f\"/addons/{self.name}/icons\"\n        manager.add_static(\n            static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n        )\n\n    # --- CLI ---\n    def cli(self, addon_click_group) -&gt; None:\n        main_group = click_wrap.group(\n            self._cli_main, name=self.name, help=\"Applications addon\"\n        )\n        (\n            main_group.command(\n                self._cli_extract_environments,\n                name=\"extractenvironments\",\n                help=(\n                    \"Extract environment variables for context into json file\"\n                )\n            )\n            .argument(\"output_json_path\")\n            .option(\"--project\", help=\"Project name\", default=None)\n            .option(\"--folder\", help=\"Folder path\", default=None)\n            .option(\"--task\", help=\"Task name\", default=None)\n            .option(\"--app\", help=\"Full application name\", default=None)\n            .option(\n                \"--envgroup\",\n                help=\"Environment group (e.g. \\\"farm\\\")\",\n                default=None\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_context_names,\n                name=\"launch\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--folder\", required=True, help=\"Folder path\")\n            .option(\"--task\", required=True, help=\"Task name\")\n            .option(\n                \"--use-last-workfile\",\n                help=\"Use last workfile\",\n                default=None,\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_with_task_id,\n                name=\"launch-by-id\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--task-id\", required=True, help=\"Task id\")\n            .option(\n                \"--use-last-workfile\",\n                help=\"Use last workfile\",\n                default=None,\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_with_workfile_id,\n                name=\"launch-by-workfile-id\",\n                help=\"Launch application using workfile id\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--workfile-id\", required=True, help=\"Workfile id\")\n        )\n        (\n            main_group.command(\n                self._cli_launch_with_debug_terminal,\n                name=\"launch-debug-terminal\",\n                help=\"Launch with debug terminal\"\n            )\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--task-id\", required=True, help=\"Task id\")\n            .option(\n                \"--app\",\n                required=False,\n                help=\"Full application name\",\n                default=None,\n            )\n        )\n        # Convert main command to click object and add it to parent group\n        addon_click_group.add_command(\n            main_group.to_click_obj()\n        )\n\n    def _cli_main(self) -&gt; None:\n        pass\n\n    def _cli_extract_environments(\n        self,\n        output_json_path: str,\n        project: str,\n        folder: str,\n        task: str,\n        app: str,\n        envgroup: str,\n    ) -&gt; None:\n        \"\"\"Produces json file with environment based on project and app.\n\n        Called by farm integration to propagate environment into farm jobs.\n\n        Args:\n            output_json_path (str): Output json file path.\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n            envgroup (str): Environment group.\n\n        \"\"\"\n        if all((project, folder, task, app)):\n            env = self.get_farm_publish_environment_variables(\n                project, folder, task, app, env_group=envgroup,\n            )\n        else:\n            env = os.environ.copy()\n\n        output_dir = os.path.dirname(output_json_path)\n        os.makedirs(output_dir, exist_ok=True)\n\n        with open(output_json_path, \"w\") as file_stream:\n            json.dump(env, file_stream, indent=4)\n\n    def _cli_launch_context_names(\n        self,\n        project: str,\n        folder: str,\n        task: str,\n        app: str,\n        use_last_workfile: Optional[\"BoolArg\"],\n    ) -&gt; None:\n        \"\"\"Launch application.\n\n        Args:\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n            use_last_workfile (Optional[Literal[\"1\", \"0\"]): Explicitly tell\n                to use last workfile.\n\n        \"\"\"\n        if use_last_workfile is not None:\n            use_last_workfile = env_value_to_bool(\n                use_last_workfile, default=None\n            )\n        self.launch_application(\n            app, project, folder, task, use_last_workfile=use_last_workfile,\n        )\n\n    def _cli_launch_with_task_id(\n        self,\n        project: str,\n        task_id: str,\n        app: str,\n        use_last_workfile: Optional[\"BoolArg\"],\n    ) -&gt; None:\n        \"\"\"Launch application using project name, task id and full app name.\n\n        Args:\n            project (str): Project name.\n            task_id (str): Task id.\n            app (str): Full application name e.g. 'maya/2024'.\n            use_last_workfile (Optional[Literal[\"1\", \"0\"]): Explicitly tell\n                to use last workfile.\n\n        \"\"\"\n        if use_last_workfile is not None:\n            use_last_workfile = env_value_to_bool(\n                value=use_last_workfile, default=None\n            )\n\n        task_entity = ayon_api.get_task_by_id(\n            project, task_id, fields={\"name\", \"folderId\"}\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project, task_entity[\"folderId\"], fields={\"path\"}\n        )\n        self.launch_application(\n            app,\n            project,\n            folder_entity[\"path\"],\n            task_entity[\"name\"],\n            use_last_workfile=use_last_workfile,\n        )\n\n    def _cli_launch_with_workfile_id(\n        self,\n        project: str,\n        workfile_id: str,\n        app: str,\n    ) -&gt; None:\n        from ayon_core.pipeline import Anatomy\n\n        workfile_entity = ayon_api.get_workfile_info_by_id(\n            project, workfile_id\n        )\n        task_id = workfile_entity[\"taskId\"]\n        task_entity = ayon_api.get_task_by_id(\n            project, task_id, fields={\"name\", \"folderId\"}\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project, task_entity[\"folderId\"], fields={\"path\"}\n        )\n        anatomy = Anatomy(project)\n        workfile_path = anatomy.fill_root(workfile_entity[\"path\"])\n        self.launch_application(\n            app,\n            project,\n            folder_entity[\"path\"],\n            task_entity[\"name\"],\n            workfile_path=workfile_path,\n        )\n\n    def _cli_launch_with_debug_terminal(\n        self,\n        project: str,\n        task_id: str,\n        app: Optional[str],\n    ) -&gt; None:\n        from .ui.debug_terminal_launch import run_with_debug_terminal\n\n        run_with_debug_terminal(self, project, task_id, app)\n\n    def _show_launch_error_dialog(self, message: str, detail: str) -&gt; None:\n        script_path = os.path.join(\n            APPLICATIONS_ADDON_ROOT, \"ui\", \"launch_failed_dialog.py\"\n        )\n        with tempfile.NamedTemporaryFile(\"w\", delete=False) as tmp:\n            tmp_path = tmp.name\n            json.dump(\n                {\"message\": message, \"detail\": detail},\n                tmp.file\n            )\n\n        try:\n            run_ayon_launcher_process(\n                \"--skip-bootstrap\",\n                script_path,\n                tmp_path,\n                add_sys_paths=True,\n                creationflags=0,\n            )\n\n        finally:\n            os.remove(tmp_path)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_app_environments_for_context","title":"<code>get_app_environments_for_context(project_name, folder_path, task_name, full_app_name, env_group=None, launch_type=None, env=None)</code>","text":"<p>Calculate environment variables for launch context.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>full_app_name</code> <code>str</code> <p>Full application name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type.</p> <code>None</code> <code>env</code> <code>Optional[dict[str, str]]</code> <p>Environment variables to update.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Environment variables for context.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_environments_for_context(\n    self,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    full_app_name: str,\n    env_group: Optional[str] = None,\n    launch_type: Optional[str] = None,\n    env: Optional[dict[str, str]] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Calculate environment variables for launch context.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        full_app_name (str): Full application name.\n        env_group (Optional[str]): Environment group.\n        launch_type (Optional[str]): Launch type.\n        env (Optional[dict[str, str]]): Environment variables to update.\n\n    Returns:\n        dict[str, str]: Environment variables for context.\n\n    \"\"\"\n    from ayon_applications.utils import get_app_environments_for_context\n\n    if not full_app_name:\n        return {}\n\n    return get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=launch_type,\n        env=env,\n        addons_manager=self.manager\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_app_icon_path","title":"<code>get_app_icon_path(icon_filename)</code>","text":"<p>Get icon path.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon filename.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Optional[str]: Icon path or None if not found.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_path(self, icon_filename: str) -&gt; str:\n    \"\"\"Get icon path.\n\n    Args:\n        icon_filename (str): Icon filename.\n\n    Returns:\n        Optional[str]: Icon path or None if not found.\n\n    \"\"\"\n    return get_app_icon_path(icon_filename)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_app_icon_url","title":"<code>get_app_icon_url(icon_filename, server=False)</code>","text":"<p>Get icon path.</p> <p>Method does not validate if icon filename exist on server.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon name.</p> required <code>server</code> <code>Optional[bool]</code> <p>Return url to AYON server.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Union[str, None]: Icon path or None is server url is not available.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_url(\n    self, icon_filename: str, server: bool = False\n) -&gt; Optional[str]:\n    \"\"\"Get icon path.\n\n    Method does not validate if icon filename exist on server.\n\n    Args:\n        icon_filename (str): Icon name.\n        server (Optional[bool]): Return url to AYON server.\n\n    Returns:\n        Union[str, None]: Icon path or None is server url is not\n            available.\n\n    \"\"\"\n    if not icon_filename:\n        return None\n    icon_name = os.path.basename(icon_filename)\n    if server:\n        base_url = ayon_api.get_base_url()\n        return (\n            f\"{base_url}/addons/{self.name}/{self.version}\"\n            f\"/public/icons/{icon_name}\"\n        )\n    server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n    if not server_url:\n        return None\n    return \"/\".join([\n        server_url, \"addons\", self.name, \"icons\", icon_name\n    ])\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_applications_manager","title":"<code>get_applications_manager(settings=None)</code>","text":"<p>Get applications manager.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Optional[dict]</code> <p>Studio/project settings.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ApplicationManager</code> <code>'ApplicationManager'</code> <p>Applications manager.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_applications_manager(\n    self, settings: Optional[dict[str, Any]] = None\n) -&gt; \"ApplicationManager\":\n    \"\"\"Get applications manager.\n\n    Args:\n        settings (Optional[dict]): Studio/project settings.\n\n    Returns:\n        ApplicationManager: Applications manager.\n\n    \"\"\"\n    return ApplicationManager(settings)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_farm_publish_environment_variables","title":"<code>get_farm_publish_environment_variables(project_name, folder_path, task_name, full_app_name=None, env_group=None)</code>","text":"<p>Calculate environment variables for farm publish.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>full_app_name</code> <code>Optional[str]</code> <p>Full application name. Value from environment variable 'AYON_APP_NAME' is used if 'None' is passed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Environment variables for farm publish.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_farm_publish_environment_variables(\n    self,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    full_app_name: Optional[str] = None,\n    env_group: Optional[str] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Calculate environment variables for farm publish.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        env_group (Optional[str]): Environment group.\n        full_app_name (Optional[str]): Full application name. Value from\n            environment variable 'AYON_APP_NAME' is used if 'None' is\n            passed.\n\n    Returns:\n        dict[str, str]: Environment variables for farm publish.\n\n    \"\"\"\n    if full_app_name is None:\n        full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n    return self.get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=LaunchTypes.farm_publish\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.launch_application","title":"<code>launch_application(app_name, project_name, folder_path, task_name, workfile_path=None, use_last_workfile=None)</code>","text":"<p>Launch application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Full application name e.g. 'maya/2024'.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>workfile_path</code> <code>Optional[str]</code> <p>Workfile path to use.</p> <code>None</code> <code>use_last_workfile</code> <code>Optional[bool]</code> <p>Explicitly tell to use or not use last workfile. Ignored if 'workfile_path' is passed.</p> <code>None</code> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def launch_application(\n    self,\n    app_name: str,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    workfile_path: Optional[str] = None,\n    use_last_workfile: Optional[bool] = None,\n):\n    \"\"\"Launch application.\n\n    Args:\n        app_name (str): Full application name e.g. 'maya/2024'.\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        workfile_path (Optional[str]): Workfile path to use.\n        use_last_workfile (Optional[bool]): Explicitly tell to use or\n            not use last workfile. Ignored if 'workfile_path' is passed.\n\n    \"\"\"\n    ensure_addons_are_process_ready(\n        addon_name=self.name,\n        addon_version=self.version,\n        project_name=project_name,\n    )\n    headless = is_headless_mode_enabled()\n\n    data = {\n        \"project_name\": project_name,\n        \"folder_path\": folder_path,\n        \"task_name\": task_name,\n    }\n    # Backwards compatibility 'workfile_path' was added\n    #   before 'use_last_workfile'\n    if isinstance(workfile_path, bool):\n        use_last_workfile = workfile_path\n        workfile_path = None\n        warnings.warn(\n            \"Passed 'use_last_workfile' as positional argument.\"\n            \" Use explicit 'use_last_workfile' keyword argument instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if workfile_path:\n        data[\"workfile_path\"] = workfile_path\n        # Backwards compatibility to be able to use 'workfile_path'\n        #   argument with older ayon-core\n        # use_last_workfile = False\n        data[\"last_workfile_path\"] = workfile_path\n        data[\"start_last_workfile\"] = True\n\n    elif use_last_workfile is not None:\n        data[\"start_last_workfile\"] = use_last_workfile\n\n    # TODO handle raise errors\n    failed = True\n    message = None\n    detail = None\n    try:\n        app_manager = self.get_applications_manager()\n        app_manager.launch(app_name, **data)\n        failed = False\n\n    except (\n        ApplicationLaunchFailed,\n        ApplicationExecutableNotFound,\n        ApplicationNotFound,\n    ) as exc:\n        message = str(exc)\n        self.log.warning(f\"Application launch failed: {message}\")\n\n    except Exception as exc:\n        message = \"An unexpected error happened\"\n        detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n        self.log.warning(\n            f\"Application launch failed: {str(exc)}\",\n            exc_info=True\n        )\n\n    if not failed:\n        return\n\n    if not headless:\n        self._show_launch_error_dialog(message, detail)\n    sys.exit(1)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.on_action_trigger","title":"<code>on_action_trigger()</code>","text":"<p>Action triggered when the tray icon is clicked.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def on_action_trigger(self) -&gt; None:\n    \"\"\"Action triggered when the tray icon is clicked.\"\"\"\n    from ayon_applications.ui.process_monitor import (\n        ProcessMonitorWindow,\n    )\n    if self._process_monitor_window is None:\n        self._process_monitor_window = ProcessMonitorWindow()\n\n    self._process_monitor_window.show()\n    self._process_monitor_window.raise_()\n    self._process_monitor_window.activateWindow()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.tray_init","title":"<code>tray_init()</code>","text":"<p>Initialize the tray action.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def tray_init(self) -&gt; None:\n    \"\"\"Initialize the tray action.\"\"\"\n    self._process_monitor_window: Optional[ProcessMonitorWindow] = None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.webserver_initialization","title":"<code>webserver_initialization(manager)</code>","text":"<p>Initialize webserver.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>WebServerManager</code> <p>Webserver manager.</p> required Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def webserver_initialization(self, manager: \"WebServerManager\") -&gt; None:\n    \"\"\"Initialize webserver.\n\n    Args:\n        manager (WebServerManager): Webserver manager.\n\n    \"\"\"\n    static_prefix = f\"/addons/{self.name}/icons\"\n    manager.add_static(\n        static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.EnvironmentTool","title":"<code>EnvironmentTool</code>","text":"<p>Hold information about application tool.</p> <p>Structure of tool information.</p> <p>Parameters:</p> Name Type Description Default <code>variant_data</code> <code>dict</code> <p>Variant data with environments and host and app variant filters.</p> required <code>group</code> <code>EnvironmentToolGroup</code> <p>Name of group which wraps tool.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentTool:\n    \"\"\"Hold information about application tool.\n\n    Structure of tool information.\n\n    Args:\n        variant_data (dict): Variant data with environments and\n            host and app variant filters.\n        group (EnvironmentToolGroup): Name of group which wraps tool.\n\n    \"\"\"\n    def __init__(\n        self,\n        variant_data: dict[str, Any],\n        group: EnvironmentToolGroup,\n    ):\n        # Backwards compatibility 3.9.1 - 3.9.2\n        # - 'variant_data' contained only environments but contain also host\n        #   and application variant filters\n        name = variant_data[\"name\"]\n        label = variant_data[\"label\"]\n        host_names = variant_data[\"host_names\"]\n        app_variants = variant_data[\"app_variants\"]\n\n        environment = {}\n        try:\n            environment = json.loads(variant_data[\"environment\"])\n        except Exception:\n            pass\n\n        self.host_names = host_names\n        self.app_variants = app_variants\n        self.name = name\n        self.variant_label = label\n        self.label = \" \".join((group.label, label))\n        self.group = group\n\n        self._environment = environment\n        self.full_name = \"/\".join((group.name, name))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.full_name}\"\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n\n    def is_valid_for_app(self, app: Application) -&gt; bool:\n        \"\"\"Is tool valid for an application.\n\n        Args:\n            app (Application): Application for which are prepared environments.\n\n        \"\"\"\n        if self.app_variants and app.full_name not in self.app_variants:\n            return False\n\n        if self.host_names and app.host_name not in self.host_names:\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.EnvironmentTool.is_valid_for_app","title":"<code>is_valid_for_app(app)</code>","text":"<p>Is tool valid for an application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>Application for which are prepared environments.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def is_valid_for_app(self, app: Application) -&gt; bool:\n    \"\"\"Is tool valid for an application.\n\n    Args:\n        app (Application): Application for which are prepared environments.\n\n    \"\"\"\n    if self.app_variants and app.full_name not in self.app_variants:\n        return False\n\n    if self.host_names and app.host_name not in self.host_names:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.EnvironmentToolGroup","title":"<code>EnvironmentToolGroup</code>","text":"<p>Hold information about environment tool group.</p> <p>Environment tool group may hold different variants of same tool and set environments that are same for all of them.</p> <p>e.g. \"mtoa\" may have different versions but all environments except one     are same.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Group information with variants.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that creates the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentToolGroup:\n    \"\"\"Hold information about environment tool group.\n\n    Environment tool group may hold different variants of same tool and set\n    environments that are same for all of them.\n\n    e.g. \"mtoa\" may have different versions but all environments except one\n        are same.\n\n    Args:\n        data (dict): Group information with variants.\n        manager (ApplicationManager): Manager that creates the group.\n\n    \"\"\"\n    def __init__(\n        self,\n        data: dict[str, Any],\n        manager: \"ApplicationManager\",\n    ):\n        name = data[\"name\"]\n        label = data[\"label\"]\n\n        self.name = name\n        self.label = label\n        self._data = data\n        self.manager = manager\n\n        environment = {}\n        try:\n            environment = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = environment\n\n        variants = data.get(\"variants\") or []\n        variants_by_name = {}\n        for variant_data in variants:\n            tool = EnvironmentTool(variant_data, self)\n            variants_by_name[tool.name] = tool\n        self.variants = variants_by_name\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.name}\"\n\n    def __iter__(self) -&gt; Generator[\"EnvironmentTool\", None, None]:\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.LaunchTypes","title":"<code>LaunchTypes</code>","text":"<p>Launch types are filters for pre/post-launch hooks.</p> <p>Please use these variables in case they'll change values.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class LaunchTypes:\n    \"\"\"Launch types are filters for pre/post-launch hooks.\n\n    Please use these variables in case they'll change values.\n    \"\"\"\n\n    # Local launch - application is launched on local machine\n    local = \"local\"\n    # Farm render job - application is on farm\n    farm_render = \"farm-render\"\n    # Farm publish job - integration post-render job\n    farm_publish = \"farm-publish\"\n    # Remote launch - application is launched on remote machine from which\n    #     can be started publishing\n    remote = \"remote\"\n    # Automated launch - application is launched with automated publishing\n    automated = \"automated\"\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.UndefinedApplicationExecutable","title":"<code>UndefinedApplicationExecutable</code>","text":"<p>               Bases: <code>ApplicationExecutable</code></p> <p>Some applications do not require executable path from settings.</p> <p>In that case this class is used to \"fake\" existing executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class UndefinedApplicationExecutable(ApplicationExecutable):\n    \"\"\"Some applications do not require executable path from settings.\n\n    In that case this class is used to \"fake\" existing executable.\n    \"\"\"\n    def __init__(self):\n        pass\n\n    def __str__(self) -&gt; str:\n        return self.__class__.__name__\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt;\"\n\n    def as_args(self) -&gt; list[str]:\n        return []\n\n    def exists(self) -&gt; bool:\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IPluginPaths</code>, <code>ITrayAction</code></p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>class ApplicationsAddon(AYONAddon, IPluginPaths, ITrayAction):\n\n    name = \"applications\"\n    version = __version__\n    admin_action = True\n\n    def tray_init(self) -&gt; None:\n        \"\"\"Initialize the tray action.\"\"\"\n        self._process_monitor_window: Optional[ProcessMonitorWindow] = None\n\n    @property\n    def label(self) -&gt; str:\n        return \"Process Monitor\"\n\n    def on_action_trigger(self) -&gt; None:\n        \"\"\"Action triggered when the tray icon is clicked.\"\"\"\n        from ayon_applications.ui.process_monitor import (\n            ProcessMonitorWindow,\n        )\n        if self._process_monitor_window is None:\n            self._process_monitor_window = ProcessMonitorWindow()\n\n        self._process_monitor_window.show()\n        self._process_monitor_window.raise_()\n        self._process_monitor_window.activateWindow()\n\n    def get_app_environments_for_context(\n        self,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        full_app_name: str,\n        env_group: Optional[str] = None,\n        launch_type: Optional[str] = None,\n        env: Optional[dict[str, str]] = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Calculate environment variables for launch context.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            full_app_name (str): Full application name.\n            env_group (Optional[str]): Environment group.\n            launch_type (Optional[str]): Launch type.\n            env (Optional[dict[str, str]]): Environment variables to update.\n\n        Returns:\n            dict[str, str]: Environment variables for context.\n\n        \"\"\"\n        from ayon_applications.utils import get_app_environments_for_context\n\n        if not full_app_name:\n            return {}\n\n        return get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=launch_type,\n            env=env,\n            addons_manager=self.manager\n        )\n\n    def get_farm_publish_environment_variables(\n        self,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        full_app_name: Optional[str] = None,\n        env_group: Optional[str] = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Calculate environment variables for farm publish.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            env_group (Optional[str]): Environment group.\n            full_app_name (Optional[str]): Full application name. Value from\n                environment variable 'AYON_APP_NAME' is used if 'None' is\n                passed.\n\n        Returns:\n            dict[str, str]: Environment variables for farm publish.\n\n        \"\"\"\n        if full_app_name is None:\n            full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n        return self.get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=LaunchTypes.farm_publish\n        )\n\n    def get_applications_manager(\n        self, settings: Optional[dict[str, Any]] = None\n    ) -&gt; \"ApplicationManager\":\n        \"\"\"Get applications manager.\n\n        Args:\n            settings (Optional[dict]): Studio/project settings.\n\n        Returns:\n            ApplicationManager: Applications manager.\n\n        \"\"\"\n        return ApplicationManager(settings)\n\n    def get_plugin_paths(self) -&gt; dict[str, list[str]]:\n        return {}\n\n    def get_publish_plugin_paths(self, host_name: str) -&gt; list[str]:\n        return [\n            os.path.join(APPLICATIONS_ADDON_ROOT, \"plugins\", \"publish\")\n        ]\n\n    def get_launch_hook_paths(self, app: \"Application\") -&gt; list[str]:\n        return [\n            os.path.join(APPLICATIONS_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_app_icon_path(self, icon_filename: str) -&gt; str:\n        \"\"\"Get icon path.\n\n        Args:\n            icon_filename (str): Icon filename.\n\n        Returns:\n            Optional[str]: Icon path or None if not found.\n\n        \"\"\"\n        return get_app_icon_path(icon_filename)\n\n    def get_app_icon_url(\n        self, icon_filename: str, server: bool = False\n    ) -&gt; Optional[str]:\n        \"\"\"Get icon path.\n\n        Method does not validate if icon filename exist on server.\n\n        Args:\n            icon_filename (str): Icon name.\n            server (Optional[bool]): Return url to AYON server.\n\n        Returns:\n            Union[str, None]: Icon path or None is server url is not\n                available.\n\n        \"\"\"\n        if not icon_filename:\n            return None\n        icon_name = os.path.basename(icon_filename)\n        if server:\n            base_url = ayon_api.get_base_url()\n            return (\n                f\"{base_url}/addons/{self.name}/{self.version}\"\n                f\"/public/icons/{icon_name}\"\n            )\n        server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n        if not server_url:\n            return None\n        return \"/\".join([\n            server_url, \"addons\", self.name, \"icons\", icon_name\n        ])\n\n    def launch_application(\n        self,\n        app_name: str,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        workfile_path: Optional[str] = None,\n        use_last_workfile: Optional[bool] = None,\n    ):\n        \"\"\"Launch application.\n\n        Args:\n            app_name (str): Full application name e.g. 'maya/2024'.\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            workfile_path (Optional[str]): Workfile path to use.\n            use_last_workfile (Optional[bool]): Explicitly tell to use or\n                not use last workfile. Ignored if 'workfile_path' is passed.\n\n        \"\"\"\n        ensure_addons_are_process_ready(\n            addon_name=self.name,\n            addon_version=self.version,\n            project_name=project_name,\n        )\n        headless = is_headless_mode_enabled()\n\n        data = {\n            \"project_name\": project_name,\n            \"folder_path\": folder_path,\n            \"task_name\": task_name,\n        }\n        # Backwards compatibility 'workfile_path' was added\n        #   before 'use_last_workfile'\n        if isinstance(workfile_path, bool):\n            use_last_workfile = workfile_path\n            workfile_path = None\n            warnings.warn(\n                \"Passed 'use_last_workfile' as positional argument.\"\n                \" Use explicit 'use_last_workfile' keyword argument instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        if workfile_path:\n            data[\"workfile_path\"] = workfile_path\n            # Backwards compatibility to be able to use 'workfile_path'\n            #   argument with older ayon-core\n            # use_last_workfile = False\n            data[\"last_workfile_path\"] = workfile_path\n            data[\"start_last_workfile\"] = True\n\n        elif use_last_workfile is not None:\n            data[\"start_last_workfile\"] = use_last_workfile\n\n        # TODO handle raise errors\n        failed = True\n        message = None\n        detail = None\n        try:\n            app_manager = self.get_applications_manager()\n            app_manager.launch(app_name, **data)\n            failed = False\n\n        except (\n            ApplicationLaunchFailed,\n            ApplicationExecutableNotFound,\n            ApplicationNotFound,\n        ) as exc:\n            message = str(exc)\n            self.log.warning(f\"Application launch failed: {message}\")\n\n        except Exception as exc:\n            message = \"An unexpected error happened\"\n            detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n            self.log.warning(\n                f\"Application launch failed: {str(exc)}\",\n                exc_info=True\n            )\n\n        if not failed:\n            return\n\n        if not headless:\n            self._show_launch_error_dialog(message, detail)\n        sys.exit(1)\n\n    def webserver_initialization(self, manager: \"WebServerManager\") -&gt; None:\n        \"\"\"Initialize webserver.\n\n        Args:\n            manager (WebServerManager): Webserver manager.\n\n        \"\"\"\n        static_prefix = f\"/addons/{self.name}/icons\"\n        manager.add_static(\n            static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n        )\n\n    # --- CLI ---\n    def cli(self, addon_click_group) -&gt; None:\n        main_group = click_wrap.group(\n            self._cli_main, name=self.name, help=\"Applications addon\"\n        )\n        (\n            main_group.command(\n                self._cli_extract_environments,\n                name=\"extractenvironments\",\n                help=(\n                    \"Extract environment variables for context into json file\"\n                )\n            )\n            .argument(\"output_json_path\")\n            .option(\"--project\", help=\"Project name\", default=None)\n            .option(\"--folder\", help=\"Folder path\", default=None)\n            .option(\"--task\", help=\"Task name\", default=None)\n            .option(\"--app\", help=\"Full application name\", default=None)\n            .option(\n                \"--envgroup\",\n                help=\"Environment group (e.g. \\\"farm\\\")\",\n                default=None\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_context_names,\n                name=\"launch\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--folder\", required=True, help=\"Folder path\")\n            .option(\"--task\", required=True, help=\"Task name\")\n            .option(\n                \"--use-last-workfile\",\n                help=\"Use last workfile\",\n                default=None,\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_with_task_id,\n                name=\"launch-by-id\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--task-id\", required=True, help=\"Task id\")\n            .option(\n                \"--use-last-workfile\",\n                help=\"Use last workfile\",\n                default=None,\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_with_workfile_id,\n                name=\"launch-by-workfile-id\",\n                help=\"Launch application using workfile id\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--workfile-id\", required=True, help=\"Workfile id\")\n        )\n        (\n            main_group.command(\n                self._cli_launch_with_debug_terminal,\n                name=\"launch-debug-terminal\",\n                help=\"Launch with debug terminal\"\n            )\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--task-id\", required=True, help=\"Task id\")\n            .option(\n                \"--app\",\n                required=False,\n                help=\"Full application name\",\n                default=None,\n            )\n        )\n        # Convert main command to click object and add it to parent group\n        addon_click_group.add_command(\n            main_group.to_click_obj()\n        )\n\n    def _cli_main(self) -&gt; None:\n        pass\n\n    def _cli_extract_environments(\n        self,\n        output_json_path: str,\n        project: str,\n        folder: str,\n        task: str,\n        app: str,\n        envgroup: str,\n    ) -&gt; None:\n        \"\"\"Produces json file with environment based on project and app.\n\n        Called by farm integration to propagate environment into farm jobs.\n\n        Args:\n            output_json_path (str): Output json file path.\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n            envgroup (str): Environment group.\n\n        \"\"\"\n        if all((project, folder, task, app)):\n            env = self.get_farm_publish_environment_variables(\n                project, folder, task, app, env_group=envgroup,\n            )\n        else:\n            env = os.environ.copy()\n\n        output_dir = os.path.dirname(output_json_path)\n        os.makedirs(output_dir, exist_ok=True)\n\n        with open(output_json_path, \"w\") as file_stream:\n            json.dump(env, file_stream, indent=4)\n\n    def _cli_launch_context_names(\n        self,\n        project: str,\n        folder: str,\n        task: str,\n        app: str,\n        use_last_workfile: Optional[\"BoolArg\"],\n    ) -&gt; None:\n        \"\"\"Launch application.\n\n        Args:\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n            use_last_workfile (Optional[Literal[\"1\", \"0\"]): Explicitly tell\n                to use last workfile.\n\n        \"\"\"\n        if use_last_workfile is not None:\n            use_last_workfile = env_value_to_bool(\n                use_last_workfile, default=None\n            )\n        self.launch_application(\n            app, project, folder, task, use_last_workfile=use_last_workfile,\n        )\n\n    def _cli_launch_with_task_id(\n        self,\n        project: str,\n        task_id: str,\n        app: str,\n        use_last_workfile: Optional[\"BoolArg\"],\n    ) -&gt; None:\n        \"\"\"Launch application using project name, task id and full app name.\n\n        Args:\n            project (str): Project name.\n            task_id (str): Task id.\n            app (str): Full application name e.g. 'maya/2024'.\n            use_last_workfile (Optional[Literal[\"1\", \"0\"]): Explicitly tell\n                to use last workfile.\n\n        \"\"\"\n        if use_last_workfile is not None:\n            use_last_workfile = env_value_to_bool(\n                value=use_last_workfile, default=None\n            )\n\n        task_entity = ayon_api.get_task_by_id(\n            project, task_id, fields={\"name\", \"folderId\"}\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project, task_entity[\"folderId\"], fields={\"path\"}\n        )\n        self.launch_application(\n            app,\n            project,\n            folder_entity[\"path\"],\n            task_entity[\"name\"],\n            use_last_workfile=use_last_workfile,\n        )\n\n    def _cli_launch_with_workfile_id(\n        self,\n        project: str,\n        workfile_id: str,\n        app: str,\n    ) -&gt; None:\n        from ayon_core.pipeline import Anatomy\n\n        workfile_entity = ayon_api.get_workfile_info_by_id(\n            project, workfile_id\n        )\n        task_id = workfile_entity[\"taskId\"]\n        task_entity = ayon_api.get_task_by_id(\n            project, task_id, fields={\"name\", \"folderId\"}\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project, task_entity[\"folderId\"], fields={\"path\"}\n        )\n        anatomy = Anatomy(project)\n        workfile_path = anatomy.fill_root(workfile_entity[\"path\"])\n        self.launch_application(\n            app,\n            project,\n            folder_entity[\"path\"],\n            task_entity[\"name\"],\n            workfile_path=workfile_path,\n        )\n\n    def _cli_launch_with_debug_terminal(\n        self,\n        project: str,\n        task_id: str,\n        app: Optional[str],\n    ) -&gt; None:\n        from .ui.debug_terminal_launch import run_with_debug_terminal\n\n        run_with_debug_terminal(self, project, task_id, app)\n\n    def _show_launch_error_dialog(self, message: str, detail: str) -&gt; None:\n        script_path = os.path.join(\n            APPLICATIONS_ADDON_ROOT, \"ui\", \"launch_failed_dialog.py\"\n        )\n        with tempfile.NamedTemporaryFile(\"w\", delete=False) as tmp:\n            tmp_path = tmp.name\n            json.dump(\n                {\"message\": message, \"detail\": detail},\n                tmp.file\n            )\n\n        try:\n            run_ayon_launcher_process(\n                \"--skip-bootstrap\",\n                script_path,\n                tmp_path,\n                add_sys_paths=True,\n                creationflags=0,\n            )\n\n        finally:\n            os.remove(tmp_path)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_app_environments_for_context","title":"<code>get_app_environments_for_context(project_name, folder_path, task_name, full_app_name, env_group=None, launch_type=None, env=None)</code>","text":"<p>Calculate environment variables for launch context.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>full_app_name</code> <code>str</code> <p>Full application name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type.</p> <code>None</code> <code>env</code> <code>Optional[dict[str, str]]</code> <p>Environment variables to update.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Environment variables for context.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_environments_for_context(\n    self,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    full_app_name: str,\n    env_group: Optional[str] = None,\n    launch_type: Optional[str] = None,\n    env: Optional[dict[str, str]] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Calculate environment variables for launch context.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        full_app_name (str): Full application name.\n        env_group (Optional[str]): Environment group.\n        launch_type (Optional[str]): Launch type.\n        env (Optional[dict[str, str]]): Environment variables to update.\n\n    Returns:\n        dict[str, str]: Environment variables for context.\n\n    \"\"\"\n    from ayon_applications.utils import get_app_environments_for_context\n\n    if not full_app_name:\n        return {}\n\n    return get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=launch_type,\n        env=env,\n        addons_manager=self.manager\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_app_icon_path","title":"<code>get_app_icon_path(icon_filename)</code>","text":"<p>Get icon path.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon filename.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Optional[str]: Icon path or None if not found.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_path(self, icon_filename: str) -&gt; str:\n    \"\"\"Get icon path.\n\n    Args:\n        icon_filename (str): Icon filename.\n\n    Returns:\n        Optional[str]: Icon path or None if not found.\n\n    \"\"\"\n    return get_app_icon_path(icon_filename)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_app_icon_url","title":"<code>get_app_icon_url(icon_filename, server=False)</code>","text":"<p>Get icon path.</p> <p>Method does not validate if icon filename exist on server.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon name.</p> required <code>server</code> <code>Optional[bool]</code> <p>Return url to AYON server.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Union[str, None]: Icon path or None is server url is not available.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_url(\n    self, icon_filename: str, server: bool = False\n) -&gt; Optional[str]:\n    \"\"\"Get icon path.\n\n    Method does not validate if icon filename exist on server.\n\n    Args:\n        icon_filename (str): Icon name.\n        server (Optional[bool]): Return url to AYON server.\n\n    Returns:\n        Union[str, None]: Icon path or None is server url is not\n            available.\n\n    \"\"\"\n    if not icon_filename:\n        return None\n    icon_name = os.path.basename(icon_filename)\n    if server:\n        base_url = ayon_api.get_base_url()\n        return (\n            f\"{base_url}/addons/{self.name}/{self.version}\"\n            f\"/public/icons/{icon_name}\"\n        )\n    server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n    if not server_url:\n        return None\n    return \"/\".join([\n        server_url, \"addons\", self.name, \"icons\", icon_name\n    ])\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_applications_manager","title":"<code>get_applications_manager(settings=None)</code>","text":"<p>Get applications manager.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Optional[dict]</code> <p>Studio/project settings.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ApplicationManager</code> <code>'ApplicationManager'</code> <p>Applications manager.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_applications_manager(\n    self, settings: Optional[dict[str, Any]] = None\n) -&gt; \"ApplicationManager\":\n    \"\"\"Get applications manager.\n\n    Args:\n        settings (Optional[dict]): Studio/project settings.\n\n    Returns:\n        ApplicationManager: Applications manager.\n\n    \"\"\"\n    return ApplicationManager(settings)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_farm_publish_environment_variables","title":"<code>get_farm_publish_environment_variables(project_name, folder_path, task_name, full_app_name=None, env_group=None)</code>","text":"<p>Calculate environment variables for farm publish.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>full_app_name</code> <code>Optional[str]</code> <p>Full application name. Value from environment variable 'AYON_APP_NAME' is used if 'None' is passed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Environment variables for farm publish.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_farm_publish_environment_variables(\n    self,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    full_app_name: Optional[str] = None,\n    env_group: Optional[str] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Calculate environment variables for farm publish.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        env_group (Optional[str]): Environment group.\n        full_app_name (Optional[str]): Full application name. Value from\n            environment variable 'AYON_APP_NAME' is used if 'None' is\n            passed.\n\n    Returns:\n        dict[str, str]: Environment variables for farm publish.\n\n    \"\"\"\n    if full_app_name is None:\n        full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n    return self.get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=LaunchTypes.farm_publish\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.launch_application","title":"<code>launch_application(app_name, project_name, folder_path, task_name, workfile_path=None, use_last_workfile=None)</code>","text":"<p>Launch application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Full application name e.g. 'maya/2024'.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>workfile_path</code> <code>Optional[str]</code> <p>Workfile path to use.</p> <code>None</code> <code>use_last_workfile</code> <code>Optional[bool]</code> <p>Explicitly tell to use or not use last workfile. Ignored if 'workfile_path' is passed.</p> <code>None</code> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def launch_application(\n    self,\n    app_name: str,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    workfile_path: Optional[str] = None,\n    use_last_workfile: Optional[bool] = None,\n):\n    \"\"\"Launch application.\n\n    Args:\n        app_name (str): Full application name e.g. 'maya/2024'.\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        workfile_path (Optional[str]): Workfile path to use.\n        use_last_workfile (Optional[bool]): Explicitly tell to use or\n            not use last workfile. Ignored if 'workfile_path' is passed.\n\n    \"\"\"\n    ensure_addons_are_process_ready(\n        addon_name=self.name,\n        addon_version=self.version,\n        project_name=project_name,\n    )\n    headless = is_headless_mode_enabled()\n\n    data = {\n        \"project_name\": project_name,\n        \"folder_path\": folder_path,\n        \"task_name\": task_name,\n    }\n    # Backwards compatibility 'workfile_path' was added\n    #   before 'use_last_workfile'\n    if isinstance(workfile_path, bool):\n        use_last_workfile = workfile_path\n        workfile_path = None\n        warnings.warn(\n            \"Passed 'use_last_workfile' as positional argument.\"\n            \" Use explicit 'use_last_workfile' keyword argument instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if workfile_path:\n        data[\"workfile_path\"] = workfile_path\n        # Backwards compatibility to be able to use 'workfile_path'\n        #   argument with older ayon-core\n        # use_last_workfile = False\n        data[\"last_workfile_path\"] = workfile_path\n        data[\"start_last_workfile\"] = True\n\n    elif use_last_workfile is not None:\n        data[\"start_last_workfile\"] = use_last_workfile\n\n    # TODO handle raise errors\n    failed = True\n    message = None\n    detail = None\n    try:\n        app_manager = self.get_applications_manager()\n        app_manager.launch(app_name, **data)\n        failed = False\n\n    except (\n        ApplicationLaunchFailed,\n        ApplicationExecutableNotFound,\n        ApplicationNotFound,\n    ) as exc:\n        message = str(exc)\n        self.log.warning(f\"Application launch failed: {message}\")\n\n    except Exception as exc:\n        message = \"An unexpected error happened\"\n        detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n        self.log.warning(\n            f\"Application launch failed: {str(exc)}\",\n            exc_info=True\n        )\n\n    if not failed:\n        return\n\n    if not headless:\n        self._show_launch_error_dialog(message, detail)\n    sys.exit(1)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.on_action_trigger","title":"<code>on_action_trigger()</code>","text":"<p>Action triggered when the tray icon is clicked.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def on_action_trigger(self) -&gt; None:\n    \"\"\"Action triggered when the tray icon is clicked.\"\"\"\n    from ayon_applications.ui.process_monitor import (\n        ProcessMonitorWindow,\n    )\n    if self._process_monitor_window is None:\n        self._process_monitor_window = ProcessMonitorWindow()\n\n    self._process_monitor_window.show()\n    self._process_monitor_window.raise_()\n    self._process_monitor_window.activateWindow()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.tray_init","title":"<code>tray_init()</code>","text":"<p>Initialize the tray action.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def tray_init(self) -&gt; None:\n    \"\"\"Initialize the tray action.\"\"\"\n    self._process_monitor_window: Optional[ProcessMonitorWindow] = None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.webserver_initialization","title":"<code>webserver_initialization(manager)</code>","text":"<p>Initialize webserver.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>WebServerManager</code> <p>Webserver manager.</p> required Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def webserver_initialization(self, manager: \"WebServerManager\") -&gt; None:\n    \"\"\"Initialize webserver.\n\n    Args:\n        manager (WebServerManager): Webserver manager.\n\n    \"\"\"\n    static_prefix = f\"/addons/{self.name}/icons\"\n    manager.add_static(\n        static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/constants.html","title":"constants","text":""},{"location":"autoapi/client/ayon_applications/defs.html","title":"defs","text":""},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.Application","title":"<code>Application</code>","text":"<p>Hold information about application.</p> <p>Object by itself does nothing special.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data for the version containing information about executables, variant label or if is enabled. Only required key is <code>executables</code>.</p> required <code>group</code> <code>ApplicationGroup</code> <p>App group object that created the application and under which application belongs.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class Application:\n    \"\"\"Hold information about application.\n\n    Object by itself does nothing special.\n\n    Args:\n        data (dict): Data for the version containing information about\n            executables, variant label or if is enabled.\n            Only required key is `executables`.\n        group (ApplicationGroup): App group object that created the application\n            and under which application belongs.\n\n    \"\"\"\n    def __init__(self, data: dict[str, Any], group: ApplicationGroup):\n        self._data = data\n        name = data[\"name\"]\n        label = data[\"label\"] or name\n        enabled = False\n        if group.enabled:\n            enabled = data.get(\"enabled\", True)\n\n        if group.label:\n            full_label = \" \".join((group.label, label))\n        else:\n            full_label = label\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n\n        arguments = data[\"arguments\"]\n        if isinstance(arguments, dict):\n            arguments = arguments.get(platform.system().lower())\n\n        if not arguments:\n            arguments = []\n\n        _executables = data[\"executables\"].get(platform.system().lower(), [])\n        executables = [\n            ApplicationExecutable(executable)\n            for executable in _executables\n        ]\n\n        self.group = group\n\n        self.name = name\n        self.label = label\n        self.enabled = enabled\n        self.use_python_2 = data.get(\"use_python_2\", False)\n\n        self.full_name = f\"{group.name}/{name}\"\n        self.full_label = full_label\n        self.arguments = arguments\n        self.executables = executables\n        self._environment = env\n        self.redirect_output = data.get(\"redirect_output\", True)\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.full_name}\"\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n\n    @property\n    def manager(self) -&gt; \"ApplicationManager\":\n        return self.group.manager\n\n    @property\n    def host_name(self) -&gt; Optional[str]:\n        return self.group.host_name\n\n    @property\n    def icon(self) -&gt; Optional[str]:\n        return self.group.icon\n\n    @property\n    def is_host(self) -&gt; bool:\n        return self.group.is_host\n\n    def find_executable(self) -&gt; Optional[ApplicationExecutable]:\n        \"\"\"Try to find existing executable for application.\n\n        Returns (str): Path to executable from `executables` or None if any\n            exists.\n        \"\"\"\n        for executable in self.executables:\n            if executable.exists():\n                return executable\n        return None\n\n    def launch(self, *args, **kwargs) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Launch the application.\n\n        For this purpose is used manager's launch method to keep logic at one\n        place.\n\n        Arguments must match with manager's launch method. That's why *args\n        **kwargs are used.\n\n        Returns:\n            subprocess.Popen: Return executed process as Popen object.\n\n        \"\"\"\n        return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.Application.find_executable","title":"<code>find_executable()</code>","text":"<p>Try to find existing executable for application.</p> <p>Returns (str): Path to executable from <code>executables</code> or None if any     exists.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def find_executable(self) -&gt; Optional[ApplicationExecutable]:\n    \"\"\"Try to find existing executable for application.\n\n    Returns (str): Path to executable from `executables` or None if any\n        exists.\n    \"\"\"\n    for executable in self.executables:\n        if executable.exists():\n            return executable\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.Application.launch","title":"<code>launch(*args, **kwargs)</code>","text":"<p>Launch the application.</p> <p>For this purpose is used manager's launch method to keep logic at one place.</p> <p>Arguments must match with manager's launch method. That's why args *kwargs are used.</p> <p>Returns:</p> Type Description <code>Optional[Popen]</code> <p>subprocess.Popen: Return executed process as Popen object.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def launch(self, *args, **kwargs) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Launch the application.\n\n    For this purpose is used manager's launch method to keep logic at one\n    place.\n\n    Arguments must match with manager's launch method. That's why *args\n    **kwargs are used.\n\n    Returns:\n        subprocess.Popen: Return executed process as Popen object.\n\n    \"\"\"\n    return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.ApplicationExecutable","title":"<code>ApplicationExecutable</code>","text":"<p>Representation of executable loaded from settings.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationExecutable:\n    \"\"\"Representation of executable loaded from settings.\"\"\"\n\n    def __init__(self, executable: str):\n        # Try to format executable with environments\n        try:\n            executable = executable.format(**os.environ)\n        except Exception:\n            pass\n\n        # On MacOS check if exists path to executable when ends with `.app`\n        # - it is common that path will lead to \"/Applications/Blender\" but\n        #   real path is \"/Applications/Blender.app\"\n        if platform.system().lower() == \"darwin\":\n            executable = self.macos_executable_prep(executable)\n\n        self.executable_path = executable\n\n    def __str__(self) -&gt; str:\n        return self.executable_path\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; {self.executable_path}\"\n\n    @staticmethod\n    def macos_executable_prep(executable: str) -&gt; str:\n        \"\"\"Try to find full path to executable file.\n\n        Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n        Having path to '*.app' gives ability to read it's plist info and\n        use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n        Plist is stored in '*.app/Contents/Info.plist'.\n\n        This is because some '*.app' directories don't have same permissions\n        as real executable.\n        \"\"\"\n        # Try to find if there is `.app` file\n        if not os.path.exists(executable):\n            _executable = executable + \".app\"\n            if os.path.exists(_executable):\n                executable = _executable\n\n        # Try to find real executable if executable has `Contents` subfolder\n        contents_dir = os.path.join(executable, \"Contents\")\n        if os.path.exists(contents_dir):\n            executable_filename = None\n            # Load plist file and check for bundle executable\n            plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n            if os.path.exists(plist_filepath):\n                import plistlib\n\n                if hasattr(plistlib, \"load\"):\n                    with open(plist_filepath, \"rb\") as stream:\n                        parsed_plist = plistlib.load(stream)\n                else:\n                    parsed_plist = plistlib.readPlist(plist_filepath)\n                executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n            if executable_filename:\n                executable = os.path.join(\n                    contents_dir, \"MacOS\", executable_filename\n                )\n\n        return executable\n\n    def as_args(self) -&gt; list[str]:\n        return [self.executable_path]\n\n    def _realpath(self) -&gt; Optional[str]:\n        \"\"\"Check if path is valid executable path.\"\"\"\n        # Check for executable in PATH\n        result = find_executable(self.executable_path)\n        if result is not None:\n            return result\n\n        # This is not 100% validation but it is better than remove ability to\n        #   launch .bat, .sh or extentionless files\n        if os.path.exists(self.executable_path):\n            return self.executable_path\n        return None\n\n    def exists(self) -&gt; bool:\n        if not self.executable_path:\n            return False\n        return bool(self._realpath())\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.ApplicationExecutable.macos_executable_prep","title":"<code>macos_executable_prep(executable)</code>  <code>staticmethod</code>","text":"<p>Try to find full path to executable file.</p> <p>Real executable is stored in '*.app/Contents/MacOS/'. <p>Having path to '*.app' gives ability to read it's plist info and use \"CFBundleExecutable\" key from plist to know what is \"executable.\"</p> <p>Plist is stored in '*.app/Contents/Info.plist'.</p> <p>This is because some '*.app' directories don't have same permissions as real executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>@staticmethod\ndef macos_executable_prep(executable: str) -&gt; str:\n    \"\"\"Try to find full path to executable file.\n\n    Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n    Having path to '*.app' gives ability to read it's plist info and\n    use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n    Plist is stored in '*.app/Contents/Info.plist'.\n\n    This is because some '*.app' directories don't have same permissions\n    as real executable.\n    \"\"\"\n    # Try to find if there is `.app` file\n    if not os.path.exists(executable):\n        _executable = executable + \".app\"\n        if os.path.exists(_executable):\n            executable = _executable\n\n    # Try to find real executable if executable has `Contents` subfolder\n    contents_dir = os.path.join(executable, \"Contents\")\n    if os.path.exists(contents_dir):\n        executable_filename = None\n        # Load plist file and check for bundle executable\n        plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n        if os.path.exists(plist_filepath):\n            import plistlib\n\n            if hasattr(plistlib, \"load\"):\n                with open(plist_filepath, \"rb\") as stream:\n                    parsed_plist = plistlib.load(stream)\n            else:\n                parsed_plist = plistlib.readPlist(plist_filepath)\n            executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n        if executable_filename:\n            executable = os.path.join(\n                contents_dir, \"MacOS\", executable_filename\n            )\n\n    return executable\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.ApplicationGroup","title":"<code>ApplicationGroup</code>","text":"<p>Hold information about application group.</p> <p>Application group wraps different versions(variants) of application. e.g. \"maya\" is group and \"maya_2020\" is variant.</p> <p>Group hold <code>host_name</code> which is implementation name used in AYON. Also holds <code>enabled</code> if whole app group is enabled or <code>icon</code> for application icon path in resources.</p> <p>Group has also <code>environment</code> which hold same environments for all variants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Groups' name.</p> required <code>data</code> <code>dict</code> <p>Group defying data loaded from settings.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that created the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationGroup:\n    \"\"\"Hold information about application group.\n\n    Application group wraps different versions(variants) of application.\n    e.g. \"maya\" is group and \"maya_2020\" is variant.\n\n    Group hold `host_name` which is implementation name used in AYON. Also\n    holds `enabled` if whole app group is enabled or `icon` for application\n    icon path in resources.\n\n    Group has also `environment` which hold same environments for all variants.\n\n    Args:\n        name (str): Groups' name.\n        data (dict): Group defying data loaded from settings.\n        manager (ApplicationManager): Manager that created the group.\n\n    \"\"\"\n    def __init__(\n        self,\n        name: str,\n        data: dict[str, Any],\n        manager: \"ApplicationManager\",\n    ):\n        icon = ICONS_BY_GROUP_NAME.get(name)\n        if not icon:\n            icon = data.get(\"icon\")\n\n        label = LABELS_BY_GROUP_NAME.get(name)\n        if not label:\n            label = data.get(\"label\")\n\n        self.name = name\n        self.manager = manager\n        self._data = data\n\n        self.enabled = data[\"enabled\"]\n        self.label = label\n        self.icon = icon\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = env\n\n        host_name = data[\"host_name\"] or None\n        self.is_host = host_name is not None\n        self.host_name = host_name\n\n        settings_variants = data[\"variants\"]\n        variants = {}\n        for variant_data in settings_variants:\n            app_variant = Application(variant_data, self)\n            variants[app_variant.name] = app_variant\n\n        self.variants = variants\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.name}\"\n\n    def __iter__(self) -&gt; Generator[\"Application\", None, None]:\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.EnvironmentTool","title":"<code>EnvironmentTool</code>","text":"<p>Hold information about application tool.</p> <p>Structure of tool information.</p> <p>Parameters:</p> Name Type Description Default <code>variant_data</code> <code>dict</code> <p>Variant data with environments and host and app variant filters.</p> required <code>group</code> <code>EnvironmentToolGroup</code> <p>Name of group which wraps tool.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentTool:\n    \"\"\"Hold information about application tool.\n\n    Structure of tool information.\n\n    Args:\n        variant_data (dict): Variant data with environments and\n            host and app variant filters.\n        group (EnvironmentToolGroup): Name of group which wraps tool.\n\n    \"\"\"\n    def __init__(\n        self,\n        variant_data: dict[str, Any],\n        group: EnvironmentToolGroup,\n    ):\n        # Backwards compatibility 3.9.1 - 3.9.2\n        # - 'variant_data' contained only environments but contain also host\n        #   and application variant filters\n        name = variant_data[\"name\"]\n        label = variant_data[\"label\"]\n        host_names = variant_data[\"host_names\"]\n        app_variants = variant_data[\"app_variants\"]\n\n        environment = {}\n        try:\n            environment = json.loads(variant_data[\"environment\"])\n        except Exception:\n            pass\n\n        self.host_names = host_names\n        self.app_variants = app_variants\n        self.name = name\n        self.variant_label = label\n        self.label = \" \".join((group.label, label))\n        self.group = group\n\n        self._environment = environment\n        self.full_name = \"/\".join((group.name, name))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.full_name}\"\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n\n    def is_valid_for_app(self, app: Application) -&gt; bool:\n        \"\"\"Is tool valid for an application.\n\n        Args:\n            app (Application): Application for which are prepared environments.\n\n        \"\"\"\n        if self.app_variants and app.full_name not in self.app_variants:\n            return False\n\n        if self.host_names and app.host_name not in self.host_names:\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.EnvironmentTool.is_valid_for_app","title":"<code>is_valid_for_app(app)</code>","text":"<p>Is tool valid for an application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>Application for which are prepared environments.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def is_valid_for_app(self, app: Application) -&gt; bool:\n    \"\"\"Is tool valid for an application.\n\n    Args:\n        app (Application): Application for which are prepared environments.\n\n    \"\"\"\n    if self.app_variants and app.full_name not in self.app_variants:\n        return False\n\n    if self.host_names and app.host_name not in self.host_names:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.EnvironmentToolGroup","title":"<code>EnvironmentToolGroup</code>","text":"<p>Hold information about environment tool group.</p> <p>Environment tool group may hold different variants of same tool and set environments that are same for all of them.</p> <p>e.g. \"mtoa\" may have different versions but all environments except one     are same.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Group information with variants.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that creates the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentToolGroup:\n    \"\"\"Hold information about environment tool group.\n\n    Environment tool group may hold different variants of same tool and set\n    environments that are same for all of them.\n\n    e.g. \"mtoa\" may have different versions but all environments except one\n        are same.\n\n    Args:\n        data (dict): Group information with variants.\n        manager (ApplicationManager): Manager that creates the group.\n\n    \"\"\"\n    def __init__(\n        self,\n        data: dict[str, Any],\n        manager: \"ApplicationManager\",\n    ):\n        name = data[\"name\"]\n        label = data[\"label\"]\n\n        self.name = name\n        self.label = label\n        self._data = data\n        self.manager = manager\n\n        environment = {}\n        try:\n            environment = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = environment\n\n        variants = data.get(\"variants\") or []\n        variants_by_name = {}\n        for variant_data in variants:\n            tool = EnvironmentTool(variant_data, self)\n            variants_by_name[tool.name] = tool\n        self.variants = variants_by_name\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt; - {self.name}\"\n\n    def __iter__(self) -&gt; Generator[\"EnvironmentTool\", None, None]:\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self) -&gt; dict[str, str]:\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.LaunchTypes","title":"<code>LaunchTypes</code>","text":"<p>Launch types are filters for pre/post-launch hooks.</p> <p>Please use these variables in case they'll change values.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class LaunchTypes:\n    \"\"\"Launch types are filters for pre/post-launch hooks.\n\n    Please use these variables in case they'll change values.\n    \"\"\"\n\n    # Local launch - application is launched on local machine\n    local = \"local\"\n    # Farm render job - application is on farm\n    farm_render = \"farm-render\"\n    # Farm publish job - integration post-render job\n    farm_publish = \"farm-publish\"\n    # Remote launch - application is launched on remote machine from which\n    #     can be started publishing\n    remote = \"remote\"\n    # Automated launch - application is launched with automated publishing\n    automated = \"automated\"\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.UndefinedApplicationExecutable","title":"<code>UndefinedApplicationExecutable</code>","text":"<p>               Bases: <code>ApplicationExecutable</code></p> <p>Some applications do not require executable path from settings.</p> <p>In that case this class is used to \"fake\" existing executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class UndefinedApplicationExecutable(ApplicationExecutable):\n    \"\"\"Some applications do not require executable path from settings.\n\n    In that case this class is used to \"fake\" existing executable.\n    \"\"\"\n    def __init__(self):\n        pass\n\n    def __str__(self) -&gt; str:\n        return self.__class__.__name__\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}&gt;\"\n\n    def as_args(self) -&gt; list[str]:\n        return []\n\n    def exists(self) -&gt; bool:\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/exceptions.html","title":"exceptions","text":""},{"location":"autoapi/client/ayon_applications/exceptions.html#client.ayon_applications.exceptions.ApplicationExecutableNotFound","title":"<code>ApplicationExecutableNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Defined executable paths are not available on the machine.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationExecutableNotFound(Exception):\n    \"\"\"Defined executable paths are not available on the machine.\"\"\"\n\n    def __init__(self, application):\n        self.application = application\n        details = None\n        if not application.executables:\n            msg = (\n                \"Executable paths for application \\\"{}\\\"({}) are not set.\"\n            )\n        else:\n            msg = (\n                \"Defined executable paths for application \\\"{}\\\"({})\"\n                \" are not available on this machine.\"\n            )\n            details = \"Defined paths:\"\n            for executable in application.executables:\n                details += \"\\n- \" + executable.executable_path\n\n        self.msg = msg.format(application.full_label, application.full_name)\n        self.details = details\n\n        exc_mgs = str(self.msg)\n        if details:\n            # Is good idea to pass new line symbol to exception message?\n            exc_mgs += \"\\n\\n\" + details\n        self.exc_msg = exc_mgs\n        super().__init__(exc_mgs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/exceptions.html#client.ayon_applications.exceptions.ApplicationLaunchFailed","title":"<code>ApplicationLaunchFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application launch failed due to known reason.</p> <p>Message should be self explanatory as traceback won't be shown.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationLaunchFailed(Exception):\n    \"\"\"Application launch failed due to known reason.\n\n    Message should be self explanatory as traceback won't be shown.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_applications/exceptions.html#client.ayon_applications.exceptions.ApplicationNotFound","title":"<code>ApplicationNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application was not found in ApplicationManager by name.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationNotFound(Exception):\n    \"\"\"Application was not found in ApplicationManager by name.\"\"\"\n\n    def __init__(self, app_name):\n        self.app_name = app_name\n        super().__init__(\n            f\"Application \\\"{app_name}\\\" was not found.\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/hooks.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_applications/manager.html","title":"manager","text":"<p>Application manager and application launch context.</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext","title":"<code>ApplicationLaunchContext</code>","text":"<p>Context of launching application.</p> <p>Main purpose of context is to prepare launch arguments and keyword arguments for new process. Most important part of keyword arguments preparations are environment variables.</p> <p>During the whole process is possible to use <code>data</code> attribute to store object usable in multiple places.</p> <p>Launch arguments are strings in list. It is possible to \"chain\" argument when order of them matters. That is possible to do with adding list where order is right and should not change. NOTE: This is recommendation, not requirement. e.g.: <code>[\"nuke.exe\", \"--NukeX\"]</code> -&gt; In this case any part of process may insert argument between <code>nuke.exe</code> and <code>--NukeX</code>. To keep them together it is better to wrap them in another list: <code>[[\"nuke.exe\", \"--NukeX\"]]</code>.</p> Notes <p>It is possible to use launch context only to prepare environment     variables. In that case <code>executable</code> may be None and can be used     'run_prelaunch_hooks' method to run prelaunch hooks which prepare     them.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Application</code> <p>Application definition.</p> required <code>executable</code> <code>ApplicationExecutable</code> <p>Object with path to executable.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment variable group. If not set 'DEFAULT_ENV_SUBGROUP' is used.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type. If not set 'local' is used.</p> <code>None</code> <code>**data</code> <code>dict</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationLaunchContext:\n    \"\"\"Context of launching application.\n\n    Main purpose of context is to prepare launch arguments and keyword\n    arguments for new process. Most important part of keyword arguments\n    preparations are environment variables.\n\n    During the whole process is possible to use `data` attribute to store\n    object usable in multiple places.\n\n    Launch arguments are strings in list. It is possible to \"chain\" argument\n    when order of them matters. That is possible to do with adding list where\n    order is right and should not change.\n    NOTE: This is recommendation, not requirement.\n    e.g.: `[\"nuke.exe\", \"--NukeX\"]` -&gt; In this case any part of process may\n    insert argument between `nuke.exe` and `--NukeX`. To keep them together\n    it is better to wrap them in another list: `[[\"nuke.exe\", \"--NukeX\"]]`.\n\n    Notes:\n        It is possible to use launch context only to prepare environment\n            variables. In that case `executable` may be None and can be used\n            'run_prelaunch_hooks' method to run prelaunch hooks which prepare\n            them.\n\n    Args:\n        application (Application): Application definition.\n        executable (ApplicationExecutable): Object with path to executable.\n        env_group (Optional[str]): Environment variable group. If not set\n            'DEFAULT_ENV_SUBGROUP' is used.\n        launch_type (Optional[str]): Launch type. If not set 'local' is used.\n        **data (dict): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n    \"\"\"\n\n    def __init__(\n        self,\n        application: Application,\n        executable: ApplicationExecutable,\n        env_group: Optional[str] = None,\n        launch_type: Optional[str] = None,\n        **data,\n    ):\n        from .process import ProcessManager\n\n        # Application object\n        self.application: Application = application\n\n        self.addons_manager: AddonsManager = AddonsManager()\n        self.process_manager: ProcessManager = ProcessManager()\n        self.redirect_output: bool = application.redirect_output\n\n        # Logger\n        self.log: logging.Logger = Logger.get_logger(\n            f\"{self.__class__.__name__}-{application.full_name}\"\n        )\n\n        self.executable: ApplicationExecutable = executable\n\n        if launch_type is None:\n            launch_type = LaunchTypes.local\n        self.launch_type: str = launch_type\n\n        if env_group is None:\n            env_group = DEFAULT_ENV_SUBGROUP\n\n        self.env_group: str = env_group\n\n        self.data: dict[str, Any] = dict(data)\n\n        launch_args = []\n        if executable is not None:\n            launch_args = executable.as_args()\n        # subprocess.Popen launch arguments (first argument in constructor)\n        self.launch_args: list[str] = launch_args\n        self.launch_args.extend(application.arguments)\n        if self.data.get(\"app_args\"):\n            self.launch_args.extend(self.data.pop(\"app_args\"))\n\n        # Handle launch environemtns\n        src_env = self.data.pop(\"env\", None)\n        if src_env is not None and not isinstance(src_env, dict):\n            self.log.warning(\n                f\"Passed `env` kwarg has invalid type: {type(src_env)}.\"\n                \" Expected: `dict`. Using `os.environ` instead.\"\n            )\n            src_env = None\n\n        if src_env is None:\n            src_env = os.environ\n\n        ignored_env = {\"QT_API\", }\n        env = {\n            key: str(value)\n            for key, value in src_env.items()\n            if key not in ignored_env\n        }\n        # subprocess.Popen keyword arguments\n        self.kwargs: dict[str, Any] = {\"env\": env}\n\n        if platform.system().lower() == \"windows\":\n            # Detach new process from currently running process on Windows\n            flags = (\n                subprocess.CREATE_NEW_PROCESS_GROUP\n                | subprocess.DETACHED_PROCESS\n            )\n            self.kwargs[\"creationflags\"] = flags\n\n        if not sys.stdout:\n            self.kwargs[\"stdout\"] = subprocess.DEVNULL\n            self.kwargs[\"stderr\"] = subprocess.DEVNULL\n\n        # TODO: add type hints\n        # note that these need to be None in order to trigger discovery\n        # when 'discover_launch_hooks' is called\n        self.prelaunch_hooks = None\n        self.postlaunch_hooks = None\n\n        self.process: Optional[Popen] = None\n        self._prelaunch_hooks_executed = False\n\n    @property\n    def env(self) -&gt; dict[str, str]:\n        if (\n            \"env\" not in self.kwargs\n            or self.kwargs[\"env\"] is None\n        ):\n            self.kwargs[\"env\"] = {}\n        return self.kwargs[\"env\"]\n\n    @env.setter\n    def env(self, value: dict[str, str]) -&gt; None:\n        if not isinstance(value, dict):\n            raise TypeError(\n                f\"'env' attribute expect 'dict' object. Got: {type(value)}\"\n            )\n        self.kwargs[\"env\"] = value\n\n    @property\n    def modules_manager(self) -&gt; AddonsManager:\n        \"\"\"\n        Deprecated:\n            Use 'addons_manager' instead.\n\n        \"\"\"\n        return self.addons_manager\n\n    def _collect_addons_launch_hook_paths(self) -&gt; list[str]:\n        \"\"\"Helper to collect application launch hooks from addons.\n\n        Module have to have implemented 'get_launch_hook_paths' method which\n        can expect application as argument or nothing.\n\n        Returns:\n            list[str]: Paths to launch hook directories.\n\n        \"\"\"\n        expected_types = (list, tuple, set)\n\n        output = []\n        for module in self.addons_manager.get_enabled_addons():\n            # Skip module if does not have implemented 'get_launch_hook_paths'\n            func = getattr(module, \"get_launch_hook_paths\", None)\n            if func is None:\n                continue\n\n            func = module.get_launch_hook_paths\n            if hasattr(inspect, \"signature\"):\n                sig = inspect.signature(func)\n                expect_args = len(sig.parameters) &gt; 0\n            else:\n                expect_args = len(inspect.getargspec(func)[0]) &gt; 0\n\n            # Pass application argument if method expect it.\n            try:\n                if expect_args:\n                    hook_paths = func(self.application)\n                else:\n                    hook_paths = func()\n            except Exception:\n                self.log.warning(\n                    \"Failed to call 'get_launch_hook_paths'\",\n                    exc_info=True\n                )\n                continue\n\n            if not hook_paths:\n                continue\n\n            # Convert string to list\n            if isinstance(hook_paths, str):\n                hook_paths = [hook_paths]\n\n            # Skip invalid types\n            if not isinstance(hook_paths, expected_types):\n                self.log.warning(\n                    \"Result of `get_launch_hook_paths` has invalid\"\n                    f\" type {type(hook_paths)}. Expected {expected_types}\"\n                )\n                continue\n\n            output.extend(hook_paths)\n        return output\n\n    def paths_to_launch_hooks(self) -&gt; list[str]:\n        \"\"\"Directory paths where to look for launch hooks.\"\"\"\n        # This method has potential to be part of application manager (maybe).\n        paths = []\n\n        # TODO load additional studio paths from settings\n        global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n        hooks_dirs = [\n            global_hooks_dir\n        ]\n        if self.host_name:\n            # If host requires launch hooks and is module then launch hooks\n            #   should be collected using 'collect_launch_hook_paths'\n            #   - module have to implement 'get_launch_hook_paths'\n            host_module = self.addons_manager.get_host_addon(self.host_name)\n            if not host_module:\n                hooks_dirs.append(os.path.join(\n                    AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n                ))\n\n        for path in hooks_dirs:\n            if (\n                os.path.exists(path)\n                and os.path.isdir(path)\n                and path not in paths\n            ):\n                paths.append(path)\n\n        # Load modules paths\n        paths.extend(self._collect_addons_launch_hook_paths())\n\n        return paths\n\n    def discover_launch_hooks(self, force: bool = False) -&gt; None:\n        \"\"\"Load and prepare launch hooks.\"\"\"\n        if (\n            self.prelaunch_hooks is not None\n            or self.postlaunch_hooks is not None\n        ):\n            if not force:\n                self.log.info(\"Launch hooks were already discovered.\")\n                return\n\n            self.prelaunch_hooks.clear()\n            self.postlaunch_hooks.clear()\n\n        self.log.debug(\"Discovery of launch hooks started.\")\n\n        paths = self.paths_to_launch_hooks()\n        self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n            \"\\n\".join(f\"- {path}\" for path in paths)\n        ))\n\n        all_classes: dict[str, list[Type[Union[PreLaunchHook, PostLaunchHook]]]] = {  # noqa: E501\n            \"pre\": [],\n            \"post\": []\n        }\n        for path in paths:\n            if not os.path.exists(path):\n                self.log.info(\n                    f\"Path to launch hooks does not exist: \\\"{path}\\\"\"\n                )\n                continue\n\n            modules, _crashed = modules_from_path(path)\n            for _filepath, module in modules:\n                all_classes[\"pre\"].extend(\n                    classes_from_module(PreLaunchHook, module)\n                )\n                all_classes[\"post\"].extend(\n                    classes_from_module(PostLaunchHook, module)\n                )\n\n        for launch_type, classes in all_classes.items():\n            hooks_with_order = []\n            hooks_without_order = []\n            for klass in classes:\n                try:\n                    hook = klass(self)\n                    if not hook.is_valid:\n                        self.log.debug(\n                            \"Skipped hook invalid for current launch context:\"\n                            f\" {klass.__name__}\"\n                        )\n                        continue\n\n                    if inspect.isabstract(hook):\n                        self.log.debug(\n                            f\"Skipped abstract hook: {klass.__name__}\"\n                        )\n                        continue\n\n                    # Separate hooks by pre/post class\n                    if hook.order is None:\n                        hooks_without_order.append(hook)\n                    else:\n                        hooks_with_order.append(hook)\n\n                except Exception:\n                    self.log.warning(\n                        f\"Initialization of hook failed: {klass.__name__}\",\n                        exc_info=True\n                    )\n\n            # Sort hooks with order by order\n            ordered_hooks = list(sorted(\n                hooks_with_order, key=lambda obj: obj.order\n            ))\n            # Extend ordered hooks with hooks without defined order\n            ordered_hooks.extend(hooks_without_order)\n\n            if launch_type == \"pre\":\n                self.prelaunch_hooks = ordered_hooks\n            else:\n                self.postlaunch_hooks = ordered_hooks\n\n        self.log.debug(\n            f\"Found {len(self.prelaunch_hooks)} prelaunch\"\n            f\" and {len(self.postlaunch_hooks)} postlaunch hooks.\"\n        )\n\n    @property\n    def app_name(self) -&gt; str:\n        return self.application.name\n\n    @property\n    def host_name(self) -&gt; str:\n        return self.application.host_name\n\n    @property\n    def app_group(self) -&gt; ApplicationGroup:\n        return self.application.group\n\n    @property\n    def manager(self) -&gt; ApplicationManager:\n        return self.application.manager\n\n    def _run_process(self) -&gt; subprocess.Popen:\n        \"\"\"Run the process with the given launch arguments and keyword args.\n\n        This method will handle the process differently based on the platform\n        it is running on. It will create a temporary file for output on\n        Windows and macos, while on Linux it will use a mid-process to launch\n        the application with the provided arguments and environment variables.\n\n        It will pass file paths to temporary files to the mid-process where\n        the process output and pid will be stored.\n\n        Returns:\n            subprocess.Popen: The process object created by Popen.\n\n        \"\"\"\n        # Windows and macOS have easier process start\n        low_platform = platform.system().lower()\n        if low_platform in (\"windows\", \"darwin\"):\n            return self._execute_with_stdout()\n        # Linux uses mid-process\n        # - it is possible that the mid-process executable is not\n        #   available for this version of AYON in that case use standard\n        #   launch\n        launch_args = get_linux_launcher_args()\n        if launch_args is None:\n            return subprocess.Popen(self.launch_args, **self.kwargs)\n\n        # Prepare data that will be passed to mid-process\n        # - store arguments to a json and pass path to json as last argument\n        # - pass environments to set\n        app_env = self.kwargs.pop(\"env\", {})\n        # create temporary file path passed to mid-process\n\n        output_file = None\n        if self.redirect_output:\n            with tempfile.NamedTemporaryFile(\n                mode=\"w\",\n                prefix=f\"ayon_{self.application.host_name}_output_\",\n                suffix=\".txt\",\n                delete=False,\n                encoding=\"utf-8\",\n            ) as temp_file:\n                output_file = temp_file.name\n        # create temporary file to read back pid\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\",\n            prefix=\"ayon_pid_\",\n            suffix=\".txt\",\n            delete=False,\n            encoding=\"utf-8\",\n        ) as pid_temp_file:\n            pid_file = pid_temp_file.name\n\n        json_data = {\n            \"args\": self.launch_args,\n            \"env\": app_env,\n            \"pid_file\": pid_file,\n        }\n        if output_file:\n            json_data[\"stdout\"] = output_file\n            json_data[\"stderr\"] = output_file\n\n        if app_env:\n            # Filter environments of subprocess\n            self.kwargs[\"env\"] = {\n                key: value\n                for key, value in os.environ.items()\n                if key in app_env\n            }\n\n        # Create the temp file\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ay_app_args\", suffix=\".json\", delete=False\n        ) as json_temp:\n            json_temp_filepath = json_temp.name\n            json.dump(json_data, json_temp)\n\n        launch_args.append(json_temp_filepath)\n\n        # Create mid-process which will launch application\n        process = subprocess.Popen(launch_args, **self.kwargs)\n        # Wait until the process finishes\n        #   - This is important! The process would stay in \"open\" state.\n        process.wait()\n\n        # read back pid from the json file\n        try:\n            with open(json_temp_filepath, encoding=\"utf-8\") as stream:\n                json_data = json.load(stream)\n\n                try:\n                    import psutil\n                except ImportError:\n                    psutil = None\n\n                pid_from_mid = json_data.get(\"pid\")\n                executable = Path(str(self.executable))\n                start_time = None\n                if pid_from_mid and psutil:\n                    start_time = (\n                        self.process_manager.get_process_start_time_by_pid(\n                            pid_from_mid)\n                    )\n                    executable = (\n                        self.process_manager.get_executable_path_by_pid(\n                            pid_from_mid)\n                    ) or executable\n\n                from .process import ProcessInfo\n\n                process_info = ProcessInfo(\n                    name=self.application.full_name,\n                    executable=executable,\n                    args=self.launch_args,\n                    env=app_env,\n                    cwd=self.kwargs.get(\"cwd\") or os.getcwd(),\n                    pid=pid_from_mid,\n                    output=Path(output_file) if self.redirect_output else None,\n                    start_time=start_time,\n                )\n                # Store process info to the database\n                self.process_manager.store_process_info(process_info)\n        except OSError:\n            self.log.exception(\n                \"Failed to read process info from JSON file: %s\"\n            )\n\n        # Remove the temp file\n        os.remove(json_temp_filepath)\n        # Return process which is already terminated\n        return process\n\n    def run_prelaunch_hooks(self) -&gt; None:\n        \"\"\"Run prelaunch hooks.\n\n        This method will be executed only once, any future calls will skip\n        the processing.\n\n        Raises:\n            RuntimeError: When prelaunch hooks were already executed.\n\n        \"\"\"\n        if self._prelaunch_hooks_executed:\n            self.log.warning(\"Prelaunch hooks were already executed.\")\n            return\n        # Discover launch hooks\n        self.discover_launch_hooks()\n\n        # Execute prelaunch hooks\n        for hook in self.prelaunch_hooks:\n            self.log.debug(\n                f\"Executing prelaunch hook: {hook.__class__.__name__}\"\n            )\n            hook.execute()\n        self._prelaunch_hooks_executed = True\n\n    def launch(self) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Collect data for new process and then create it.\n\n        This method must not be executed more than once.\n\n        Returns:\n            subprocess.Popen: Created process as Popen object.\n\n        \"\"\"\n        if self.process is not None:\n            self.log.warning(\"Application was already launched.\")\n            return None\n\n        if not self._prelaunch_hooks_executed:\n            self.run_prelaunch_hooks()\n\n        self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n        # Prepare subprocess args\n        args_len_str = \"\"\n        if isinstance(self.launch_args, str):\n            args = self.launch_args\n        else:\n            args = self.clear_launch_args(self.launch_args)\n            args_len_str = f\" ({len(args)})\"\n        self.log.info(\n            f'Launching \"{self.application.full_name}\"'\n            f\" with args{args_len_str}: {args}\"\n        )\n        self.launch_args = args\n\n        # Run process\n        self.process = self._run_process()\n\n        # Process post launch hooks\n        for hook in self.postlaunch_hooks:\n            self.log.debug(\n                f\"Executing postlaunch hook: {hook.__class__.__name__}\"\n            )\n\n            # TODO how to handle errors?\n            # - store to variable to let them accessible?\n            try:\n                hook.execute()\n\n            except Exception:\n                self.log.warning(\n                    \"After launch procedures were not successful.\",\n                    exc_info=True,\n                )\n\n        self.log.debug(f\"Launch of {self.application.full_name} finished.\")\n\n        return self.process\n\n    @staticmethod\n    def clear_launch_args(args: list) -&gt; list[str]:\n        \"\"\"Collect launch arguments to final order.\n\n        Launch argument should be a list that may contain another lists this\n        function will upack inner lists and keep ordering.\n\n        ```\n        # source\n        [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n        # result\n        [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n        Args:\n            args (list): Source arguments in list may contain inner lists.\n\n        Returns:\n            list: Unpacked arguments.\n\n        \"\"\"\n        all_cleared = False\n        while not all_cleared:\n            all_cleared = True\n            new_args = []\n            for arg in args:\n                if isinstance(arg, (list, tuple, set)):\n                    all_cleared = False\n                    for _arg in arg:\n                        new_args.append(_arg)\n                else:\n                    new_args.append(arg)\n            args = new_args\n\n        return args\n\n    def _execute_with_stdout(self) -&gt; subprocess.Popen:\n        \"\"\"Run the process with stdout and stderr redirected to a file.\n\n        Stores process information to the database.\n\n        Returns:\n            subprocess.Popen: The process object created by Popen.\n        \"\"\"\n        from .process import ProcessInfo\n\n        process_info = ProcessInfo(\n            name=self.application.full_name,\n            executable=Path(str(self.executable)),\n            args=self.launch_args,\n            env=self.kwargs.get(\"env\", {}),\n            cwd=self.kwargs.get(\"cwd\") or os.getcwd(),\n            output=None,\n            pid=None,\n            start_time=None,\n        )\n\n        if self.redirect_output:\n            with tempfile.NamedTemporaryFile(\n                mode=\"w\",\n                prefix=f\"ayon_{self.application.host_name}_output_\",\n                suffix=\".txt\",\n                delete=False,\n                encoding=\"utf-8\",\n            ) as temp_file:\n                temp_file_path = temp_file.name\n\n            with open(temp_file_path, \"wb\") as tmp_file:\n                self.kwargs[\"stdout\"] = tmp_file\n                self.kwargs[\"stderr\"] = tmp_file\n                process = subprocess.Popen(self.launch_args, **self.kwargs)\n                process_info.output = Path(temp_file_path)\n        else:\n            process = subprocess.Popen(self.launch_args, **self.kwargs)\n\n        start_time = self.process_manager.get_process_start_time(process)\n        process_info.pid = process.pid\n        process_info.start_time = start_time\n        # Store process info to the database\n        self.process_manager.store_process_info(process_info)\n\n        return process\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.modules_manager","title":"<code>modules_manager</code>  <code>property</code>","text":"Deprecated <p>Use 'addons_manager' instead.</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.clear_launch_args","title":"<code>clear_launch_args(args)</code>  <code>staticmethod</code>","text":"<p>Collect launch arguments to final order.</p> <p>Launch argument should be a list that may contain another lists this function will upack inner lists and keep ordering.</p> <p>```</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.clear_launch_args--source","title":"source","text":"<p>[ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.clear_launch_args--result","title":"result","text":"<p>[ arg1, arg2, arg3, arg4, arg5, arg6]</p> <p>Args:     args (list): Source arguments in list may contain inner lists.</p> <p>Returns:     list: Unpacked arguments.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>@staticmethod\ndef clear_launch_args(args: list) -&gt; list[str]:\n    \"\"\"Collect launch arguments to final order.\n\n    Launch argument should be a list that may contain another lists this\n    function will upack inner lists and keep ordering.\n\n    ```\n    # source\n    [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n    # result\n    [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n    Args:\n        args (list): Source arguments in list may contain inner lists.\n\n    Returns:\n        list: Unpacked arguments.\n\n    \"\"\"\n    all_cleared = False\n    while not all_cleared:\n        all_cleared = True\n        new_args = []\n        for arg in args:\n            if isinstance(arg, (list, tuple, set)):\n                all_cleared = False\n                for _arg in arg:\n                    new_args.append(_arg)\n            else:\n                new_args.append(arg)\n        args = new_args\n\n    return args\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.discover_launch_hooks","title":"<code>discover_launch_hooks(force=False)</code>","text":"<p>Load and prepare launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def discover_launch_hooks(self, force: bool = False) -&gt; None:\n    \"\"\"Load and prepare launch hooks.\"\"\"\n    if (\n        self.prelaunch_hooks is not None\n        or self.postlaunch_hooks is not None\n    ):\n        if not force:\n            self.log.info(\"Launch hooks were already discovered.\")\n            return\n\n        self.prelaunch_hooks.clear()\n        self.postlaunch_hooks.clear()\n\n    self.log.debug(\"Discovery of launch hooks started.\")\n\n    paths = self.paths_to_launch_hooks()\n    self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n        \"\\n\".join(f\"- {path}\" for path in paths)\n    ))\n\n    all_classes: dict[str, list[Type[Union[PreLaunchHook, PostLaunchHook]]]] = {  # noqa: E501\n        \"pre\": [],\n        \"post\": []\n    }\n    for path in paths:\n        if not os.path.exists(path):\n            self.log.info(\n                f\"Path to launch hooks does not exist: \\\"{path}\\\"\"\n            )\n            continue\n\n        modules, _crashed = modules_from_path(path)\n        for _filepath, module in modules:\n            all_classes[\"pre\"].extend(\n                classes_from_module(PreLaunchHook, module)\n            )\n            all_classes[\"post\"].extend(\n                classes_from_module(PostLaunchHook, module)\n            )\n\n    for launch_type, classes in all_classes.items():\n        hooks_with_order = []\n        hooks_without_order = []\n        for klass in classes:\n            try:\n                hook = klass(self)\n                if not hook.is_valid:\n                    self.log.debug(\n                        \"Skipped hook invalid for current launch context:\"\n                        f\" {klass.__name__}\"\n                    )\n                    continue\n\n                if inspect.isabstract(hook):\n                    self.log.debug(\n                        f\"Skipped abstract hook: {klass.__name__}\"\n                    )\n                    continue\n\n                # Separate hooks by pre/post class\n                if hook.order is None:\n                    hooks_without_order.append(hook)\n                else:\n                    hooks_with_order.append(hook)\n\n            except Exception:\n                self.log.warning(\n                    f\"Initialization of hook failed: {klass.__name__}\",\n                    exc_info=True\n                )\n\n        # Sort hooks with order by order\n        ordered_hooks = list(sorted(\n            hooks_with_order, key=lambda obj: obj.order\n        ))\n        # Extend ordered hooks with hooks without defined order\n        ordered_hooks.extend(hooks_without_order)\n\n        if launch_type == \"pre\":\n            self.prelaunch_hooks = ordered_hooks\n        else:\n            self.postlaunch_hooks = ordered_hooks\n\n    self.log.debug(\n        f\"Found {len(self.prelaunch_hooks)} prelaunch\"\n        f\" and {len(self.postlaunch_hooks)} postlaunch hooks.\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.launch","title":"<code>launch()</code>","text":"<p>Collect data for new process and then create it.</p> <p>This method must not be executed more than once.</p> <p>Returns:</p> Type Description <code>Optional[Popen]</code> <p>subprocess.Popen: Created process as Popen object.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Collect data for new process and then create it.\n\n    This method must not be executed more than once.\n\n    Returns:\n        subprocess.Popen: Created process as Popen object.\n\n    \"\"\"\n    if self.process is not None:\n        self.log.warning(\"Application was already launched.\")\n        return None\n\n    if not self._prelaunch_hooks_executed:\n        self.run_prelaunch_hooks()\n\n    self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n    # Prepare subprocess args\n    args_len_str = \"\"\n    if isinstance(self.launch_args, str):\n        args = self.launch_args\n    else:\n        args = self.clear_launch_args(self.launch_args)\n        args_len_str = f\" ({len(args)})\"\n    self.log.info(\n        f'Launching \"{self.application.full_name}\"'\n        f\" with args{args_len_str}: {args}\"\n    )\n    self.launch_args = args\n\n    # Run process\n    self.process = self._run_process()\n\n    # Process post launch hooks\n    for hook in self.postlaunch_hooks:\n        self.log.debug(\n            f\"Executing postlaunch hook: {hook.__class__.__name__}\"\n        )\n\n        # TODO how to handle errors?\n        # - store to variable to let them accessible?\n        try:\n            hook.execute()\n\n        except Exception:\n            self.log.warning(\n                \"After launch procedures were not successful.\",\n                exc_info=True,\n            )\n\n    self.log.debug(f\"Launch of {self.application.full_name} finished.\")\n\n    return self.process\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.paths_to_launch_hooks","title":"<code>paths_to_launch_hooks()</code>","text":"<p>Directory paths where to look for launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def paths_to_launch_hooks(self) -&gt; list[str]:\n    \"\"\"Directory paths where to look for launch hooks.\"\"\"\n    # This method has potential to be part of application manager (maybe).\n    paths = []\n\n    # TODO load additional studio paths from settings\n    global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n    hooks_dirs = [\n        global_hooks_dir\n    ]\n    if self.host_name:\n        # If host requires launch hooks and is module then launch hooks\n        #   should be collected using 'collect_launch_hook_paths'\n        #   - module have to implement 'get_launch_hook_paths'\n        host_module = self.addons_manager.get_host_addon(self.host_name)\n        if not host_module:\n            hooks_dirs.append(os.path.join(\n                AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n            ))\n\n    for path in hooks_dirs:\n        if (\n            os.path.exists(path)\n            and os.path.isdir(path)\n            and path not in paths\n        ):\n            paths.append(path)\n\n    # Load modules paths\n    paths.extend(self._collect_addons_launch_hook_paths())\n\n    return paths\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.run_prelaunch_hooks","title":"<code>run_prelaunch_hooks()</code>","text":"<p>Run prelaunch hooks.</p> <p>This method will be executed only once, any future calls will skip the processing.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>When prelaunch hooks were already executed.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def run_prelaunch_hooks(self) -&gt; None:\n    \"\"\"Run prelaunch hooks.\n\n    This method will be executed only once, any future calls will skip\n    the processing.\n\n    Raises:\n        RuntimeError: When prelaunch hooks were already executed.\n\n    \"\"\"\n    if self._prelaunch_hooks_executed:\n        self.log.warning(\"Prelaunch hooks were already executed.\")\n        return\n    # Discover launch hooks\n    self.discover_launch_hooks()\n\n    # Execute prelaunch hooks\n    for hook in self.prelaunch_hooks:\n        self.log.debug(\n            f\"Executing prelaunch hook: {hook.__class__.__name__}\"\n        )\n        hook.execute()\n    self._prelaunch_hooks_executed = True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager","title":"<code>ApplicationManager</code>","text":"<p>Load applications and tools and store them by their full name.</p> <p>Parameters:</p> Name Type Description Default <code>studio_settings</code> <code>dict</code> <p>Preloaded studio settings. When passed manager will always use these values. Gives ability to create manager using different settings.</p> <code>None</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationManager:\n    \"\"\"Load applications and tools and store them by their full name.\n\n    Args:\n        studio_settings (dict): Preloaded studio settings. When passed manager\n            will always use these values. Gives ability to create manager\n            using different settings.\n    \"\"\"\n\n    def __init__(self, studio_settings: Optional[dict[str, Any]] = None):\n        self.log = Logger.get_logger(self.__class__.__name__)\n\n        self.app_groups: dict[str, ApplicationGroup] = {}\n        self.applications: dict[str, Application] = {}\n        self.tool_groups: dict[str, EnvironmentToolGroup] = {}\n        self.tools: dict[str, EnvironmentTool] = {}\n\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def set_studio_settings(self, studio_settings: dict[str, Any]) -&gt; None:\n        \"\"\"Ability to change init system settings.\n\n        This will trigger refresh of manager.\n        \"\"\"\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refresh applications from settings.\"\"\"\n        self.app_groups.clear()\n        self.applications.clear()\n        self.tool_groups.clear()\n        self.tools.clear()\n\n        if self._studio_settings is not None:\n            settings = copy.deepcopy(self._studio_settings)\n        else:\n            settings = get_studio_settings(\n                clear_metadata=False, exclude_locals=False\n            )\n\n        applications_addon_settings = settings[\"applications\"]\n\n        # Prepare known applications\n        app_defs = applications_addon_settings[\"applications\"]\n        additional_apps = app_defs.pop(\"additional_apps\")\n        for additional_app in additional_apps:\n            app_name = additional_app.pop(\"name\")\n            if app_name in app_defs:\n                self.log.warning(\n                    f\"Additional application '{app_name}' is already\"\n                    \" in built-in applications.\"\n                )\n            app_defs[app_name] = additional_app\n\n        for group_name, variant_defs in app_defs.items():\n            group = ApplicationGroup(group_name, variant_defs, self)\n            self.app_groups[group_name] = group\n            for app in group:\n                self.applications[app.full_name] = app\n\n        tools_definitions = applications_addon_settings[\"tool_groups\"]\n        for tool_group_data in tools_definitions:\n            group = EnvironmentToolGroup(tool_group_data, self)\n            self.tool_groups[group.name] = group\n            for tool in group:\n                self.tools[tool.full_name] = tool\n\n    def find_latest_available_variant_for_group(\n        self, group_name: str\n    ) -&gt; Optional[ApplicationGroup]:\n        group = self.app_groups.get(group_name)\n        if group is None or not group.enabled:\n            return None\n\n        output = None\n        for _, variant in reversed(sorted(group.variants.items())):\n            executable = variant.find_executable()\n            if executable:\n                output = variant\n                break\n        return output\n\n    def create_launch_context(\n        self, app_name: str, **data\n    ) -&gt; \"ApplicationLaunchContext\":\n        \"\"\"Prepare launch context for application.\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n\n        Returns:\n            ApplicationLaunchContext: Launch context for application.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered name.\n        \"\"\"\n\n        app = self.applications.get(app_name)\n        if not app:\n            raise ApplicationNotFound(app_name)\n\n        executable = app.find_executable()\n\n        return ApplicationLaunchContext(\n            app, executable, **data\n        )\n\n    def launch_with_context(\n        self, launch_context: \"ApplicationLaunchContext\"\n    ) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Launch application using existing launch context.\n\n        Args:\n            launch_context (ApplicationLaunchContext): Prepared launch\n                context.\n        \"\"\"\n\n        if not launch_context.executable:\n            raise ApplicationExecutableNotFound(launch_context.application)\n        return launch_context.launch()\n\n    def launch(self, app_name, **data) -&gt; Optional[subprocess.Popen]:\n        \"\"\"Launch procedure.\n\n        For host application it's expected to contain \"project_name\",\n        \"folder_path\" and \"task_name\".\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n                preparation to store objects usable in multiple places.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered\n                argument `app_name`.\n            ApplicationExecutableNotFound: Executables in application\n                definition were not found on this machine.\n            ApplicationLaunchFailed: Something important for application launch\n                failed. Exception should contain an explanation message,\n                traceback should not be needed.\n\n        \"\"\"\n        context = self.create_launch_context(app_name, **data)\n        return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.create_launch_context","title":"<code>create_launch_context(app_name, **data)</code>","text":"<p>Prepare launch context for application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ApplicationLaunchContext</code> <code>'ApplicationLaunchContext'</code> <p>Launch context for application.</p> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered name.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def create_launch_context(\n    self, app_name: str, **data\n) -&gt; \"ApplicationLaunchContext\":\n    \"\"\"Prepare launch context for application.\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n\n    Returns:\n        ApplicationLaunchContext: Launch context for application.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered name.\n    \"\"\"\n\n    app = self.applications.get(app_name)\n    if not app:\n        raise ApplicationNotFound(app_name)\n\n    executable = app.find_executable()\n\n    return ApplicationLaunchContext(\n        app, executable, **data\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.launch","title":"<code>launch(app_name, **data)</code>","text":"<p>Launch procedure.</p> <p>For host application it's expected to contain \"project_name\", \"folder_path\" and \"task_name\".</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered argument <code>app_name</code>.</p> <code>ApplicationExecutableNotFound</code> <p>Executables in application definition were not found on this machine.</p> <code>ApplicationLaunchFailed</code> <p>Something important for application launch failed. Exception should contain an explanation message, traceback should not be needed.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self, app_name, **data) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Launch procedure.\n\n    For host application it's expected to contain \"project_name\",\n    \"folder_path\" and \"task_name\".\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered\n            argument `app_name`.\n        ApplicationExecutableNotFound: Executables in application\n            definition were not found on this machine.\n        ApplicationLaunchFailed: Something important for application launch\n            failed. Exception should contain an explanation message,\n            traceback should not be needed.\n\n    \"\"\"\n    context = self.create_launch_context(app_name, **data)\n    return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.launch_with_context","title":"<code>launch_with_context(launch_context)</code>","text":"<p>Launch application using existing launch context.</p> <p>Parameters:</p> Name Type Description Default <code>launch_context</code> <code>ApplicationLaunchContext</code> <p>Prepared launch context.</p> required Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch_with_context(\n    self, launch_context: \"ApplicationLaunchContext\"\n) -&gt; Optional[subprocess.Popen]:\n    \"\"\"Launch application using existing launch context.\n\n    Args:\n        launch_context (ApplicationLaunchContext): Prepared launch\n            context.\n    \"\"\"\n\n    if not launch_context.executable:\n        raise ApplicationExecutableNotFound(launch_context.application)\n    return launch_context.launch()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.refresh","title":"<code>refresh()</code>","text":"<p>Refresh applications from settings.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh applications from settings.\"\"\"\n    self.app_groups.clear()\n    self.applications.clear()\n    self.tool_groups.clear()\n    self.tools.clear()\n\n    if self._studio_settings is not None:\n        settings = copy.deepcopy(self._studio_settings)\n    else:\n        settings = get_studio_settings(\n            clear_metadata=False, exclude_locals=False\n        )\n\n    applications_addon_settings = settings[\"applications\"]\n\n    # Prepare known applications\n    app_defs = applications_addon_settings[\"applications\"]\n    additional_apps = app_defs.pop(\"additional_apps\")\n    for additional_app in additional_apps:\n        app_name = additional_app.pop(\"name\")\n        if app_name in app_defs:\n            self.log.warning(\n                f\"Additional application '{app_name}' is already\"\n                \" in built-in applications.\"\n            )\n        app_defs[app_name] = additional_app\n\n    for group_name, variant_defs in app_defs.items():\n        group = ApplicationGroup(group_name, variant_defs, self)\n        self.app_groups[group_name] = group\n        for app in group:\n            self.applications[app.full_name] = app\n\n    tools_definitions = applications_addon_settings[\"tool_groups\"]\n    for tool_group_data in tools_definitions:\n        group = EnvironmentToolGroup(tool_group_data, self)\n        self.tool_groups[group.name] = group\n        for tool in group:\n            self.tools[tool.full_name] = tool\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.set_studio_settings","title":"<code>set_studio_settings(studio_settings)</code>","text":"<p>Ability to change init system settings.</p> <p>This will trigger refresh of manager.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def set_studio_settings(self, studio_settings: dict[str, Any]) -&gt; None:\n    \"\"\"Ability to change init system settings.\n\n    This will trigger refresh of manager.\n    \"\"\"\n    self._studio_settings = studio_settings\n\n    self.refresh()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html","title":"process","text":"<p>Handling of processes in Ayon Applications.</p>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessIdTriplet","title":"<code>ProcessIdTriplet</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Triplet of process identification values.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>class ProcessIdTriplet(NamedTuple):\n    \"\"\"Triplet of process identification values.\"\"\"\n    pid: int\n    executable: str\n    start_time: Optional[float]  # the same goes for start time\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessInfo","title":"<code>ProcessInfo</code>  <code>dataclass</code>","text":"<p>Information about a process launched by the addon.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the process.</p> <code>executable</code> <code>Path</code> <p>Path to the executable.</p> <code>args</code> <code>list[str]</code> <p>Arguments for the process.</p> <code>env</code> <code>dict[str, str]</code> <p>Environment variables for the process.</p> <code>hash</code> <code>str</code> <p>Hash of the process information.</p> <code>cwd</code> <code>str</code> <p>Current working directory for the process.</p> <code>pid</code> <code>int</code> <p>Process ID of the launched process.</p> <code>active</code> <code>bool</code> <p>Whether the process is currently active.</p> <code>output</code> <code>Path</code> <p>Output of the process.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@dataclass\nclass ProcessInfo:\n    \"\"\"Information about a process launched by the addon.\n\n    Attributes:\n        name (str): Name of the process.\n        executable (Path): Path to the executable.\n        args (list[str]): Arguments for the process.\n        env (dict[str, str]): Environment variables for the process.\n        hash (str): Hash of the process information.\n        cwd (str): Current working directory for the process.\n        pid (int): Process ID of the launched process.\n        active (bool): Whether the process is currently active.\n        output (Path): Output of the process.\n\n    \"\"\"\n\n    name: str\n    executable: Path\n    args: list[str]\n    env: dict[str, str]\n    cwd: str\n    hash: Optional[str] = None\n    pid: Optional[int] = None\n    active: bool = False\n    output: Optional[Path] = None\n    start_time: Optional[float] = None\n    created_at: Optional[str] = None\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post-initialization to compute the hash if not provided.\"\"\"\n        if self.hash is None:\n            self.hash = ProcessManager.get_process_info_hash(self)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessInfo.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization to compute the hash if not provided.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post-initialization to compute the hash if not provided.\"\"\"\n    if self.hash is None:\n        self.hash = ProcessManager.get_process_info_hash(self)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager","title":"<code>ProcessManager</code>","text":"<p>Manager for handling processes in AYON Applications.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>class ProcessManager:\n    \"\"\"Manager for handling processes in AYON Applications.\"\"\"\n\n    log: logging.Logger\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ProcessManager.\"\"\"\n        self.log = logging.getLogger(f\"{__name__}.ProcessManager\")\n        # Use thread-local storage for SQLite connections to avoid\n        # sharing connections between threads (fixes Linux SQLite issues)\n        self._thread_local = threading.local()\n\n    @staticmethod\n    def get_process_info_storage_location() -&gt; Path:\n        \"\"\"Get the path to process info storage.\n\n        Returns:\n            Path: Path to the process handlers storage.\n\n        \"\"\"\n        return Path(get_launcher_local_dir()) / \"process_handlers.db\"\n\n    def _get_process_storage_connection(self) -&gt; sqlite3.Connection:\n        \"\"\"Get a thread-local SQLite connection.\n\n        Each thread gets its own connection to avoid thread-safety issues\n        that can occur on Linux.\n\n        Returns:\n            sqlite3.Connection: Thread-local connection to the process storage.\n\n        \"\"\"\n        # Check if this thread already has a connection\n        if hasattr(self._thread_local, \"connection\"):\n            return self._thread_local.connection\n\n        # Create a new connection for this thread\n        cnx = sqlite3.connect(\n            self.get_process_info_storage_location(),\n            # Enable thread safety for SQLite operations\n            check_same_thread=False\n        )\n        cursor = cnx.cursor()\n        cursor.execute(\n            \"CREATE TABLE IF NOT EXISTS process_info (\"\n            \"hash TEXT PRIMARY KEY, \"\n            \"name TEXT, \"\n            \"executable TEXT, \"\n            \"args TEXT DEFAULT NULL, \"\n            \"env TEXT DEFAULT NULL, \"\n            \"cwd TEXT DEFAULT NULL, \"\n            \"pid INTEGER DEFAULT NULL, \"\n            \"output_file TEXT DEFAULT NULL, \"\n            \"start_time REAL DEFAULT NULL, \"\n            \"created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\"\n            \")\"\n        )\n        cnx.commit()\n        self._thread_local.connection = cnx\n\n        return self._thread_local.connection\n\n    @staticmethod\n    def get_process_info_hash(process_info: ProcessInfo) -&gt; str:\n        \"\"\"Get hash of the process information.\n\n        Returns:\n            str: Hash of the process information.\n        \"\"\"\n        return ProcessManager.get_process_info_hash_by_values(\n            process_info.executable,\n            process_info.name,\n            process_info.pid,\n            process_info.start_time,\n        )\n\n    @staticmethod\n    def get_process_info_hash_by_values(\n        executable: Path,\n        name: str,\n        pid: Optional[int] = None,\n        start_time: Optional[float] = None,\n    ) -&gt; str:\n        \"\"\"Get hash of the process information by values.\n\n        Args:\n            executable (Path): Path to the executable.\n            name (str): Name of the process.\n            pid (Optional[int]): Process ID of the launched process.\n            start_time (Optional[float]): Start time of the process.\n\n        Returns:\n            str: Hash of the process information.\n\n        \"\"\"\n        start = (\n            f\"{start_time}\"\n            if start_time is not None\n            else \"\"\n        )\n        key = f\"{name}{pid}{executable}{start}\"\n        return sha256(key.encode()).hexdigest()\n\n    def store_process_info(self, process_info: ProcessInfo) -&gt; None:\n        \"\"\"Store process information.\n\n        Args:\n            process_info (ProcessInfo): Process handler to store.\n\n        \"\"\"\n        # refresh hash in case some values changed\n        process_info.hash = ProcessManager.get_process_info_hash(process_info)\n        if process_info.pid is None:\n            self.log.warning((\n                \"Cannot store process info for process without PID. \"\n                \"Process name: %s\"\n            ), process_info.name)\n            return\n\n        cnx = self._get_process_storage_connection()\n        cursor = cnx.cursor()\n        cursor.execute(\n            \"INSERT OR REPLACE INTO process_info \"\n            \"(hash, name, executable, args, env, cwd, \"\n            \"pid, output_file, start_time) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            (\n                process_info.hash,\n                process_info.name,\n                process_info.executable.as_posix(),\n                json.dumps(process_info.args),\n                json.dumps(process_info.env),\n                process_info.cwd,\n                process_info.pid,\n                (\n                    process_info.output.as_posix()\n                    if process_info.output else None\n                ),\n                process_info.start_time,\n            )\n        )\n        cnx.commit()\n\n    def get_process_info(self, process_hash: str) -&gt; Optional[ProcessInfo]:\n        \"\"\"Get process information by hash.\n\n        Args:\n            process_hash (str): Hash of the process.\n\n        Returns:\n            Optional[ProcessInfo]: Process information or None if not found.\n        \"\"\"\n        cnx = self._get_process_storage_connection()\n        cursor = cnx.cursor()\n        cursor.execute(\n            \"SELECT * FROM process_info WHERE hash = ?\",\n            (process_hash,)\n        )\n        row = cursor.fetchone()\n        if row is None:\n            return None\n\n        return ProcessInfo(\n            name=row[1],\n            executable=Path(row[2]),\n            args=json.loads(row[3]),\n            env=json.loads(row[4]),\n            cwd=row[5],\n            hash=process_hash,\n            pid=row[6],\n            output=Path(row[7]) if row[7] else None,\n            start_time=row[8],\n            created_at=row[9],\n        )\n\n    def get_process_info_by_name(\n        self, name: str) -&gt; Optional[ProcessInfo]:\n        \"\"\"Get process information by name.\n\n        Args:\n            name (str): Name of the process.\n\n        Returns:\n            Optional[ProcessInfo]: Process information or None if not found.\n        \"\"\"\n        cnx = self._get_process_storage_connection()\n        cursor = cnx.cursor()\n        query = \"SELECT * FROM process_info WHERE name = ?\"\n        params = [name]\n\n        cursor.execute(query, params)\n        row = cursor.fetchone()\n        if row is None:\n            return None\n\n        return ProcessInfo(\n            name=row[1],\n            executable=Path(row[2]),\n            args=json.loads(row[3]),\n            env=json.loads(row[4]),\n            cwd=row[5],\n            pid=row[6],\n            output=Path(row[7]) if row[7] else None,\n            start_time=row[8],\n            created_at=row[9],\n        )\n\n    def get_process_info_by_pid(self, pid: int) -&gt; Optional[ProcessInfo]:\n        \"\"\"Get process information by process id.\n\n        Args:\n            pid (int): ID of the process.\n\n        Returns:\n            Optional[ProcessInfo]: Process information or None if not found.\n        \"\"\"\n        cnx = self._get_process_storage_connection()\n        cursor = cnx.cursor()\n        query = \"SELECT * FROM process_info WHERE pid = ?\"\n        params = [pid]\n\n        cursor.execute(query, params)\n        row = cursor.fetchone()\n        if row is None:\n            return None\n\n        return ProcessInfo(\n            name=row[1],\n            executable=Path(row[2]),\n            args=json.loads(row[3]),\n            env=json.loads(row[4]),\n            cwd=row[5],\n            pid=row[6],\n            output=Path(row[7]) if row[7] else None,\n            start_time=row[8],\n            created_at=row[9],\n        )\n\n    def get_current_process_info(self) -&gt; Optional[ProcessInfo]:\n        \"\"\"Get information for the current process.\n\n        Returns:\n            Optional[ProcessInfo]: Process information or None if not found.\n        \"\"\"\n        return self.get_process_info_by_pid(os.getpid())\n\n    def get_all_process_info(self) -&gt; list[ProcessInfo]:\n        \"\"\"Get all process information from the database.\n\n        Returns:\n            list[ProcessInfo]: List of all process information.\n        \"\"\"\n        cnx = self._get_process_storage_connection()\n        cursor = cnx.cursor()\n        cursor.execute(\"SELECT * FROM process_info ORDER BY created_at DESC\")\n        rows = cursor.fetchall()\n\n        processes: list[ProcessInfo] = [\n            ProcessInfo(\n                name=row[1],\n                executable=Path(row[2]),\n                args=json.loads(row[3]) if row[3] else [],\n                env=json.loads(row[4]) if row[4] else {},\n                cwd=row[5],\n                pid=row[6],\n                output=Path(row[7]) if row[7] else None,\n                start_time=row[8],\n                created_at=row[9],\n            )\n            for row in rows\n        ]\n        # Check if processes are still running\n        # This is done by checking the pid of the process.\n        # It is using `_are_processes_running` method which\n        # checks for processes in batch, mostly because of the fallback\n        # on systems without `psutil` module. See `_are_processes_running`\n        # documentation for more details.\n        # Build list of (pid, executable_name, start_time) triplets so the\n        # check can verify PID + image and, when possible, process start time\n        # (stronger protection against PID reuse).\n        pid_triplets: list[ProcessIdTriplet] = []\n        processes_with_pid = []\n        for proc in processes:\n            if proc.pid is None:\n                continue\n            exe = proc.executable.as_posix()\n            pid_triplets.append(\n                ProcessIdTriplet(proc.pid, exe, proc.start_time))\n            processes_with_pid.append(proc)\n\n        if pid_triplets:\n            running_status = self._are_processes_running(pid_triplets)\n            for proc, (_, is_running) in zip(  # noqa: B905\n                    processes_with_pid, running_status):\n                proc.active = is_running\n\n        return processes\n\n    def delete_process_info(self, process_hash: str) -&gt; bool:\n        \"\"\"Delete process information by hash.\n\n        This also deletes the output file if it exists.\n\n        Args:\n            process_hash (str): Hash of the process to delete.\n\n        Returns:\n            bool: True if deleted, False if not found.\n        \"\"\"\n        process = self.get_process_info(process_hash)\n        if process is None:\n            return False\n        if process.output and Path(process.output).exists():\n            # File might not exist anymore, so we use contextlib.suppress\n            with contextlib.suppress(OSError):\n                os.remove(process.output)\n\n        cnx = self._get_process_storage_connection()\n        cursor = cnx.cursor()\n        cursor.execute(\n            \"DELETE FROM process_info WHERE hash = ?\",\n            (process_hash,))\n        cnx.commit()\n        return cursor.rowcount &gt; 0\n\n    def delete_inactive_processes(self) -&gt; int:\n        \"\"\"Delete all inactive process information.\n\n        This also deletes the output files of the inactive processes.\n\n        Returns:\n            int: Number of deleted processes.\n        \"\"\"\n        cnx = self._get_process_storage_connection()\n\n        # Get all processes and check which ones are inactive\n        all_processes = self.get_all_process_info()\n\n        files_to_delete = [\n            process.output\n            for process in all_processes\n            if (\n                    not process.active\n                    and (process.output and Path(process.output).exists())\n            )\n        ]\n\n        inactive_hashes = []\n\n        for process in all_processes:\n            if not process.active:\n                process_hash = self.get_process_info_hash(process)\n                inactive_hashes.append(process_hash)\n\n        if not inactive_hashes:\n            return 0\n\n        cursor = cnx.cursor()\n        placeholders = \",\".join(\"?\" * len(inactive_hashes))\n        cursor.execute(\n            (\"DELETE FROM process_info WHERE \"  # noqa: S608\n            f\"hash IN ({placeholders})\"),\n            inactive_hashes\n        )\n        cnx.commit()\n\n        for file_path in files_to_delete:\n            # File might not exist anymore, so we use contextlib.suppress\n            with contextlib.suppress(OSError):\n                os.remove(file_path)\n\n        return cursor.rowcount\n\n    @staticmethod\n    def _is_process_running(\n            pid: int,\n            executable: str,\n            start_time: Optional[float] = None) -&gt; bool:\n        \"\"\"Check if a process is running using psutil.\n\n        Args:\n            pid (int): Process ID to check.\n            executable (str): Executable name to verify.\n            start_time (Optional[float]): Start time to verify.\n\n        Returns:\n            bool: True if the process is running, False otherwise.\n\n        \"\"\"\n        import psutil\n\n        try:\n            proc = psutil.Process(pid)\n        except (psutil.NoSuchProcess, psutil.ZombieProcess):\n            return False\n\n        # If start_time provided, verify it matches process creation time\n        if start_time is not None:\n            try:\n                proc_ct = proc.create_time()\n                # allow small tolerance for float differences\n                if abs(proc_ct - float(start_time)) &gt; 1.0:\n                    return False\n            except Exception:  # noqa: BLE001\n                # cannot verify start time -&gt; conservative False\n                return False\n\n        if not executable:\n            # No executable provided, process exists\n            # (and start_time matched if provided)\n            return True\n\n        # Try to get executable path/name and command line first\n        candidates = set()\n        with contextlib.suppress(Exception):\n            exe_path = proc.exe() if hasattr(proc, \"exe\") else None\n            if exe_path:\n                candidates.add(Path(exe_path).as_posix())\n\n            name = proc.name()\n            if name:\n                candidates.add(name)\n\n            cmd = proc.cmdline()\n            if cmd:\n                first = cmd[0]\n                candidates.add(first)\n        if platform.system().lower() == \"windows\":\n            # On Windows be more relaxed and check image name only\n            candidates = {c.lower() for c in candidates if c}\n            return Path(executable).name.lower() in candidates\n\n        return Path(executable).as_posix() in candidates\n\n    @staticmethod\n    def _are_processes_running(\n            pid_triplets: list[ProcessIdTriplet]) -&gt; list[tuple[int, bool]]:\n        \"\"\"Check if the processes are still running.\n\n        This checks for presence of `psutil` module and uses it if available.\n\n        Args:\n            pid_triplets (list[ProcessIdTriplet]): Processes ID to check.\n\n        Returns:\n            list[tuple[int, bool]]: List of tuples with process ID and\n                boolean indicating if the process is running.\n\n        \"\"\"\n        if not pid_triplets:\n            result: list[tuple[int, bool]] = []\n            return result\n\n        return ProcessManager._check_processes_running(\n                pid_triplets)\n\n    @staticmethod\n    def _check_processes_running(\n            pid_triplets: list[ProcessIdTriplet]) -&gt; list[tuple[int, bool]]:\n        \"\"\"Check if processes are running using psutil.\n\n        Args:\n            pid_triplets (list[ProcessIdTriplet]): List of triplets\n\n        Returns:\n            list[tuple[int, bool]]: List of tuples with process ID and\n                boolean indicating if the process is running.\n\n        \"\"\"\n        import psutil\n\n        result: list[tuple[int, bool]] = []\n\n        for pid, exe, start_time in pid_triplets:\n            try:\n                is_running = ProcessManager._is_process_running(\n                    pid, exe, start_time\n                )\n            except Exception:  # noqa: BLE001\n                # if something goes wrong, fall back to pid_exists\n                try:\n                    is_running = psutil.pid_exists(pid)\n                except Exception:   # noqa: BLE001\n                    is_running = False\n            result.append((pid, is_running))\n        return result\n\n    @staticmethod\n    def get_executable_path_by_pid(pid: int) -&gt; Optional[Path]:\n        \"\"\"Get the executable path of a process by its PID using psutil.\n\n        Args:\n            pid (int): Process ID.\n\n        Returns:\n            Optional[Path]: The executable path of the process, or None if it\n                cannot be determined.\n\n        \"\"\"\n        import psutil\n\n        exe_path = None\n        if pid:\n            try:\n                exe_path_str = psutil.Process(pid).exe()\n                if exe_path_str:\n                    exe_path = Path(exe_path_str)\n            except (\n                    psutil.NoSuchProcess,\n                    psutil.ZombieProcess,\n                    psutil.AccessDenied):\n                exe_path = None\n        return exe_path\n\n    @staticmethod\n    def get_process_start_time(\n            process: subprocess.Popen) -&gt; Optional[float]:\n        \"\"\"Get the start time of a process using psutil.\n\n        Returns:\n            Optional[float]: The start time of the process in seconds since\n                the epoch, or None if it cannot be determined.\n\n        \"\"\"\n        import psutil\n\n        start_time = None\n        if process.pid:\n            try:\n                start_time = psutil.Process(process.pid).create_time()\n            except (\n                    psutil.NoSuchProcess,\n                    psutil.ZombieProcess,\n                    psutil.AccessDenied):\n                start_time = None\n        return start_time\n\n    @staticmethod\n    def get_process_start_time_by_pid(pid: int) -&gt; Optional[float]:\n        \"\"\"Get the start time of a process by PID using psutil.\n\n        Args:\n            pid (int): Process ID.\n\n        Returns:\n            Optional[float]: The start time of the process in seconds since\n                the epoch, or None if it cannot be determined.\n\n        \"\"\"\n        import psutil\n\n        start_time = None\n        if pid:\n            try:\n                start_time = psutil.Process(pid).create_time()\n            except (\n                    psutil.NoSuchProcess,\n                    psutil.ZombieProcess,\n                    psutil.AccessDenied):\n                start_time = None\n        return start_time\n\n    @staticmethod\n    def get_descendant_processes_by_pid(pid: int) -&gt; list[ProcessInfo]:\n        \"\"\"Get descendant processes of a given process id.\n\n        Args:\n            pid (int): Process ID of the parent process.\n\n        Returns:\n            list[ProcessInfo]: List of descendant process information.\n\n        \"\"\"\n        import psutil\n\n        descendants: list[ProcessInfo] = []\n        with contextlib.suppress(\n                psutil.NoSuchProcess,\n                psutil.ZombieProcess,\n                psutil.AccessDenied):\n            parent_proc = psutil.Process(pid)\n            child_procs = parent_proc.children(recursive=True)\n            for child in child_procs:\n                #  environment isn't used on child processes for now\n                proc_info = ProcessInfo(\n                    name=child.name(),\n                    executable=Path(child.exe()),\n                    args=child.cmdline(),\n                    env={},  # skipped for performance reasons\n                    cwd=child.cwd(),\n                    pid=child.pid,\n                    start_time=child.create_time(),\n                )\n                # If psutil returned the process, it's currently running\n                proc_info.active = True\n                descendants.append(proc_info)\n        return descendants\n\n    def get_descendant_processes(\n            self, process_info: ProcessInfo) -&gt; list[ProcessInfo]:\n        \"\"\"Get descendant processes of a given process information.\n\n        Args:\n            process_info (ProcessInfo): Parent process information.\n\n        Returns:\n            list[ProcessInfo]: List of descendant process information.\n\n        \"\"\"\n        if process_info.pid is None:\n            return []\n        return self.get_descendant_processes_by_pid(process_info.pid)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the ProcessManager.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the ProcessManager.\"\"\"\n    self.log = logging.getLogger(f\"{__name__}.ProcessManager\")\n    # Use thread-local storage for SQLite connections to avoid\n    # sharing connections between threads (fixes Linux SQLite issues)\n    self._thread_local = threading.local()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.delete_inactive_processes","title":"<code>delete_inactive_processes()</code>","text":"<p>Delete all inactive process information.</p> <p>This also deletes the output files of the inactive processes.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of deleted processes.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def delete_inactive_processes(self) -&gt; int:\n    \"\"\"Delete all inactive process information.\n\n    This also deletes the output files of the inactive processes.\n\n    Returns:\n        int: Number of deleted processes.\n    \"\"\"\n    cnx = self._get_process_storage_connection()\n\n    # Get all processes and check which ones are inactive\n    all_processes = self.get_all_process_info()\n\n    files_to_delete = [\n        process.output\n        for process in all_processes\n        if (\n                not process.active\n                and (process.output and Path(process.output).exists())\n        )\n    ]\n\n    inactive_hashes = []\n\n    for process in all_processes:\n        if not process.active:\n            process_hash = self.get_process_info_hash(process)\n            inactive_hashes.append(process_hash)\n\n    if not inactive_hashes:\n        return 0\n\n    cursor = cnx.cursor()\n    placeholders = \",\".join(\"?\" * len(inactive_hashes))\n    cursor.execute(\n        (\"DELETE FROM process_info WHERE \"  # noqa: S608\n        f\"hash IN ({placeholders})\"),\n        inactive_hashes\n    )\n    cnx.commit()\n\n    for file_path in files_to_delete:\n        # File might not exist anymore, so we use contextlib.suppress\n        with contextlib.suppress(OSError):\n            os.remove(file_path)\n\n    return cursor.rowcount\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.delete_process_info","title":"<code>delete_process_info(process_hash)</code>","text":"<p>Delete process information by hash.</p> <p>This also deletes the output file if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>process_hash</code> <code>str</code> <p>Hash of the process to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deleted, False if not found.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def delete_process_info(self, process_hash: str) -&gt; bool:\n    \"\"\"Delete process information by hash.\n\n    This also deletes the output file if it exists.\n\n    Args:\n        process_hash (str): Hash of the process to delete.\n\n    Returns:\n        bool: True if deleted, False if not found.\n    \"\"\"\n    process = self.get_process_info(process_hash)\n    if process is None:\n        return False\n    if process.output and Path(process.output).exists():\n        # File might not exist anymore, so we use contextlib.suppress\n        with contextlib.suppress(OSError):\n            os.remove(process.output)\n\n    cnx = self._get_process_storage_connection()\n    cursor = cnx.cursor()\n    cursor.execute(\n        \"DELETE FROM process_info WHERE hash = ?\",\n        (process_hash,))\n    cnx.commit()\n    return cursor.rowcount &gt; 0\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_all_process_info","title":"<code>get_all_process_info()</code>","text":"<p>Get all process information from the database.</p> <p>Returns:</p> Type Description <code>list[ProcessInfo]</code> <p>list[ProcessInfo]: List of all process information.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def get_all_process_info(self) -&gt; list[ProcessInfo]:\n    \"\"\"Get all process information from the database.\n\n    Returns:\n        list[ProcessInfo]: List of all process information.\n    \"\"\"\n    cnx = self._get_process_storage_connection()\n    cursor = cnx.cursor()\n    cursor.execute(\"SELECT * FROM process_info ORDER BY created_at DESC\")\n    rows = cursor.fetchall()\n\n    processes: list[ProcessInfo] = [\n        ProcessInfo(\n            name=row[1],\n            executable=Path(row[2]),\n            args=json.loads(row[3]) if row[3] else [],\n            env=json.loads(row[4]) if row[4] else {},\n            cwd=row[5],\n            pid=row[6],\n            output=Path(row[7]) if row[7] else None,\n            start_time=row[8],\n            created_at=row[9],\n        )\n        for row in rows\n    ]\n    # Check if processes are still running\n    # This is done by checking the pid of the process.\n    # It is using `_are_processes_running` method which\n    # checks for processes in batch, mostly because of the fallback\n    # on systems without `psutil` module. See `_are_processes_running`\n    # documentation for more details.\n    # Build list of (pid, executable_name, start_time) triplets so the\n    # check can verify PID + image and, when possible, process start time\n    # (stronger protection against PID reuse).\n    pid_triplets: list[ProcessIdTriplet] = []\n    processes_with_pid = []\n    for proc in processes:\n        if proc.pid is None:\n            continue\n        exe = proc.executable.as_posix()\n        pid_triplets.append(\n            ProcessIdTriplet(proc.pid, exe, proc.start_time))\n        processes_with_pid.append(proc)\n\n    if pid_triplets:\n        running_status = self._are_processes_running(pid_triplets)\n        for proc, (_, is_running) in zip(  # noqa: B905\n                processes_with_pid, running_status):\n            proc.active = is_running\n\n    return processes\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_current_process_info","title":"<code>get_current_process_info()</code>","text":"<p>Get information for the current process.</p> <p>Returns:</p> Type Description <code>Optional[ProcessInfo]</code> <p>Optional[ProcessInfo]: Process information or None if not found.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def get_current_process_info(self) -&gt; Optional[ProcessInfo]:\n    \"\"\"Get information for the current process.\n\n    Returns:\n        Optional[ProcessInfo]: Process information or None if not found.\n    \"\"\"\n    return self.get_process_info_by_pid(os.getpid())\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_descendant_processes","title":"<code>get_descendant_processes(process_info)</code>","text":"<p>Get descendant processes of a given process information.</p> <p>Parameters:</p> Name Type Description Default <code>process_info</code> <code>ProcessInfo</code> <p>Parent process information.</p> required <p>Returns:</p> Type Description <code>list[ProcessInfo]</code> <p>list[ProcessInfo]: List of descendant process information.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def get_descendant_processes(\n        self, process_info: ProcessInfo) -&gt; list[ProcessInfo]:\n    \"\"\"Get descendant processes of a given process information.\n\n    Args:\n        process_info (ProcessInfo): Parent process information.\n\n    Returns:\n        list[ProcessInfo]: List of descendant process information.\n\n    \"\"\"\n    if process_info.pid is None:\n        return []\n    return self.get_descendant_processes_by_pid(process_info.pid)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_descendant_processes_by_pid","title":"<code>get_descendant_processes_by_pid(pid)</code>  <code>staticmethod</code>","text":"<p>Get descendant processes of a given process id.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>Process ID of the parent process.</p> required <p>Returns:</p> Type Description <code>list[ProcessInfo]</code> <p>list[ProcessInfo]: List of descendant process information.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_descendant_processes_by_pid(pid: int) -&gt; list[ProcessInfo]:\n    \"\"\"Get descendant processes of a given process id.\n\n    Args:\n        pid (int): Process ID of the parent process.\n\n    Returns:\n        list[ProcessInfo]: List of descendant process information.\n\n    \"\"\"\n    import psutil\n\n    descendants: list[ProcessInfo] = []\n    with contextlib.suppress(\n            psutil.NoSuchProcess,\n            psutil.ZombieProcess,\n            psutil.AccessDenied):\n        parent_proc = psutil.Process(pid)\n        child_procs = parent_proc.children(recursive=True)\n        for child in child_procs:\n            #  environment isn't used on child processes for now\n            proc_info = ProcessInfo(\n                name=child.name(),\n                executable=Path(child.exe()),\n                args=child.cmdline(),\n                env={},  # skipped for performance reasons\n                cwd=child.cwd(),\n                pid=child.pid,\n                start_time=child.create_time(),\n            )\n            # If psutil returned the process, it's currently running\n            proc_info.active = True\n            descendants.append(proc_info)\n    return descendants\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_executable_path_by_pid","title":"<code>get_executable_path_by_pid(pid)</code>  <code>staticmethod</code>","text":"<p>Get the executable path of a process by its PID using psutil.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>Process ID.</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Optional[Path]: The executable path of the process, or None if it cannot be determined.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_executable_path_by_pid(pid: int) -&gt; Optional[Path]:\n    \"\"\"Get the executable path of a process by its PID using psutil.\n\n    Args:\n        pid (int): Process ID.\n\n    Returns:\n        Optional[Path]: The executable path of the process, or None if it\n            cannot be determined.\n\n    \"\"\"\n    import psutil\n\n    exe_path = None\n    if pid:\n        try:\n            exe_path_str = psutil.Process(pid).exe()\n            if exe_path_str:\n                exe_path = Path(exe_path_str)\n        except (\n                psutil.NoSuchProcess,\n                psutil.ZombieProcess,\n                psutil.AccessDenied):\n            exe_path = None\n    return exe_path\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_info","title":"<code>get_process_info(process_hash)</code>","text":"<p>Get process information by hash.</p> <p>Parameters:</p> Name Type Description Default <code>process_hash</code> <code>str</code> <p>Hash of the process.</p> required <p>Returns:</p> Type Description <code>Optional[ProcessInfo]</code> <p>Optional[ProcessInfo]: Process information or None if not found.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def get_process_info(self, process_hash: str) -&gt; Optional[ProcessInfo]:\n    \"\"\"Get process information by hash.\n\n    Args:\n        process_hash (str): Hash of the process.\n\n    Returns:\n        Optional[ProcessInfo]: Process information or None if not found.\n    \"\"\"\n    cnx = self._get_process_storage_connection()\n    cursor = cnx.cursor()\n    cursor.execute(\n        \"SELECT * FROM process_info WHERE hash = ?\",\n        (process_hash,)\n    )\n    row = cursor.fetchone()\n    if row is None:\n        return None\n\n    return ProcessInfo(\n        name=row[1],\n        executable=Path(row[2]),\n        args=json.loads(row[3]),\n        env=json.loads(row[4]),\n        cwd=row[5],\n        hash=process_hash,\n        pid=row[6],\n        output=Path(row[7]) if row[7] else None,\n        start_time=row[8],\n        created_at=row[9],\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_info_by_name","title":"<code>get_process_info_by_name(name)</code>","text":"<p>Get process information by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the process.</p> required <p>Returns:</p> Type Description <code>Optional[ProcessInfo]</code> <p>Optional[ProcessInfo]: Process information or None if not found.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def get_process_info_by_name(\n    self, name: str) -&gt; Optional[ProcessInfo]:\n    \"\"\"Get process information by name.\n\n    Args:\n        name (str): Name of the process.\n\n    Returns:\n        Optional[ProcessInfo]: Process information or None if not found.\n    \"\"\"\n    cnx = self._get_process_storage_connection()\n    cursor = cnx.cursor()\n    query = \"SELECT * FROM process_info WHERE name = ?\"\n    params = [name]\n\n    cursor.execute(query, params)\n    row = cursor.fetchone()\n    if row is None:\n        return None\n\n    return ProcessInfo(\n        name=row[1],\n        executable=Path(row[2]),\n        args=json.loads(row[3]),\n        env=json.loads(row[4]),\n        cwd=row[5],\n        pid=row[6],\n        output=Path(row[7]) if row[7] else None,\n        start_time=row[8],\n        created_at=row[9],\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_info_by_pid","title":"<code>get_process_info_by_pid(pid)</code>","text":"<p>Get process information by process id.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>ID of the process.</p> required <p>Returns:</p> Type Description <code>Optional[ProcessInfo]</code> <p>Optional[ProcessInfo]: Process information or None if not found.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>def get_process_info_by_pid(self, pid: int) -&gt; Optional[ProcessInfo]:\n    \"\"\"Get process information by process id.\n\n    Args:\n        pid (int): ID of the process.\n\n    Returns:\n        Optional[ProcessInfo]: Process information or None if not found.\n    \"\"\"\n    cnx = self._get_process_storage_connection()\n    cursor = cnx.cursor()\n    query = \"SELECT * FROM process_info WHERE pid = ?\"\n    params = [pid]\n\n    cursor.execute(query, params)\n    row = cursor.fetchone()\n    if row is None:\n        return None\n\n    return ProcessInfo(\n        name=row[1],\n        executable=Path(row[2]),\n        args=json.loads(row[3]),\n        env=json.loads(row[4]),\n        cwd=row[5],\n        pid=row[6],\n        output=Path(row[7]) if row[7] else None,\n        start_time=row[8],\n        created_at=row[9],\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_info_hash","title":"<code>get_process_info_hash(process_info)</code>  <code>staticmethod</code>","text":"<p>Get hash of the process information.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hash of the process information.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_process_info_hash(process_info: ProcessInfo) -&gt; str:\n    \"\"\"Get hash of the process information.\n\n    Returns:\n        str: Hash of the process information.\n    \"\"\"\n    return ProcessManager.get_process_info_hash_by_values(\n        process_info.executable,\n        process_info.name,\n        process_info.pid,\n        process_info.start_time,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_info_hash_by_values","title":"<code>get_process_info_hash_by_values(executable, name, pid=None, start_time=None)</code>  <code>staticmethod</code>","text":"<p>Get hash of the process information by values.</p> <p>Parameters:</p> Name Type Description Default <code>executable</code> <code>Path</code> <p>Path to the executable.</p> required <code>name</code> <code>str</code> <p>Name of the process.</p> required <code>pid</code> <code>Optional[int]</code> <p>Process ID of the launched process.</p> <code>None</code> <code>start_time</code> <code>Optional[float]</code> <p>Start time of the process.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hash of the process information.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_process_info_hash_by_values(\n    executable: Path,\n    name: str,\n    pid: Optional[int] = None,\n    start_time: Optional[float] = None,\n) -&gt; str:\n    \"\"\"Get hash of the process information by values.\n\n    Args:\n        executable (Path): Path to the executable.\n        name (str): Name of the process.\n        pid (Optional[int]): Process ID of the launched process.\n        start_time (Optional[float]): Start time of the process.\n\n    Returns:\n        str: Hash of the process information.\n\n    \"\"\"\n    start = (\n        f\"{start_time}\"\n        if start_time is not None\n        else \"\"\n    )\n    key = f\"{name}{pid}{executable}{start}\"\n    return sha256(key.encode()).hexdigest()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_info_storage_location","title":"<code>get_process_info_storage_location()</code>  <code>staticmethod</code>","text":"<p>Get the path to process info storage.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the process handlers storage.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_process_info_storage_location() -&gt; Path:\n    \"\"\"Get the path to process info storage.\n\n    Returns:\n        Path: Path to the process handlers storage.\n\n    \"\"\"\n    return Path(get_launcher_local_dir()) / \"process_handlers.db\"\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_start_time","title":"<code>get_process_start_time(process)</code>  <code>staticmethod</code>","text":"<p>Get the start time of a process using psutil.</p> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The start time of the process in seconds since the epoch, or None if it cannot be determined.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_process_start_time(\n        process: subprocess.Popen) -&gt; Optional[float]:\n    \"\"\"Get the start time of a process using psutil.\n\n    Returns:\n        Optional[float]: The start time of the process in seconds since\n            the epoch, or None if it cannot be determined.\n\n    \"\"\"\n    import psutil\n\n    start_time = None\n    if process.pid:\n        try:\n            start_time = psutil.Process(process.pid).create_time()\n        except (\n                psutil.NoSuchProcess,\n                psutil.ZombieProcess,\n                psutil.AccessDenied):\n            start_time = None\n    return start_time\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.get_process_start_time_by_pid","title":"<code>get_process_start_time_by_pid(pid)</code>  <code>staticmethod</code>","text":"<p>Get the start time of a process by PID using psutil.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>Process ID.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The start time of the process in seconds since the epoch, or None if it cannot be determined.</p> Source code in <code>client/ayon_applications/process.py</code> <pre><code>@staticmethod\ndef get_process_start_time_by_pid(pid: int) -&gt; Optional[float]:\n    \"\"\"Get the start time of a process by PID using psutil.\n\n    Args:\n        pid (int): Process ID.\n\n    Returns:\n        Optional[float]: The start time of the process in seconds since\n            the epoch, or None if it cannot be determined.\n\n    \"\"\"\n    import psutil\n\n    start_time = None\n    if pid:\n        try:\n            start_time = psutil.Process(pid).create_time()\n        except (\n                psutil.NoSuchProcess,\n                psutil.ZombieProcess,\n                psutil.AccessDenied):\n            start_time = None\n    return start_time\n</code></pre>"},{"location":"autoapi/client/ayon_applications/process.html#client.ayon_applications.process.ProcessManager.store_process_info","title":"<code>store_process_info(process_info)</code>","text":"<p>Store process information.</p> <p>Parameters:</p> Name Type Description Default <code>process_info</code> <code>ProcessInfo</code> <p>Process handler to store.</p> required Source code in <code>client/ayon_applications/process.py</code> <pre><code>def store_process_info(self, process_info: ProcessInfo) -&gt; None:\n    \"\"\"Store process information.\n\n    Args:\n        process_info (ProcessInfo): Process handler to store.\n\n    \"\"\"\n    # refresh hash in case some values changed\n    process_info.hash = ProcessManager.get_process_info_hash(process_info)\n    if process_info.pid is None:\n        self.log.warning((\n            \"Cannot store process info for process without PID. \"\n            \"Process name: %s\"\n        ), process_info.name)\n        return\n\n    cnx = self._get_process_storage_connection()\n    cursor = cnx.cursor()\n    cursor.execute(\n        \"INSERT OR REPLACE INTO process_info \"\n        \"(hash, name, executable, args, env, cwd, \"\n        \"pid, output_file, start_time) \"\n        \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n        (\n            process_info.hash,\n            process_info.name,\n            process_info.executable.as_posix(),\n            json.dumps(process_info.args),\n            json.dumps(process_info.env),\n            process_info.cwd,\n            process_info.pid,\n            (\n                process_info.output.as_posix()\n                if process_info.output else None\n            ),\n            process_info.start_time,\n        )\n    )\n    cnx.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.EnvironmentPrepData","title":"<code>EnvironmentPrepData</code>","text":"<p>               Bases: <code>dict</code></p> <p>Helper dictionary for storin temp data during environment prep.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data must contain required keys.</p> required Source code in <code>client/ayon_applications/utils.py</code> <pre><code>class EnvironmentPrepData(dict):\n    \"\"\"Helper dictionary for storin temp data during environment prep.\n\n    Args:\n        data (dict): Data must contain required keys.\n    \"\"\"\n    required_keys = (\n        \"project_entity\",\n        \"folder_entity\",\n        \"task_entity\",\n        \"app\",\n        \"anatomy\",\n    )\n\n    def __init__(self, data: dict[str, Any]):\n        for key in self.required_keys:\n            if key not in data:\n                raise MissingRequiredKey(key)\n\n        if not data.get(\"log\"):\n            data[\"log\"] = Logger.get_logger(\"EnvironmentPrepData\")\n\n        if data.get(\"env\") is None:\n            data[\"env\"] = os.environ.copy()\n\n        project_name = data[\"project_entity\"][\"name\"]\n        if \"project_settings\" not in data:\n            data[\"project_settings\"] = get_project_settings(project_name)\n\n        super().__init__(data)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.apply_project_environments_value","title":"<code>apply_project_environments_value(project_name, env, project_settings=None, env_group=None)</code>","text":"<p>Apply project specific environments on passed environments.</p> <p>The environments are applied on passed <code>env</code> argument value so it is not required to apply changes back.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project for which environments should be received.</p> required <code>env</code> <code>dict</code> <p>Environment values on which project specific environments will be applied.</p> required <code>project_settings</code> <code>dict</code> <p>Project settings for passed project name. Optional if project settings are already prepared.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str]</code> <p>Passed env values with applied project environments.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If project settings do not contain keys for project specific environments.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def apply_project_environments_value(\n    project_name: str,\n    env: dict[str, str],\n    project_settings: Optional[dict[str, Any]] = None,\n    env_group: Optional[str] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Apply project specific environments on passed environments.\n\n    The environments are applied on passed `env` argument value so it is not\n    required to apply changes back.\n\n    Args:\n        project_name (str): Name of project for which environments should be\n            received.\n        env (dict): Environment values on which project specific environments\n            will be applied.\n        project_settings (dict): Project settings for passed project name.\n            Optional if project settings are already prepared.\n\n    Returns:\n        dict: Passed env values with applied project environments.\n\n    Raises:\n        KeyError: If project settings do not contain keys for project specific\n            environments.\n\n    \"\"\"\n    if project_settings is None:\n        project_settings = get_project_settings(project_name)\n\n    env_value = project_settings[\"core\"][\"project_environments\"]\n    if env_value:\n        env_value = json.loads(env_value)\n        parsed_value = parse_environments(env_value, env_group)\n        env.update(compute_env_variables_structure(\n            merge_env_variables(parsed_value, env)\n        ))\n    return env\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_app_environments_for_context","title":"<code>get_app_environments_for_context(project_name, folder_path, task_name, app_name, env_group=None, launch_type=None, env=None, addons_manager=None)</code>","text":"<p>Prepare environment variables by context. Args:     project_name (str): Name of project.     folder_path (str): Folder path.     task_name (str): Name of task.     app_name (str): Name of application that is launched and can be found         by ApplicationManager.     env_group (Optional[str]): Name of environment group. If not passed         default group is used.     launch_type (Optional[str]): Type for which prelaunch hooks are         executed.     env (Optional[dict[str, str]]): Initial environment variables.         <code>os.environ</code> is used when not passed.     addons_manager (Optional[AddonsManager]): Initialized modules         manager.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str]</code> <p>Environments for passed context and application.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_app_environments_for_context(\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    app_name: str,\n    env_group: Optional[str] = None,\n    launch_type: Optional[str] = None,\n    env: Optional[dict[str, str]] = None,\n    addons_manager: Optional[AddonsManager] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Prepare environment variables by context.\n    Args:\n        project_name (str): Name of project.\n        folder_path (str): Folder path.\n        task_name (str): Name of task.\n        app_name (str): Name of application that is launched and can be found\n            by ApplicationManager.\n        env_group (Optional[str]): Name of environment group. If not passed\n            default group is used.\n        launch_type (Optional[str]): Type for which prelaunch hooks are\n            executed.\n        env (Optional[dict[str, str]]): Initial environment variables.\n            `os.environ` is used when not passed.\n        addons_manager (Optional[AddonsManager]): Initialized modules\n            manager.\n\n    Returns:\n        dict: Environments for passed context and application.\n\n    \"\"\"\n    # Prepare app object which can be obtained only from ApplicationManager\n    app_manager = ApplicationManager()\n    context = app_manager.create_launch_context(\n        app_name,\n        project_name=project_name,\n        folder_path=folder_path,\n        task_name=task_name,\n        env_group=env_group,\n        launch_type=launch_type,\n        env=env,\n        addons_manager=addons_manager,\n        modules_manager=addons_manager,\n    )\n    context.run_prelaunch_hooks()\n    return context.env\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_app_icon_path","title":"<code>get_app_icon_path(icon_filename)</code>","text":"<p>Get icon path.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon filename.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Union[str, None]: Icon path or None if not found.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_app_icon_path(icon_filename: str) -&gt; Optional[str]:\n    \"\"\"Get icon path.\n\n    Args:\n        icon_filename (str): Icon filename.\n\n    Returns:\n        Union[str, None]: Icon path or None if not found.\n\n    \"\"\"\n    if not icon_filename:\n        return None\n    icon_name = os.path.basename(icon_filename)\n    path = os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\", icon_name)\n    if os.path.exists(path):\n        return path\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_applications_for_context","title":"<code>get_applications_for_context(project_name, folder_entity, task_entity, project_settings=None, project_entity=None)</code>","text":"<p>Get applications for context based on project settings.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project.</p> required <code>folder_entity</code> <code>dict</code> <p>Folder entity.</p> required <code>task_entity</code> <code>dict</code> <p>Task entity.</p> required <code>project_settings</code> <code>Optional[dict]</code> <p>Project settings.</p> <code>None</code> <code>project_entity</code> <code>Optional[dict]</code> <p>Project entity.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of applications that can be used in given context.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_applications_for_context(\n    project_name: str,\n    folder_entity: dict[str, Any],\n    task_entity: dict[str, Any],\n    project_settings: Optional[dict[str, Any]] = None,\n    project_entity: Optional[dict[str, Any]] = None,\n) -&gt; list[str]:\n    \"\"\"Get applications for context based on project settings.\n\n    Args:\n        project_name (str): Name of project.\n        folder_entity (dict): Folder entity.\n        task_entity (dict): Task entity.\n        project_settings (Optional[dict]): Project settings.\n        project_entity (Optional[dict]): Project entity.\n\n    Returns:\n        list[str]: List of applications that can be used in given context.\n\n    \"\"\"\n    if project_settings is None:\n        project_settings = get_project_settings(project_name)\n    apps_settings = project_settings[\"applications\"]\n\n    # Use attributes to get available applications\n    # - this is older source of the information, will be deprecated in future\n    project_applications = apps_settings[\"project_applications\"]\n    if not project_applications[\"enabled\"]:\n        if project_entity is None:\n            project_entity = ayon_api.get_project(project_name)\n        apps = project_entity[\"attrib\"].get(\"applications\")\n        return apps or []\n\n    task_type = None\n    if task_entity:\n        task_type = task_entity[\"taskType\"]\n\n    profile = filter_profiles(\n        project_applications[\"profiles\"],\n        {\"task_types\": task_type}\n    )\n    if profile:\n        if profile[\"allow_type\"] == \"applications\":\n            return profile[\"applications\"]\n        return _get_app_full_names_from_settings(apps_settings)\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_tools_for_context","title":"<code>get_tools_for_context(project_name, folder_entity, task_entity, project_settings=None)</code>","text":"<p>Get tools for context based on project settings.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project.</p> required <code>folder_entity</code> <code>dict</code> <p>Folder entity.</p> required <code>task_entity</code> <code>dict</code> <p>Task entity.</p> required <code>project_settings</code> <code>Optional[dict]</code> <p>Project settings.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of applications that can be used in given context.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_tools_for_context(\n    project_name: str,\n    folder_entity: dict[str, Any],\n    task_entity: dict[str, Any],\n    project_settings: Optional[dict[str, Any]] = None,\n) -&gt; list[str]:\n    \"\"\"Get tools for context based on project settings.\n\n    Args:\n        project_name (str): Name of project.\n        folder_entity (dict): Folder entity.\n        task_entity (dict): Task entity.\n        project_settings (Optional[dict]): Project settings.\n\n    Returns:\n        list[str]: List of applications that can be used in given context.\n\n    \"\"\"\n    if project_settings is None:\n        project_settings = get_project_settings(project_name)\n    apps_settings = project_settings[\"applications\"]\n\n    project_tools = apps_settings[\"project_tools\"]\n    # Use attributes to get available tools\n    # - this is older source of the information, will be deprecated in future\n    if not project_tools[\"enabled\"]:\n        tools = None\n        if task_entity:\n            tools = task_entity[\"attrib\"].get(\"tools\")\n\n        if tools is None and folder_entity:\n            tools = folder_entity[\"attrib\"].get(\"tools\")\n\n        return tools or []\n\n    folder_path = task_type = task_name = None\n    if folder_entity:\n        folder_path = folder_entity[\"path\"]\n    if task_entity:\n        task_type = task_entity[\"taskType\"]\n        task_name = task_entity[\"name\"]\n\n    profile = filter_profiles(\n        project_tools[\"profiles\"],\n        {\n            \"folder_paths\": folder_path,\n            \"task_types\": task_type,\n            \"task_names\": task_name,\n        },\n        keys_order=[\"folder_paths\", \"task_names\", \"task_types\"]\n    )\n    if profile:\n        return profile[\"tools\"]\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.parse_environments","title":"<code>parse_environments(env_data, env_group=None, platform_name=None)</code>","text":"<p>Parse environment values from settings byt group and platform.</p> <p>Data may contain up to 2 hierarchical levels of dictionaries. At the end of the last level must be string or list. List is joined using platform specific joiner (';' for windows and ':' for linux and mac).</p> <p>Hierarchical levels can contain keys for subgroups and platform name. Platform specific values must be always last level of dictionary. Platform names are \"windows\" (MS Windows), \"linux\" (any linux distribution) and \"darwin\" (any MacOS distribution).</p> <p>Subgroups are helpers added mainly for standard and on farm usage. Farm may require different environments for e.g. licence related values or plugins. Default subgroup is \"standard\".</p> <p>Examples:</p> <pre><code>{\n    # Unchanged value\n    \"ENV_KEY1\": \"value\",\n    # Empty values are kept (unset environment variable)\n    \"ENV_KEY2\": \"\",\n\n    # Join list values with ':' or ';'\n    \"ENV_KEY3\": [\"value1\", \"value2\"],\n\n    # Environment groups\n    \"ENV_KEY4\": {\n        \"standard\": \"DEMO_SERVER_URL\",\n        \"farm\": \"LICENCE_SERVER_URL\"\n    },\n\n    # Platform specific (and only for windows and mac)\n    \"ENV_KEY5\": {\n        \"windows\": \"windows value\",\n        \"darwin\": [\"value 1\", \"value 2\"]\n    },\n\n    # Environment groups and platform combination\n    \"ENV_KEY6\": {\n        \"farm\": \"FARM_VALUE\",\n        \"standard\": {\n            \"windows\": [\"value1\", \"value2\"],\n            \"linux\": \"value1\",\n            \"darwin\": \"\"\n        }\n    }\n}\n</code></pre> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def parse_environments(\n    env_data: dict[str, Any],\n    env_group: Optional[str] = None,\n    platform_name: Optional[str] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Parse environment values from settings byt group and platform.\n\n    Data may contain up to 2 hierarchical levels of dictionaries. At the end\n    of the last level must be string or list. List is joined using platform\n    specific joiner (';' for windows and ':' for linux and mac).\n\n    Hierarchical levels can contain keys for subgroups and platform name.\n    Platform specific values must be always last level of dictionary. Platform\n    names are \"windows\" (MS Windows), \"linux\" (any linux distribution) and\n    \"darwin\" (any MacOS distribution).\n\n    Subgroups are helpers added mainly for standard and on farm usage. Farm\n    may require different environments for e.g. licence related values or\n    plugins. Default subgroup is \"standard\".\n\n    Examples:\n    ```\n    {\n        # Unchanged value\n        \"ENV_KEY1\": \"value\",\n        # Empty values are kept (unset environment variable)\n        \"ENV_KEY2\": \"\",\n\n        # Join list values with ':' or ';'\n        \"ENV_KEY3\": [\"value1\", \"value2\"],\n\n        # Environment groups\n        \"ENV_KEY4\": {\n            \"standard\": \"DEMO_SERVER_URL\",\n            \"farm\": \"LICENCE_SERVER_URL\"\n        },\n\n        # Platform specific (and only for windows and mac)\n        \"ENV_KEY5\": {\n            \"windows\": \"windows value\",\n            \"darwin\": [\"value 1\", \"value 2\"]\n        },\n\n        # Environment groups and platform combination\n        \"ENV_KEY6\": {\n            \"farm\": \"FARM_VALUE\",\n            \"standard\": {\n                \"windows\": [\"value1\", \"value2\"],\n                \"linux\": \"value1\",\n                \"darwin\": \"\"\n            }\n        }\n    }\n    ```\n    \"\"\"\n    output = {}\n    if not env_data:\n        return output\n\n    if not env_group:\n        env_group = DEFAULT_ENV_SUBGROUP\n\n    if not platform_name:\n        platform_name = platform.system().lower()\n\n    for key, value in env_data.items():\n        if isinstance(value, dict):\n            # Look if any key is platform key\n            #   - expect that represents environment group if does not contain\n            #   platform keys\n            if not PLATFORM_NAMES.intersection(set(value.keys())):\n                # Skip the key if group is not available\n                if env_group not in value:\n                    continue\n                value = value[env_group]\n\n        # Check again if value is dictionary\n        #   - this time there should be only platform keys\n        if isinstance(value, dict):\n            value = value.get(platform_name)\n\n        # Check if value is list and join it's values\n        # QUESTION Should empty values be skipped?\n        if isinstance(value, (list, tuple)):\n            value = os.pathsep.join(value)\n\n        # Set key to output if value is string\n        if isinstance(value, str):\n            output[key] = value\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.prepare_app_environments","title":"<code>prepare_app_environments(data, env_group=None, implementation_envs=True, addons_manager=None)</code>","text":"<p>Modify launch environments based on launched app and context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EnvironmentPrepData</code> <p>Dictionary where result and intermediate result will be stored.</p> required Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def prepare_app_environments(\n    data: dict[str, Any],\n    env_group: Optional[str] = None,\n    implementation_envs: bool = True,\n    addons_manager: Optional[AddonsManager] = None\n) -&gt; None:\n    \"\"\"Modify launch environments based on launched app and context.\n\n    Args:\n        data (EnvironmentPrepData): Dictionary where result and intermediate\n            result will be stored.\n\n    \"\"\"\n    app = data[\"app\"]\n    log = data[\"log\"]\n    source_env = data[\"env\"].copy()\n\n    if addons_manager is None:\n        addons_manager = AddonsManager()\n\n    _add_python_version_paths(app, source_env, log, addons_manager)\n\n    # Use environments from local settings\n    filtered_local_envs = {}\n    # NOTE Overrides for environment variables are not implemented in AYON.\n    # project_settings = data[\"project_settings\"]\n    # whitelist_envs = project_settings[\"general\"].get(\"local_env_white_list\")\n    # if whitelist_envs:\n    #     local_settings = get_local_settings()\n    #     local_envs = local_settings.get(\"environments\") or {}\n    #     filtered_local_envs = {\n    #         key: value\n    #         for key, value in local_envs.items()\n    #         if key in whitelist_envs\n    #     }\n\n    # Apply local environment variables for already existing values\n    for key, value in filtered_local_envs.items():\n        if key in source_env:\n            source_env[key] = value\n\n    # `app_and_tool_labels` has debug purpose\n    app_and_tool_labels = [app.full_name]\n    # Environments for application\n    environments = [\n        app.group.environment,\n        app.environment\n    ]\n\n    tools = get_tools_for_context(\n        data.get(\"project_name\"),\n        data.get(\"folder_entity\"),\n        data.get(\"task_entity\"),\n    )\n\n    # Add tools environments\n    groups_by_name = {}\n    tool_by_group_name = collections.defaultdict(dict)\n    used_tool_names = []\n    for key in tools:\n        tool = app.manager.tools.get(key)\n        if not tool or not tool.is_valid_for_app(app):\n            continue\n        used_tool_names.append(tool.full_name)\n        groups_by_name[tool.group.name] = tool.group\n        tool_by_group_name[tool.group.name][tool.name] = tool\n\n    for group_name in sorted(groups_by_name.keys()):\n        group = groups_by_name[group_name]\n        environments.append(group.environment)\n        for tool_name in sorted(tool_by_group_name[group_name].keys()):\n            tool = tool_by_group_name[group_name][tool_name]\n            environments.append(tool.environment)\n            app_and_tool_labels.append(tool.full_name)\n\n    log.info(\n        \"Will add environments for apps and tools: {}\".format(\n            \", \".join(app_and_tool_labels)\n        )\n    )\n\n    env_values = {}\n    for _env_values in environments:\n        if not _env_values:\n            continue\n\n        # Choose right platform\n        tool_env = parse_environments(_env_values, env_group)\n\n        # Apply local environment variables\n        # - must happen between all values because they may be used during\n        #   merge\n        for key, value in filtered_local_envs.items():\n            if key in tool_env:\n                tool_env[key] = value\n\n        # Merge dictionaries\n        env_values = merge_env_variables(tool_env, env_values)\n\n    merged_env = merge_env_variables(env_values, source_env)\n    loaded_env = compute_env_variables_structure(merged_env)\n\n    final_env = None\n    # Add host specific environments\n    if app.host_name and implementation_envs:\n        host_addon = addons_manager.get_host_addon(app.host_name)\n        add_implementation_envs = None\n        if host_addon:\n            add_implementation_envs = getattr(\n                host_addon, \"add_implementation_envs\", None\n            )\n        if add_implementation_envs:\n            # Function may only modify passed dict without returning value\n            final_env = add_implementation_envs(loaded_env, app)\n\n    if final_env is None:\n        final_env = loaded_env\n\n    keys_to_remove = set(source_env.keys()) - set(final_env.keys())\n\n    # Update env\n    data[\"env\"].update(final_env)\n    for key in keys_to_remove:\n        data[\"env\"].pop(key, None)\n    data[\"env\"][\"AYON_APP_TOOLS\"] = \";\".join(used_tool_names)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.prepare_context_environments","title":"<code>prepare_context_environments(data, env_group=None, addons_manager=None)</code>","text":"<p>Modify launch environments with context data for launched host.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EnvironmentPrepData</code> <p>Dictionary where result and intermediate result will be stored.</p> required Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def prepare_context_environments(\n    data: EnvironmentPrepData,\n    env_group: Optional[str] = None,\n    addons_manager: Optional[AddonsManager] = None,\n) -&gt; None:\n    \"\"\"Modify launch environments with context data for launched host.\n\n    Args:\n        data (EnvironmentPrepData): Dictionary where result and intermediate\n            result will be stored.\n\n    \"\"\"\n    # Context environments\n    log = data[\"log\"]\n\n    project_entity = data[\"project_entity\"]\n    folder_entity = data[\"folder_entity\"]\n    task_entity = data[\"task_entity\"]\n    if not project_entity:\n        log.info(\n            \"Skipping context environments preparation.\"\n            \" Launch context does not contain required data.\"\n        )\n        return\n\n    # Load project specific environments\n    project_name = project_entity[\"name\"]\n    project_settings = get_project_settings(project_name)\n    data[\"project_settings\"] = project_settings\n\n    app = data[\"app\"]\n    context_env = {\n        \"AYON_PROJECT_NAME\": project_entity[\"name\"],\n        \"AYON_APP_NAME\": app.full_name\n    }\n    if folder_entity:\n        folder_path = folder_entity[\"path\"]\n        context_env[\"AYON_FOLDER_PATH\"] = folder_path\n\n        if task_entity:\n            context_env[\"AYON_TASK_NAME\"] = task_entity[\"name\"]\n\n    log.debug(\n        \"Context environments set:\\n{}\".format(\n            json.dumps(context_env, indent=4)\n        )\n    )\n    data[\"env\"].update(context_env)\n\n    # Apply project specific environments on current env value\n    # - apply them once the context environments are set\n    apply_project_environments_value(\n        project_name, data[\"env\"], project_settings, env_group\n    )\n\n    if not app.is_host:\n        return\n\n    data[\"env\"][\"AYON_HOST_NAME\"] = app.host_name\n\n    if not folder_entity or not task_entity:\n        # QUESTION replace with log.info and skip workfile discovery?\n        # - technically it should be possible to launch host without context\n        raise ApplicationLaunchFailed(\n            \"Host launch require folder and task context.\"\n        )\n\n    workdir_data = get_template_data(\n        project_entity,\n        folder_entity,\n        task_entity,\n        app.host_name,\n        project_settings\n    )\n    data[\"workdir_data\"] = workdir_data\n\n    anatomy = data[\"anatomy\"]\n\n    task_type = workdir_data[\"task\"][\"type\"]\n    # Temp solution how to pass task type to `_prepare_last_workfile`\n    data[\"task_type\"] = task_type\n\n    try:\n        workdir = get_workdir_with_workdir_data(\n            workdir_data,\n            anatomy.project_name,\n            anatomy,\n            project_settings=project_settings\n        )\n\n    except Exception as exc:\n        raise ApplicationLaunchFailed(\n            f\"Error in anatomy.format: {exc}\"\n        )\n\n    if not os.path.exists(workdir):\n        log.debug(f\"Creating workdir folder: \\\"{workdir}\\\"\")\n        try:\n            os.makedirs(workdir, exist_ok=True)\n        except Exception as exc:\n            raise ApplicationLaunchFailed(\n                f\"Couldn't create workdir because: {exc}\"\n            )\n\n    data[\"env\"][\"AYON_WORKDIR\"] = workdir\n\n    _prepare_last_workfile(data, workdir, addons_manager)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/version.html","title":"version","text":"<p>Package declaring AYON addon 'applications' version.</p>"},{"location":"autoapi/client/ayon_applications/hooks/index.html","title":"Index","text":""},{"location":"autoapi/client/ayon_applications/hooks/prelaunch_shell_windows.html","title":"prelaunch_shell_windows","text":""},{"location":"autoapi/client/ayon_applications/hooks/prelaunch_shell_windows.html#client.ayon_applications.hooks.prelaunch_shell_windows.LaunchTerminalWindowsCreationflags","title":"<code>LaunchTerminalWindowsCreationflags</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Avoid running the terminal without new console</p> Source code in <code>client/ayon_applications/hooks/prelaunch_shell_windows.py</code> <pre><code>class LaunchTerminalWindowsCreationflags(PreLaunchHook):\n    \"\"\"Avoid running the terminal without new console\"\"\"\n\n    # Should be as last hook because must change launch arguments to string\n    order = 1000\n    app_groups = {\"terminal\"}\n    platforms = {\"windows\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Change `creationflags` to CREATE_NEW_CONSOLE\n        # - on Windows some apps will create new window using its console\n        # Set `stdout` and `stderr` to None so new created console does not\n        #   have redirected output to DEVNULL in build\n        self.launch_context.kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE,\n            \"stdout\": None,\n            \"stderr\": None\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_applications/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_app_name.html","title":"collect_app_name","text":"<p>Run after global plugin 'CollectHostName' in ayon_core.</p> Requires <p>None</p> Provides <p>context -&gt; hostName (str) context -&gt; appName (str) context -&gt; appLabel (str)</p>"},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_app_name.html#client.ayon_applications.plugins.publish.collect_app_name.CollectAppName","title":"<code>CollectAppName</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect avalon host name to context.</p> Source code in <code>client/ayon_applications/plugins/publish/collect_app_name.py</code> <pre><code>class CollectAppName(pyblish.api.ContextPlugin):\n    \"\"\"Collect avalon host name to context.\"\"\"\n\n    label = \"Collect App Name\"\n    order = pyblish.api.CollectorOrder - 0.499999\n\n    def process(self, context):\n        host_name = context.data.get(\"hostName\")\n        app_name = context.data.get(\"appName\")\n        app_label = context.data.get(\"appLabel\")\n        # Don't override value if is already set\n        if host_name and app_name and app_label:\n            return\n\n        # Use AYON_APP_NAME to get full app name\n        if not app_name:\n            app_name = os.environ.get(\"AYON_APP_NAME\")\n\n        # Fill missing values based on app full name\n        if (not host_name or not app_label) and app_name:\n            app_manager = ApplicationManager()\n            app = app_manager.applications.get(app_name)\n            if app:\n                if not host_name:\n                    host_name = app.host_name\n                if not app_label:\n                    app_label = app.full_label\n\n        context.data[\"hostName\"] = host_name\n        context.data[\"appName\"] = app_name\n        context.data[\"appLabel\"] = app_label\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_farm_env_variables.html","title":"collect_farm_env_variables","text":""},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_farm_env_variables.html#client.ayon_applications.plugins.publish.collect_farm_env_variables.CollectApplicationsJobEnvVars","title":"<code>CollectApplicationsJobEnvVars</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect set of environment variables for farm jobs</p> Source code in <code>client/ayon_applications/plugins/publish/collect_farm_env_variables.py</code> <pre><code>class CollectApplicationsJobEnvVars(pyblish.api.ContextPlugin):\n    \"\"\"Collect set of environment variables for farm jobs\"\"\"\n    order = pyblish.api.CollectorOrder - 0.45\n    label = \"Collect Applications farm environment variables\"\n    targets = [\"local\"]\n\n    def process(self, context):\n        env = context.data.setdefault(FARM_JOB_ENV_DATA_KEY, {})\n        for key in [\n            \"AYON_APP_NAME\",\n        ]:\n            value = os.getenv(key)\n            if value:\n                self.log.debug(f\"Setting job env: {key}: {value}\")\n                env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/publish/integrate_app_name.html","title":"integrate_app_name","text":""},{"location":"autoapi/client/ayon_applications/plugins/publish/integrate_app_name.html#client.ayon_applications.plugins.publish.integrate_app_name.IntegrateVersionAppNameData","title":"<code>IntegrateVersionAppNameData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Add application name to version data.</p> Source code in <code>client/ayon_applications/plugins/publish/integrate_app_name.py</code> <pre><code>class IntegrateVersionAppNameData(pyblish.api.InstancePlugin):\n    \"\"\"Add application name to version data.\"\"\"\n    label = \"Add app name to version data\"\n    order = pyblish.api.IntegratorOrder - 0.49\n\n    def process(self, instance):\n        version_data = instance.data.setdefault(\"versionData\", {})\n        app_name: str = instance.context.data[\"appName\"]\n        version_data[\"ayon_app_name\"] = app_name\n        self.log.debug(f\"Version data 'ayon_app_name' set to: {app_name}\")\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/index.html","title":"ui","text":""},{"location":"autoapi/client/ayon_applications/ui/ansi_parser.html","title":"ansi_parser","text":"<p>ANSI to HTML converter for rendering colored terminal output in a web UI.</p>"},{"location":"autoapi/client/ayon_applications/ui/ansi_parser.html#client.ayon_applications.ui.ansi_parser.AnsiToHtmlConverter","title":"<code>AnsiToHtmlConverter</code>","text":"<p>Convert ANSI escape sequences to HTML formatting.</p> Source code in <code>client/ayon_applications/ui/ansi_parser.py</code> <pre><code>class AnsiToHtmlConverter:\n    \"\"\"Convert ANSI escape sequences to HTML formatting.\"\"\"\n\n    # ANSI color codes to HTML colors\n    ANSI_COLORS = {\n        30: \"#000000\",  # Black\n        31: \"#AA0000\",  # Red\n        32: \"#00AA00\",  # Green\n        33: \"#AA5500\",  # Yellow\n        34: \"#0000AA\",  # Blue\n        35: \"#AA00AA\",  # Magenta\n        36: \"#00AAAA\",  # Cyan\n        37: \"#AAAAAA\",  # White\n        90: \"#555555\",  # Bright Black (Gray)\n        91: \"#FF5555\",  # Bright Red\n        92: \"#55FF55\",  # Bright Green\n        93: \"#FFFF55\",  # Bright Yellow\n        94: \"#5555FF\",  # Bright Blue\n        95: \"#FF55FF\",  # Bright Magenta\n        96: \"#55FFFF\",  # Bright Cyan\n        97: \"#FFFFFF\",  # Bright White\n    }\n\n    # Background colors (add 10 to foreground codes)\n    ANSI_BG_COLORS = {\n        40: \"#000000\",  # Black\n        41: \"#AA0000\",  # Red\n        42: \"#00AA00\",  # Green\n        43: \"#AA5500\",  # Yellow\n        44: \"#0000AA\",  # Blue\n        45: \"#AA00AA\",  # Magenta\n        46: \"#00AAAA\",  # Cyan\n        47: \"#AAAAAA\",  # White\n        100: \"#555555\",  # Bright Black (Gray)\n        101: \"#FF5555\",  # Bright Red\n        102: \"#55FF55\",  # Bright Green\n        103: \"#FFFF55\",  # Bright Yellow\n        104: \"#5555FF\",  # Bright Blue\n        105: \"#FF55FF\",  # Bright Magenta\n        106: \"#55FFFF\",  # Bright Cyan\n        107: \"#FFFFFF\",  # Bright White\n    }\n\n    def __init__(self):\n        \"\"\"Initialize the converter.\"\"\"\n        # Regex pattern to match ANSI escape sequences\n        self.ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n\n        # More specific pattern for SGR (Select Graphic Rendition) sequences\n        self.sgr_pattern = re.compile(r\"\\x1B\\[([0-9;]*)m\")\n\n    def convert(self, text: str) -&gt; str:\n        \"\"\"Convert text with ANSI codes to HTML.\n\n        Args:\n            text (str): Input text with ANSI escape sequences.\n\n        Returns:\n            str: HTML formatted text.\n        \"\"\"\n        if not text:\n            return \"\"\n\n        # HTML escape the text first, but preserve ANSI sequences\n        parts = []\n        last_end = 0\n\n        # Find all ANSI escape sequences\n        for match in self.ansi_escape.finditer(text):\n            # Add escaped text before this sequence\n            if match.start() &gt; last_end:\n                parts.append(html.escape(text[last_end : match.start()]))\n\n            # Add the ANSI sequence (unescaped for processing)\n            parts.append(text[match.start() : match.end()])\n            last_end = match.end()\n\n        # Add remaining escaped text\n        if last_end &lt; len(text):\n            parts.append(html.escape(text[last_end:]))\n\n        # Now process the mixed content\n        html_text = \"\".join(parts)\n\n        # Track current formatting state\n        current_fg = None\n        current_bg = None\n        bold = False\n        italic = False\n        underline = False\n\n        result_parts = []\n        open_spans = []\n\n        def close_all_spans():\n            \"\"\"Close all open spans.\"\"\"\n            nonlocal open_spans\n            for _ in open_spans:\n                result_parts.append(\"&lt;/span&gt;\")\n            open_spans.clear()\n\n        def open_span():\n            \"\"\"Open a new span with current formatting.\"\"\"\n            styles = []\n            if current_fg:\n                styles.append(f\"color: {current_fg}\")\n            if current_bg:\n                styles.append(f\"background-color: {current_bg}\")\n            if bold:\n                styles.append(\"font-weight: bold\")\n            if italic:\n                styles.append(\"font-style: italic\")\n            if underline:\n                styles.append(\"text-decoration: underline\")\n\n            if styles:\n                style_str = \"; \".join(styles)\n                result_parts.append(f'&lt;span style=\"{style_str}\"&gt;')\n                open_spans.append(\"span\")\n\n        # Process SGR sequences\n        last_pos = 0\n        for match in self.sgr_pattern.finditer(html_text):\n            # Add text before this sequence\n            if match.start() &gt; last_pos:\n                if not open_spans and (\n                    current_fg or current_bg or bold or italic or underline\n                ):\n                    open_span()\n                result_parts.append(html_text[last_pos : match.start()])\n\n            # Parse the SGR sequence\n            params = match.group(1) or \"0\"  # Default reset\n\n            codes = [int(x) if x else 0 for x in params.split(\";\")]\n\n            for code in codes:\n                if code == 0:  # Reset all\n                    close_all_spans()\n                    current_fg = current_bg = None\n                    bold = italic = underline = False\n                elif code == 1:  # Bold\n                    bold = True\n                elif code == 3:  # Italic\n                    italic = True\n                elif code == 4:  # Underline\n                    underline = True\n                elif code == 22:  # Normal intensity (not bold)\n                    bold = False\n                elif code == 23:  # Not italic\n                    italic = False\n                elif code == 24:  # Not underlined\n                    underline = False\n                elif code in self.ANSI_COLORS:  # Foreground color\n                    current_fg = self.ANSI_COLORS[code]\n                elif code in self.ANSI_BG_COLORS:  # Background color\n                    current_bg = self.ANSI_BG_COLORS[code]\n                elif code == 39:  # Default foreground\n                    current_fg = None\n                elif code == 49:  # Default background\n                    current_bg = None\n\n            # Close previous span and open new one if needed\n            if open_spans:\n                close_all_spans()\n            if current_fg or current_bg or bold or italic or underline:\n                open_span()\n\n            last_pos = match.end()\n\n        # Add remaining text\n        if last_pos &lt; len(html_text):\n            if not open_spans and (\n                current_fg or current_bg or bold or italic or underline\n            ):\n                open_span()\n            result_parts.append(html_text[last_pos:])\n\n        # Close any remaining spans\n        close_all_spans()\n\n        # Convert newlines to &lt;br&gt; tags\n        result = \"\".join(result_parts).replace(\"\\n\", \"&lt;br&gt;\")\n\n        return (\n            f'&lt;pre style=\"margin: 0; font-family: monospace;\"&gt;{result}&lt;/pre&gt;'\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/ansi_parser.html#client.ayon_applications.ui.ansi_parser.AnsiToHtmlConverter.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the converter.</p> Source code in <code>client/ayon_applications/ui/ansi_parser.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the converter.\"\"\"\n    # Regex pattern to match ANSI escape sequences\n    self.ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n\n    # More specific pattern for SGR (Select Graphic Rendition) sequences\n    self.sgr_pattern = re.compile(r\"\\x1B\\[([0-9;]*)m\")\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/ansi_parser.html#client.ayon_applications.ui.ansi_parser.AnsiToHtmlConverter.convert","title":"<code>convert(text)</code>","text":"<p>Convert text with ANSI codes to HTML.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Input text with ANSI escape sequences.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>HTML formatted text.</p> Source code in <code>client/ayon_applications/ui/ansi_parser.py</code> <pre><code>def convert(self, text: str) -&gt; str:\n    \"\"\"Convert text with ANSI codes to HTML.\n\n    Args:\n        text (str): Input text with ANSI escape sequences.\n\n    Returns:\n        str: HTML formatted text.\n    \"\"\"\n    if not text:\n        return \"\"\n\n    # HTML escape the text first, but preserve ANSI sequences\n    parts = []\n    last_end = 0\n\n    # Find all ANSI escape sequences\n    for match in self.ansi_escape.finditer(text):\n        # Add escaped text before this sequence\n        if match.start() &gt; last_end:\n            parts.append(html.escape(text[last_end : match.start()]))\n\n        # Add the ANSI sequence (unescaped for processing)\n        parts.append(text[match.start() : match.end()])\n        last_end = match.end()\n\n    # Add remaining escaped text\n    if last_end &lt; len(text):\n        parts.append(html.escape(text[last_end:]))\n\n    # Now process the mixed content\n    html_text = \"\".join(parts)\n\n    # Track current formatting state\n    current_fg = None\n    current_bg = None\n    bold = False\n    italic = False\n    underline = False\n\n    result_parts = []\n    open_spans = []\n\n    def close_all_spans():\n        \"\"\"Close all open spans.\"\"\"\n        nonlocal open_spans\n        for _ in open_spans:\n            result_parts.append(\"&lt;/span&gt;\")\n        open_spans.clear()\n\n    def open_span():\n        \"\"\"Open a new span with current formatting.\"\"\"\n        styles = []\n        if current_fg:\n            styles.append(f\"color: {current_fg}\")\n        if current_bg:\n            styles.append(f\"background-color: {current_bg}\")\n        if bold:\n            styles.append(\"font-weight: bold\")\n        if italic:\n            styles.append(\"font-style: italic\")\n        if underline:\n            styles.append(\"text-decoration: underline\")\n\n        if styles:\n            style_str = \"; \".join(styles)\n            result_parts.append(f'&lt;span style=\"{style_str}\"&gt;')\n            open_spans.append(\"span\")\n\n    # Process SGR sequences\n    last_pos = 0\n    for match in self.sgr_pattern.finditer(html_text):\n        # Add text before this sequence\n        if match.start() &gt; last_pos:\n            if not open_spans and (\n                current_fg or current_bg or bold or italic or underline\n            ):\n                open_span()\n            result_parts.append(html_text[last_pos : match.start()])\n\n        # Parse the SGR sequence\n        params = match.group(1) or \"0\"  # Default reset\n\n        codes = [int(x) if x else 0 for x in params.split(\";\")]\n\n        for code in codes:\n            if code == 0:  # Reset all\n                close_all_spans()\n                current_fg = current_bg = None\n                bold = italic = underline = False\n            elif code == 1:  # Bold\n                bold = True\n            elif code == 3:  # Italic\n                italic = True\n            elif code == 4:  # Underline\n                underline = True\n            elif code == 22:  # Normal intensity (not bold)\n                bold = False\n            elif code == 23:  # Not italic\n                italic = False\n            elif code == 24:  # Not underlined\n                underline = False\n            elif code in self.ANSI_COLORS:  # Foreground color\n                current_fg = self.ANSI_COLORS[code]\n            elif code in self.ANSI_BG_COLORS:  # Background color\n                current_bg = self.ANSI_BG_COLORS[code]\n            elif code == 39:  # Default foreground\n                current_fg = None\n            elif code == 49:  # Default background\n                current_bg = None\n\n        # Close previous span and open new one if needed\n        if open_spans:\n            close_all_spans()\n        if current_fg or current_bg or bold or italic or underline:\n            open_span()\n\n        last_pos = match.end()\n\n    # Add remaining text\n    if last_pos &lt; len(html_text):\n        if not open_spans and (\n            current_fg or current_bg or bold or italic or underline\n        ):\n            open_span()\n        result_parts.append(html_text[last_pos:])\n\n    # Close any remaining spans\n    close_all_spans()\n\n    # Convert newlines to &lt;br&gt; tags\n    result = \"\".join(result_parts).replace(\"\\n\", \"&lt;br&gt;\")\n\n    return (\n        f'&lt;pre style=\"margin: 0; font-family: monospace;\"&gt;{result}&lt;/pre&gt;'\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/debug_terminal_launch.html","title":"debug_terminal_launch","text":""},{"location":"autoapi/client/ayon_applications/ui/launch_failed_dialog.html","title":"launch_failed_dialog","text":""},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html","title":"process_monitor","text":"<p>Process Monitor UI for launched processes.</p>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CatchTime","title":"<code>CatchTime</code>","text":"<p>Context manager to measure execution time.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class CatchTime:\n    \"\"\"Context manager to measure execution time.\"\"\"\n    def __enter__(self):\n        \"\"\"Start timing.\n\n        Returns:\n            CatchTime: self, with start time initialized.\n\n        \"\"\"\n        self.start = perf_counter()\n        return self\n\n    def __exit__(\n            self,\n            type_: Optional[type[BaseException]],\n            value: Optional[BaseException],\n            traceback: Optional[TracebackType],\n    ) -&gt; Optional[bool]:\n        \"\"\"Stop timing and store elapsed time.\n\n        Returns:\n            Optional[bool]: None\n\n        \"\"\"\n        self.time = perf_counter() - self.start\n        self.readout = f\"Time: {self.time:.3f} seconds\"\n        return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CatchTime.__enter__","title":"<code>__enter__()</code>","text":"<p>Start timing.</p> <p>Returns:</p> Name Type Description <code>CatchTime</code> <p>self, with start time initialized.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Start timing.\n\n    Returns:\n        CatchTime: self, with start time initialized.\n\n    \"\"\"\n    self.start = perf_counter()\n    return self\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CatchTime.__exit__","title":"<code>__exit__(type_, value, traceback)</code>","text":"<p>Stop timing and store elapsed time.</p> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>Optional[bool]: None</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __exit__(\n        self,\n        type_: Optional[type[BaseException]],\n        value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n) -&gt; Optional[bool]:\n    \"\"\"Stop timing and store elapsed time.\n\n    Returns:\n        Optional[bool]: None\n\n    \"\"\"\n    self.time = perf_counter() - self.start\n    self.readout = f\"Time: {self.time:.3f} seconds\"\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CleanupWorker","title":"<code>CleanupWorker</code>","text":"<p>               Bases: <code>QRunnable</code></p> <p>Worker thread for cleanup operations.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class CleanupWorker(QRunnable):\n    \"\"\"Worker thread for cleanup operations.\"\"\"\n\n    def __init__(self,\n                 manager: ProcessManager,\n                 cleanup_type: str,\n                 process_hash: Optional[str] = None) -&gt; None:\n        \"\"\"Initialize the worker.\n\n        Args:\n            manager (ApplicationManager): Application manager instance.\n            cleanup_type (str): Type of cleanup (\"inactive\" or \"single\").\n            process_hash (Optional[str]): Hash of the process to delete\n                if cleanup_type is \"single\".\n\n        \"\"\"\n        super().__init__()\n        self.signals = CleanupWorkerSignals()\n        self.signature = f\"{self.__class__.__name__} ({cleanup_type})\"\n        self._manager = manager\n        self._cleanup_type = cleanup_type  # \"inactive\" or \"single\"\n        self._process_hash = process_hash\n        self._log = getLogger(self.signature)\n\n    @Slot()\n    def run(self) -&gt; None:\n        \"\"\"Perform cleanup in background thread.\"\"\"\n        self._log.debug(\n            \"Starting cleanup of type: %s\", self._cleanup_type)\n        try:\n            if self._cleanup_type == \"inactive\":\n                self._cleanup_inactive()\n            elif self._cleanup_type == \"single\":\n                self._remove_selected()\n        except Exception as e:  # noqa: BLE001\n            self.signals.error.emit(str(e))\n\n    def _cleanup_inactive(self) -&gt; None:\n        \"\"\"Clean up inactive processes.\"\"\"\n        deleted_count = self._manager.delete_inactive_processes()\n        self.signals.finished.emit(deleted_count)\n\n    def _remove_selected(self) -&gt; None:\n        \"\"\"Remove a single selected process.\"\"\"\n        if not self._process_hash:\n            self.signals.error.emit(\"No process hash provided\")\n            return\n\n        self._manager.delete_process_info(self._process_hash)\n        self.signals.finished.emit(1)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CleanupWorker.__init__","title":"<code>__init__(manager, cleanup_type, process_hash=None)</code>","text":"<p>Initialize the worker.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>ApplicationManager</code> <p>Application manager instance.</p> required <code>cleanup_type</code> <code>str</code> <p>Type of cleanup (\"inactive\" or \"single\").</p> required <code>process_hash</code> <code>Optional[str]</code> <p>Hash of the process to delete if cleanup_type is \"single\".</p> <code>None</code> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(self,\n             manager: ProcessManager,\n             cleanup_type: str,\n             process_hash: Optional[str] = None) -&gt; None:\n    \"\"\"Initialize the worker.\n\n    Args:\n        manager (ApplicationManager): Application manager instance.\n        cleanup_type (str): Type of cleanup (\"inactive\" or \"single\").\n        process_hash (Optional[str]): Hash of the process to delete\n            if cleanup_type is \"single\".\n\n    \"\"\"\n    super().__init__()\n    self.signals = CleanupWorkerSignals()\n    self.signature = f\"{self.__class__.__name__} ({cleanup_type})\"\n    self._manager = manager\n    self._cleanup_type = cleanup_type  # \"inactive\" or \"single\"\n    self._process_hash = process_hash\n    self._log = getLogger(self.signature)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CleanupWorker.run","title":"<code>run()</code>","text":"<p>Perform cleanup in background thread.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>@Slot()\ndef run(self) -&gt; None:\n    \"\"\"Perform cleanup in background thread.\"\"\"\n    self._log.debug(\n        \"Starting cleanup of type: %s\", self._cleanup_type)\n    try:\n        if self._cleanup_type == \"inactive\":\n            self._cleanup_inactive()\n        elif self._cleanup_type == \"single\":\n            self._remove_selected()\n    except Exception as e:  # noqa: BLE001\n        self.signals.error.emit(str(e))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.CleanupWorkerSignals","title":"<code>CleanupWorkerSignals</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Signals for CleanupWorker.</p> <p>Signals can be defined only in classes derived from QObject.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class CleanupWorkerSignals(QtCore.QObject):\n    \"\"\"Signals for CleanupWorker.\n\n    Signals can be defined only in classes derived from QObject.\n    \"\"\"\n    # Emits (deleted_processes, deleted_files)\n    finished = QtCore.Signal(int)\n    error = QtCore.Signal(str)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileChangeWatcher","title":"<code>FileChangeWatcher</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Qt-based file watcher with rotation handling and debounce.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class FileChangeWatcher(QtCore.QObject):\n    \"\"\"Qt-based file watcher with rotation handling and debounce.\"\"\"\n    changed = QtCore.Signal(object)  # emits Path (as object)\n\n    def __init__(self, parent=None, debounce_ms: int = 150) -&gt; None:\n        super().__init__(parent)\n        self._watcher = QtCore.QFileSystemWatcher(self)\n        self._target: Optional[Path] = None\n\n        # debounce timer to coalesce bursts of events\n        # QFileSystemWatcher can emit multiple events for a single change\n        self._debounce = QtCore.QTimer(self)\n        self._debounce.setSingleShot(True)\n        self._debounce.setInterval(debounce_ms)\n        self._debounce.timeout.connect(self._emit_changed)\n\n        self._watcher.fileChanged.connect(self._on_any_change)\n        self._watcher.directoryChanged.connect(self._on_any_change)\n\n    def set_target(self, file_path: Optional[Path]) -&gt; None:\n        \"\"\"Start watching given file and its parent directory.\"\"\"\n        self.stop()\n        self._target = file_path\n        if not file_path:\n            return\n\n        # Clear watched paths\n        for path in self._watcher.files():\n            with contextlib.suppress(Exception):\n                self._watcher.removePath(path)\n\n        # Watch the file (if present)\n        with contextlib.suppress(Exception):\n            self._watcher.files()\n            self._watcher.addPath(str(file_path))\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop watching.\"\"\"\n        self._debounce.stop()\n        files = self._watcher.files()\n        if files:\n            self._watcher.removePaths(files)\n        dirs = self._watcher.directories()\n        if dirs:\n            self._watcher.removePaths(dirs)\n\n    @QtCore.Slot(str)\n    def _on_any_change(self, _path: str) -&gt; None:\n        \"\"\"Handle file changes.\"\"\"\n        if not self._target:\n            return\n        # Debounce bursts of events.\n        self._debounce.start()\n\n    def _emit_changed(self) -&gt; None:\n        if self._target:\n            self.changed.emit(self._target)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileChangeWatcher.set_target","title":"<code>set_target(file_path)</code>","text":"<p>Start watching given file and its parent directory.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def set_target(self, file_path: Optional[Path]) -&gt; None:\n    \"\"\"Start watching given file and its parent directory.\"\"\"\n    self.stop()\n    self._target = file_path\n    if not file_path:\n        return\n\n    # Clear watched paths\n    for path in self._watcher.files():\n        with contextlib.suppress(Exception):\n            self._watcher.removePath(path)\n\n    # Watch the file (if present)\n    with contextlib.suppress(Exception):\n        self._watcher.files()\n        self._watcher.addPath(str(file_path))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileChangeWatcher.stop","title":"<code>stop()</code>","text":"<p>Stop watching.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop watching.\"\"\"\n    self._debounce.stop()\n    files = self._watcher.files()\n    if files:\n        self._watcher.removePaths(files)\n    dirs = self._watcher.directories()\n    if dirs:\n        self._watcher.removePaths(dirs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileContentWorker","title":"<code>FileContentWorker</code>","text":"<p>               Bases: <code>QRunnable</code></p> <p>Worker thread for loading file content.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class FileContentWorker(QRunnable):\n    \"\"\"Worker thread for loading file content.\"\"\"\n\n    def __init__(self, file_path: Path):\n        \"\"\"Initialize the worker.\n\n        Args:\n            file_path (Path): Path to the file to load.\n\n        \"\"\"\n        super().__init__()\n        self.signals = FileContentWorkerSignals()\n        self.signature = self.__class__.__name__\n        self._file_path = file_path\n        self._log = getLogger(self.signature)\n\n    @Slot()\n    def run(self) -&gt; None:\n        \"\"\"Load file content in background thread.\"\"\"\n        self._log.debug(\"Loading file content from %s\", self._file_path)\n        try:\n            if not self._file_path or not Path(self._file_path).exists():\n                self.signals.finished.emit(\"Output file not found\")\n                return\n\n            content = Path(self._file_path).read_text(\n                encoding=\"utf-8\", errors=\"replace\")\n            self.signals.finished.emit(content)\n        except Exception as e:  # noqa: BLE001\n            self.signals.error.emit(f\"Error reading file: {e}\")\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileContentWorker.__init__","title":"<code>__init__(file_path)</code>","text":"<p>Initialize the worker.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the file to load.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(self, file_path: Path):\n    \"\"\"Initialize the worker.\n\n    Args:\n        file_path (Path): Path to the file to load.\n\n    \"\"\"\n    super().__init__()\n    self.signals = FileContentWorkerSignals()\n    self.signature = self.__class__.__name__\n    self._file_path = file_path\n    self._log = getLogger(self.signature)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileContentWorker.run","title":"<code>run()</code>","text":"<p>Load file content in background thread.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>@Slot()\ndef run(self) -&gt; None:\n    \"\"\"Load file content in background thread.\"\"\"\n    self._log.debug(\"Loading file content from %s\", self._file_path)\n    try:\n        if not self._file_path or not Path(self._file_path).exists():\n            self.signals.finished.emit(\"Output file not found\")\n            return\n\n        content = Path(self._file_path).read_text(\n            encoding=\"utf-8\", errors=\"replace\")\n        self.signals.finished.emit(content)\n    except Exception as e:  # noqa: BLE001\n        self.signals.error.emit(f\"Error reading file: {e}\")\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.FileContentWorkerSignals","title":"<code>FileContentWorkerSignals</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Signals for FileContentWorker.</p> <p>Signals can be defined only in classes derived from QObject.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class FileContentWorkerSignals(QtCore.QObject):\n    \"\"\"Signals for FileContentWorker.\n\n    Signals can be defined only in classes derived from QObject.\n    \"\"\"\n    finished = QtCore.Signal(str)  # Emits file content\n    error = QtCore.Signal(str)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessDescendantsUpdateWorker","title":"<code>ProcessDescendantsUpdateWorker</code>","text":"<p>               Bases: <code>QRunnable</code></p> <p>Worker thread for updating process descendants.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessDescendantsUpdateWorker(QRunnable):\n    \"\"\"Worker thread for updating process descendants.\"\"\"\n\n    def __init__(\n            self,\n            manager: ProcessManager,\n            parent_pid: int,\n            parent_hash: str):\n        \"\"\"Initialize the worker.\"\"\"\n        super().__init__()\n        self.signals = ProcessDescendantsUpdateWorkerSignals()\n        self.signature = self.__class__.__name__\n        self._manager = manager\n        self._parent_pid = parent_pid\n        self._parent_hash = parent_hash\n        self._log = getLogger(self.signature)\n\n    @Slot()\n    def run(self) -&gt; None:\n        \"\"\"Update process descendants data in background thread.\"\"\"\n        with CatchTime() as timer:\n            try:\n                descendants = self._manager.get_descendant_processes_by_pid(\n                    self._parent_pid)\n                self.signals.finished.emit(self._parent_hash, descendants)\n            except Exception as e:  # noqa: BLE001\n                self.signals.error.emit(str(e))\n        self._log.debug(\n            \"Descendants update from db completed in %s\", timer.readout)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessDescendantsUpdateWorker.__init__","title":"<code>__init__(manager, parent_pid, parent_hash)</code>","text":"<p>Initialize the worker.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(\n        self,\n        manager: ProcessManager,\n        parent_pid: int,\n        parent_hash: str):\n    \"\"\"Initialize the worker.\"\"\"\n    super().__init__()\n    self.signals = ProcessDescendantsUpdateWorkerSignals()\n    self.signature = self.__class__.__name__\n    self._manager = manager\n    self._parent_pid = parent_pid\n    self._parent_hash = parent_hash\n    self._log = getLogger(self.signature)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessDescendantsUpdateWorker.run","title":"<code>run()</code>","text":"<p>Update process descendants data in background thread.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>@Slot()\ndef run(self) -&gt; None:\n    \"\"\"Update process descendants data in background thread.\"\"\"\n    with CatchTime() as timer:\n        try:\n            descendants = self._manager.get_descendant_processes_by_pid(\n                self._parent_pid)\n            self.signals.finished.emit(self._parent_hash, descendants)\n        except Exception as e:  # noqa: BLE001\n            self.signals.error.emit(str(e))\n    self._log.debug(\n        \"Descendants update from db completed in %s\", timer.readout)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessDescendantsUpdateWorkerSignals","title":"<code>ProcessDescendantsUpdateWorkerSignals</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Signals for ProcessDescendantsUpdateWorker.</p> <p>Signals can be defined only in classes derived from QObject.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessDescendantsUpdateWorkerSignals(QtCore.QObject):\n    \"\"\"Signals for ProcessDescendantsUpdateWorker.\n\n    Signals can be defined only in classes derived from QObject.\n    \"\"\"\n    # Emits (parent_hash, list[ProcessInfo])\n    finished = QtCore.Signal(object, list)\n    error = QtCore.Signal(str)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController","title":"<code>ProcessMonitorController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controller that encapsulates data logic for ProcessMonitorWindow.</p> <p>Handles ApplicationManager, QThreadPool, and QTimers.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessMonitorController(QtCore.QObject):\n    \"\"\"Controller that encapsulates data logic for ProcessMonitorWindow.\n\n    Handles ApplicationManager, QThreadPool, and QTimers.\n\n    \"\"\"\n    processes_refreshed = QtCore.Signal(list)\n    file_content = QtCore.Signal(str)\n    cleanup_finished = QtCore.Signal(int)\n    error = QtCore.Signal(str)\n    # New: descendants refreshed signal (parent_hash, descendants)\n    descendants_refreshed = QtCore.Signal(object, list)\n\n    def __init__(self, parent: Optional[QtCore.QObject] = None):\n        \"\"\"Initialize the controller.\"\"\"\n        super().__init__(parent)\n        self.manager = ProcessManager()\n        self._thread_pool = QThreadPool()\n        self._file_watcher = FileChangeWatcher(self)\n        self._file_watcher.changed.connect(self._on_file_changed)\n\n        # Timers (created once)\n        self._refresh_timer = QtCore.QTimer(self)\n        self._refresh_timer.timeout.connect(self.refresh)\n        self._refresh_timer.setInterval(5000)\n\n        self._file_reload_timer = QtCore.QTimer(self)\n        self._file_reload_timer.timeout.connect(self._on_file_reload_timeout)\n        self._file_reload_timer.setSingleShot(False)\n        self._file_reload_interval = 2000\n        self._file_reload_target: Optional[Path] = None\n\n    # Timer control\n    def start_timers(self) -&gt; None:\n        \"\"\"Start the refresh timer if not already active.\"\"\"\n        if not self._refresh_timer.isActive():\n            self._refresh_timer.start()\n\n    def stop_timers(self) -&gt; None:\n        \"\"\"Stop all active timers.\"\"\"\n        if self._refresh_timer.isActive():\n            self._refresh_timer.stop()\n        if self._file_reload_timer.isActive():\n            self._file_reload_timer.stop()\n\n    # Refresh\n    def refresh(self) -&gt; None:\n        \"\"\"Refresh process data in background thread.\"\"\"\n        try:\n            worker = ProcessRefreshWorker(self.manager)\n            worker.signals.finished.connect(self._on_refresh_finished)\n            worker.signals.error.connect(self._on_error)\n            self._thread_pool.start(worker)\n        except Exception as exc:  # noqa: BLE001\n            self.error.emit(str(exc))\n\n    def _on_refresh_finished(self, processes: list[ProcessInfo]) -&gt; None:\n        \"\"\"Handle completion of process refresh.\n\n        Args:\n            processes (list[ProcessInfo]): List of refreshed processes.\n\n        \"\"\"\n        self.processes_refreshed.emit(processes)\n\n    def fetch_descendants(self, parent_process: ProcessInfo) -&gt; None:\n        \"\"\"Fetch descendants of a given parent process in background thread.\n\n        Args:\n            parent_process (ProcessInfo): Parent process whose descendants\n                to fetch.\n\n        \"\"\"\n        if not parent_process.pid or not parent_process.hash:\n            return\n        try:\n            worker = ProcessDescendantsUpdateWorker(\n                self.manager, parent_process.pid, parent_process.hash)\n            worker.signals.finished.connect(self._on_descendants_finished)\n            worker.signals.error.connect(self._on_error)\n            self._thread_pool.start(worker)\n        except Exception as exc:  # noqa: BLE001\n            self.error.emit(str(exc))\n\n    def _on_descendants_finished(\n            self,\n            parent_hash: object,\n            descendants: list[ProcessInfo]) -&gt; None:\n        \"\"\"Handle completion of descendants fetch.\n\n        Args:\n            parent_hash (object): Hash of the parent process.\n            descendants (list[ProcessInfo]): List of descendant processes.\n\n        \"\"\"\n        # Re-emit to window\n        try:\n            self.descendants_refreshed.emit(str(parent_hash), descendants)\n        except Exception as exc:  # noqa: BLE001\n            self.error.emit(str(exc))\n\n    def load_file_content(self, file_path: Optional[Path]) -&gt; None:\n        \"\"\"Load file content in background thread.\n\n        Args:\n            file_path (Optional[Path]): Path to the file to load.\n\n        \"\"\"\n        if not file_path:\n            self.file_content.emit(\"No output file available\")\n            return\n        try:\n            worker = FileContentWorker(file_path)\n            worker.signals.finished.connect(self._on_file_content_loaded)\n            worker.signals.error.connect(self._on_error)\n            self._thread_pool.start(worker)\n        except Exception as exc:  # noqa: BLE001\n            self.error.emit(str(exc))\n\n    def _on_file_content_loaded(self, content: str) -&gt; None:\n        \"\"\"Handle completion of file content loading.\"\"\"\n        self.file_content.emit(content)\n\n    # Auto-reload control\n    def start_file_watch(self, file_path: Path) -&gt; None:\n        \"\"\"Start watching file for instant updates.\n\n        Args:\n            file_path (Path): Path to the file to watch.\n\n        \"\"\"\n        self._file_watcher.set_target(file_path)\n        # Also load immediately so UI updates without waiting for first event.\n        self.load_file_content(file_path)\n\n    def stop_file_watch(self) -&gt; None:\n        \"\"\"Stop watching file.\"\"\"\n        self._file_watcher.stop()\n\n    def start_file_reload(self, file_path: Path, interval: int = 2000) -&gt; None:\n        \"\"\"Start auto-reloading file content at given interval.\"\"\"\n        self._file_reload_target = file_path\n        self._file_reload_interval = interval\n        self._file_reload_timer.start(self._file_reload_interval)\n\n    def stop_file_reload(self) -&gt; None:\n        \"\"\"Stop auto-reloading file content.\"\"\"\n        self._file_reload_timer.stop()\n        self._file_reload_target = None\n\n    def _on_file_reload_timeout(self) -&gt; None:\n        \"\"\"Handle file reload timer timeout.\"\"\"\n        if self._file_reload_target:\n            self.load_file_content(self._file_reload_target)\n\n    @QtCore.Slot(object)\n    def _on_file_changed(self, file_obj: object) -&gt; None:\n        \"\"\"Instant update on file change.\"\"\"\n        file_path = Path(str(file_obj))\n        self.load_file_content(file_path)\n\n    # Cleanup operations\n    def clean_inactive(self) -&gt; None:\n        \"\"\"Clean all inactive processes in background thread.\"\"\"\n        try:\n            worker = CleanupWorker(self.manager, \"inactive\")\n            worker.signals.finished.connect(self._on_cleanup_finished)\n            worker.signals.error.connect(self._on_error)\n            self._thread_pool.start(worker)\n        except Exception as exc:  # noqa: BLE001\n            self.error.emit(str(exc))\n\n    def delete_single(self, process_hash: str) -&gt; None:\n        \"\"\"Delete a single process by its hash in background thread.\n\n        Args:\n            process_hash (str): Hash of the process to delete.\n\n        \"\"\"\n        try:\n            worker = CleanupWorker(self.manager, \"single\", process_hash)\n            worker.signals.finished.connect(self._on_cleanup_finished)\n            worker.signals.error.connect(self._on_error)\n            self._thread_pool.start(worker)\n        except Exception as exc:  # noqa: BLE001\n            self.error.emit(str(exc))\n\n    def _on_cleanup_finished(\n            self, deleted_proc: int) -&gt; None:\n        \"\"\"Handle completion of cleanup operation.\"\"\"\n        self.cleanup_finished.emit(deleted_proc)\n\n    def _on_error(self, msg: str) -&gt; None:\n        \"\"\"Handle errors from workers.\"\"\"\n        self.error.emit(msg)\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown controller.\n\n        Stop timers and wait for workers.\n\n        \"\"\"\n        self.stop_timers()\n        with contextlib.suppress(Exception):\n            self.stop_file_watch()\n        with contextlib.suppress(Exception):\n            self._thread_pool.waitForDone()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initialize the controller.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(self, parent: Optional[QtCore.QObject] = None):\n    \"\"\"Initialize the controller.\"\"\"\n    super().__init__(parent)\n    self.manager = ProcessManager()\n    self._thread_pool = QThreadPool()\n    self._file_watcher = FileChangeWatcher(self)\n    self._file_watcher.changed.connect(self._on_file_changed)\n\n    # Timers (created once)\n    self._refresh_timer = QtCore.QTimer(self)\n    self._refresh_timer.timeout.connect(self.refresh)\n    self._refresh_timer.setInterval(5000)\n\n    self._file_reload_timer = QtCore.QTimer(self)\n    self._file_reload_timer.timeout.connect(self._on_file_reload_timeout)\n    self._file_reload_timer.setSingleShot(False)\n    self._file_reload_interval = 2000\n    self._file_reload_target: Optional[Path] = None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.clean_inactive","title":"<code>clean_inactive()</code>","text":"<p>Clean all inactive processes in background thread.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def clean_inactive(self) -&gt; None:\n    \"\"\"Clean all inactive processes in background thread.\"\"\"\n    try:\n        worker = CleanupWorker(self.manager, \"inactive\")\n        worker.signals.finished.connect(self._on_cleanup_finished)\n        worker.signals.error.connect(self._on_error)\n        self._thread_pool.start(worker)\n    except Exception as exc:  # noqa: BLE001\n        self.error.emit(str(exc))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.delete_single","title":"<code>delete_single(process_hash)</code>","text":"<p>Delete a single process by its hash in background thread.</p> <p>Parameters:</p> Name Type Description Default <code>process_hash</code> <code>str</code> <p>Hash of the process to delete.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def delete_single(self, process_hash: str) -&gt; None:\n    \"\"\"Delete a single process by its hash in background thread.\n\n    Args:\n        process_hash (str): Hash of the process to delete.\n\n    \"\"\"\n    try:\n        worker = CleanupWorker(self.manager, \"single\", process_hash)\n        worker.signals.finished.connect(self._on_cleanup_finished)\n        worker.signals.error.connect(self._on_error)\n        self._thread_pool.start(worker)\n    except Exception as exc:  # noqa: BLE001\n        self.error.emit(str(exc))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.fetch_descendants","title":"<code>fetch_descendants(parent_process)</code>","text":"<p>Fetch descendants of a given parent process in background thread.</p> <p>Parameters:</p> Name Type Description Default <code>parent_process</code> <code>ProcessInfo</code> <p>Parent process whose descendants to fetch.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def fetch_descendants(self, parent_process: ProcessInfo) -&gt; None:\n    \"\"\"Fetch descendants of a given parent process in background thread.\n\n    Args:\n        parent_process (ProcessInfo): Parent process whose descendants\n            to fetch.\n\n    \"\"\"\n    if not parent_process.pid or not parent_process.hash:\n        return\n    try:\n        worker = ProcessDescendantsUpdateWorker(\n            self.manager, parent_process.pid, parent_process.hash)\n        worker.signals.finished.connect(self._on_descendants_finished)\n        worker.signals.error.connect(self._on_error)\n        self._thread_pool.start(worker)\n    except Exception as exc:  # noqa: BLE001\n        self.error.emit(str(exc))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.load_file_content","title":"<code>load_file_content(file_path)</code>","text":"<p>Load file content in background thread.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Optional[Path]</code> <p>Path to the file to load.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def load_file_content(self, file_path: Optional[Path]) -&gt; None:\n    \"\"\"Load file content in background thread.\n\n    Args:\n        file_path (Optional[Path]): Path to the file to load.\n\n    \"\"\"\n    if not file_path:\n        self.file_content.emit(\"No output file available\")\n        return\n    try:\n        worker = FileContentWorker(file_path)\n        worker.signals.finished.connect(self._on_file_content_loaded)\n        worker.signals.error.connect(self._on_error)\n        self._thread_pool.start(worker)\n    except Exception as exc:  # noqa: BLE001\n        self.error.emit(str(exc))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.refresh","title":"<code>refresh()</code>","text":"<p>Refresh process data in background thread.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh process data in background thread.\"\"\"\n    try:\n        worker = ProcessRefreshWorker(self.manager)\n        worker.signals.finished.connect(self._on_refresh_finished)\n        worker.signals.error.connect(self._on_error)\n        self._thread_pool.start(worker)\n    except Exception as exc:  # noqa: BLE001\n        self.error.emit(str(exc))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown controller.</p> <p>Stop timers and wait for workers.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown controller.\n\n    Stop timers and wait for workers.\n\n    \"\"\"\n    self.stop_timers()\n    with contextlib.suppress(Exception):\n        self.stop_file_watch()\n    with contextlib.suppress(Exception):\n        self._thread_pool.waitForDone()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.start_file_reload","title":"<code>start_file_reload(file_path, interval=2000)</code>","text":"<p>Start auto-reloading file content at given interval.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def start_file_reload(self, file_path: Path, interval: int = 2000) -&gt; None:\n    \"\"\"Start auto-reloading file content at given interval.\"\"\"\n    self._file_reload_target = file_path\n    self._file_reload_interval = interval\n    self._file_reload_timer.start(self._file_reload_interval)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.start_file_watch","title":"<code>start_file_watch(file_path)</code>","text":"<p>Start watching file for instant updates.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the file to watch.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def start_file_watch(self, file_path: Path) -&gt; None:\n    \"\"\"Start watching file for instant updates.\n\n    Args:\n        file_path (Path): Path to the file to watch.\n\n    \"\"\"\n    self._file_watcher.set_target(file_path)\n    # Also load immediately so UI updates without waiting for first event.\n    self.load_file_content(file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.start_timers","title":"<code>start_timers()</code>","text":"<p>Start the refresh timer if not already active.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def start_timers(self) -&gt; None:\n    \"\"\"Start the refresh timer if not already active.\"\"\"\n    if not self._refresh_timer.isActive():\n        self._refresh_timer.start()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.stop_file_reload","title":"<code>stop_file_reload()</code>","text":"<p>Stop auto-reloading file content.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def stop_file_reload(self) -&gt; None:\n    \"\"\"Stop auto-reloading file content.\"\"\"\n    self._file_reload_timer.stop()\n    self._file_reload_target = None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.stop_file_watch","title":"<code>stop_file_watch()</code>","text":"<p>Stop watching file.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def stop_file_watch(self) -&gt; None:\n    \"\"\"Stop watching file.\"\"\"\n    self._file_watcher.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorController.stop_timers","title":"<code>stop_timers()</code>","text":"<p>Stop all active timers.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def stop_timers(self) -&gt; None:\n    \"\"\"Stop all active timers.\"\"\"\n    if self._refresh_timer.isActive():\n        self._refresh_timer.stop()\n    if self._file_reload_timer.isActive():\n        self._file_reload_timer.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorWindow","title":"<code>ProcessMonitorWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Main window for the Process Monitor application.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessMonitorWindow(QtWidgets.QDialog):\n    \"\"\"Main window for the Process Monitor application.\"\"\"\n    def __init__(self, parent=None):  # noqa: ANN001\n        \"\"\"Initialize the main window.\"\"\"\n        super().__init__(parent)\n        self._log = getLogger(self.__class__.__name__)\n        self.setWindowTitle(\"AYON Process Monitor\")\n        self.setMinimumSize(1000, 600)\n\n        # Controller instance (owns manager, thread pool, timers)\n        self._controller = ProcessMonitorController(self)\n\n        # Connect controller signals to UI slots\n        # ANSI to HTML converter\n        self._ansi_converter = AnsiToHtmlConverter()\n\n        self._controller.processes_refreshed.connect(\n            self._on_processes_refreshed\n        )\n        self._controller.file_content.connect(self._on_file_content)\n        self._controller.cleanup_finished.connect(self._on_cleanup_finished)\n        self._controller.error.connect(self._on_error)\n        # New: descendants\n        self._controller.descendants_refreshed.connect(\n            self._on_descendants_refreshed\n        )\n\n        self._current_process = None\n        self._is_loading = False\n        # Track last selection to restore across refreshes (including children)\n        self._last_selected_hashes: set[str] = set()\n\n        self._setup_ui()\n\n    def _setup_ui(self) -&gt; None:\n        \"\"\"Set up the user interface.\"\"\"\n        central_widget = self\n        main_layout = QtWidgets.QVBoxLayout(central_widget)\n\n        # Toolbar\n        toolbar_layout = self._setup_toolbar_ui()\n\n        main_layout.addLayout(toolbar_layout)\n\n        splitter = QtWidgets.QSplitter(QtCore.Qt.Orientation.Vertical)\n\n        # Process tree view\n        self._setup_tree_view_ui()\n\n        splitter.addWidget(self._tree_view)\n\n        # Output area\n        self._setup_output_ui()\n\n        splitter.addWidget(self._output_widget)\n\n        # Give the tree view slightly more space than the output pane\n        splitter.setStretchFactor(0, 3)\n        splitter.setStretchFactor(1, 2)\n\n        main_layout.addWidget(splitter, 1)\n\n        # Status bar\n        self._status_bar = QtWidgets.QStatusBar()\n        self._status_bar.setSizeGripEnabled(False)\n        main_layout.addWidget(self._status_bar, 0)\n        self._status_bar.showMessage(\"Ready\")\n\n    def _setup_output_ui(self) -&gt; None:\n        self._output_widget = QtWidgets.QWidget()\n        output_layout = QtWidgets.QVBoxLayout(self._output_widget)\n\n        output_label = QtWidgets.QLabel(\"Output Content:\")\n        output_label.setStyleSheet(\"font-weight: bold; margin-top: 10px;\")\n\n        # Use QTextEdit instead of QPlainTextEdit for HTML support\n        self._output_text = QtWidgets.QTextEdit()\n        self._output_text.setReadOnly(True)\n        # Set monospace font for consistent output formatting\n        font = QtGui.QFont(\"Noto Sans Mono, Courier New, monospace\")\n        font.setPointSize(9)\n        self._output_text.setFont(font)\n        self._output_text.setPlaceholderText(\n            \"Double-click a process row to view its output file content...\")\n\n        # Auto-reload checkbox\n        self._auto_reload_checkbox = QtWidgets.QCheckBox(\n            \"Auto-reload output for running processes\")\n        self._auto_reload_checkbox.setChecked(True)\n        self._auto_reload_checkbox.toggled.connect(\n            self._on_auto_reload_toggled)\n\n        output_layout.addWidget(output_label, 0)\n        output_layout.addWidget(self._output_text, 1)\n        output_layout.addWidget(self._auto_reload_checkbox, 0)\n\n        # Ensure output widget expands and takes available space\n        self._output_widget.setSizePolicy(\n            QtWidgets.QSizePolicy.Policy.Expanding,\n            QtWidgets.QSizePolicy.Policy.Expanding\n        )\n        self._output_text.setSizePolicy(\n            QtWidgets.QSizePolicy.Policy.Expanding,\n            QtWidgets.QSizePolicy.Policy.Expanding\n        )\n\n    def _setup_tree_view_ui(self) -&gt; None:\n        \"\"\"Set up the process tree view UI.\"\"\"\n        self._tree_model = ProcessTreeModel(manager=self._controller.manager)\n        self._tree_view = QtWidgets.QTreeView()\n        self._tree_view.setModel(self._tree_model)\n        self._tree_view.setSelectionBehavior(\n            QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)\n        self._tree_view.setSortingEnabled(True)\n        self._tree_view.doubleClicked.connect(self._on_row_double_clicked)\n\n        header = self._tree_view.header()\n        header.setStretchLastSection(True)\n        for i in range(len(self._tree_model.headers)):\n            header.setSectionResizeMode(\n                i, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)\n\n        # Make tree view expand to fill available space\n        self._tree_view.setSizePolicy(\n            QtWidgets.QSizePolicy.Policy.Expanding,\n            QtWidgets.QSizePolicy.Policy.Expanding\n        )\n\n    def _setup_toolbar_ui(self) -&gt; QtWidgets.QHBoxLayout:\n        \"\"\"Set up the toolbar UI.\n\n        Returns:\n            QtWidgets.QHBoxLayout: The toolbar layout.\n\n        \"\"\"\n        toolbar_layout = QtWidgets.QHBoxLayout()\n\n        self._refresh_btn = QtWidgets.QPushButton(\"Refresh Process List\")\n        self._refresh_btn.clicked.connect(self._refresh_data)\n\n        self._clean_inactive_btn = QtWidgets.QPushButton(\"Clean Inactive\")\n        self._clean_inactive_btn.setToolTip(\n            \"Remove all inactive processes from database\")\n        self._clean_inactive_btn.clicked.connect(\n            self._clean_inactive_processes)\n\n        self._clean_selected_btn = QtWidgets.QPushButton(\"Delete Selected\")\n        self._clean_selected_btn.setToolTip(\n            \"Delete selected process from database and its output file\")\n        self._clean_selected_btn.clicked.connect(\n            self._delete_selected_process)\n\n        # Loading indicator\n        self._loading_label = QtWidgets.QLabel(\"Loading...\")\n        self._loading_label.setVisible(False)\n\n        toolbar_layout.addWidget(self._refresh_btn, 0)\n        toolbar_layout.addWidget(self._clean_inactive_btn, 0)\n        toolbar_layout.addWidget(self._clean_selected_btn, 0)\n        toolbar_layout.addStretch(1)\n        toolbar_layout.addWidget(self._loading_label, 0)\n        return toolbar_layout\n\n    def _set_loading_state(self, *, loading: bool) -&gt; None:\n        \"\"\"Set the loading state of the UI.\n\n        Args:\n            loading (bool): True to show loading state, False to hide.\n\n        \"\"\"\n        self._is_loading = loading\n        self._loading_label.setVisible(loading)\n\n        # Disable buttons during loading\n        buttons = [\n            self._refresh_btn,\n            self._clean_inactive_btn,\n            self._clean_selected_btn,\n        ]\n        for btn in buttons:\n            btn.setEnabled(not loading)\n\n    def _refresh_data(self) -&gt; None:\n        \"\"\"Refresh the process table data in background thread.\"\"\"\n        self._set_loading_state(loading=True)\n        self._controller.refresh()\n\n    def _on_processes_refreshed(self, processes: list[ProcessInfo]) -&gt; None:\n        selection_model = self._tree_view.selectionModel()\n        selected_hashes: set[str] = set()\n        if selection_model.hasSelection():\n            for index in selection_model.selectedRows():\n                proc = self._tree_model.get_process_at_index(index)\n                if proc and proc.hash:\n                    selected_hashes.add(proc.hash)\n        # remember for later (children restored after descendants load)\n        self._last_selected_hashes = selected_hashes\n\n        # Update the model with new processes\n        self._tree_model.update_processes(processes)\n\n        # Restore selection for any top-level rows we can now\n        indexes_to_select = self._tree_model.find_indexes_by_hashes(\n            selected_hashes)\n        for idx in indexes_to_select:\n            selection_model.select(\n                idx,\n                (\n                    QtCore.QItemSelectionModel.SelectionFlag.Select\n                    | QtCore.QItemSelectionModel.SelectionFlag.Rows\n                ),\n            )\n\n        # Fetch descendants for each process with PID\n        for proc in processes:\n            if proc.pid:\n                self._controller.fetch_descendants(proc)\n\n        self._status_bar.showMessage(f\"Loaded {len(processes)} processes\")\n        self._set_loading_state(loading=False)\n        self._log.debug(\"Process tree updated with new data\")\n\n    def _on_descendants_refreshed(\n            self,\n            parent_hash: object,\n            descendants: list[ProcessInfo]) -&gt; None:\n        \"\"\"Handle updated descendants for a parent process.\n\n        Args:\n            parent_hash (object): Hash of the parent process.\n            descendants (list[ProcessInfo]): List of descendant processes.\n\n        \"\"\"\n        parent_hash_str = str(parent_hash)\n        self._tree_model.update_descendants(parent_hash_str, descendants)\n        # Expand parent row to show its children\n        parent_index = self._tree_model.get_index_by_hash(parent_hash_str)\n        if parent_index is not None:\n            self._tree_view.setExpanded(parent_index, True)  # noqa: FBT003\n        # Try to restore child selection if needed\n        if self._last_selected_hashes:\n            sel_model = self._tree_view.selectionModel()\n            for idx in self._tree_model.find_indexes_by_hashes(\n                    self._last_selected_hashes):\n                sel_model.select(\n                    idx,\n                    (\n                        QtCore.QItemSelectionModel.SelectionFlag.Select\n                        | QtCore.QItemSelectionModel.SelectionFlag.Rows\n                    ),\n                )\n\n    def _on_error(self, error_msg: str) -&gt; None:\n        \"\"\"Handle refresh error.\n\n        Args:\n            error_msg (str): Error message to display.\n\n        \"\"\"\n        self._status_bar.showMessage(f\"Error: {error_msg}\")\n        self._set_loading_state(loading=False)\n\n    def _on_row_double_clicked(self, index: QtCore.QModelIndex) -&gt; None:\n        \"\"\"Handle double-click on a process row to load its output file.\n\n        Args:\n            index (QtCore.QModelIndex): Index of the clicked row.\n\n        \"\"\"\n        if not index.isValid() or self._is_loading:\n            return\n        process = self._tree_model.get_process_at_index(index)\n        if not process:\n            return\n        self._current_process = process\n        self._load_output_content()\n        if (\n            self._auto_reload_checkbox.isChecked()\n            and process.pid\n            and process.active\n        ):\n            self._controller.stop_file_reload()\n            self._controller.start_file_watch(process.output)\n        else:\n            self._controller.stop_file_watch()\n            self._controller.stop_file_reload()\n\n    def _load_output_content(self) -&gt; None:\n        \"\"\"Load output file content in background thread.\"\"\"\n        if not self._current_process or not self._current_process.output:\n            self._output_text.setPlainText(\"No output file available\")\n            return\n\n        self._output_text.setPlainText(\"Loading file content...\")\n\n        self._controller.load_file_content(self._current_process.output)\n\n    def _on_file_content(self, content: str) -&gt; None:\n        \"\"\"Handle file content loaded.\n\n        Args:\n            content (str): Loaded file content.\n\n        \"\"\"\n        sb = self._output_text.verticalScrollBar()\n        # Detect whether user was at bottom before reload\n        at_bottom = sb.value() == sb.maximum()\n        prev_max = sb.maximum()\n        prev_val = sb.value()\n        ratio = (prev_val / prev_max) if prev_max &gt; 0 else 1.0\n\n        if not content:\n            self._output_text.setPlainText(\"Output file is empty\")\n        else:\n            html_content = self._ansi_converter.convert(content)\n            self._output_text.setHtml(html_content)\n\n        # Restore scroll after layout pass\n        def restore_scroll() -&gt; None:\n            \"\"\"Restore the scroll position to the bottom.\n\n            If the user was at the bottom before reload, keep them at\n            the bottom. Otherwise, maintain their relative position.\n\n            This is done in a single-shot timer to ensure it runs\n            after the layout has been updated.\n\n            \"\"\"\n            if at_bottom:\n                sb.setValue(sb.maximum())\n            else:\n                sb.setValue(int(ratio * sb.maximum()))\n        QtCore.QTimer.singleShot(0, restore_scroll)\n\n    def _on_auto_reload_toggled(self, checked: bool) -&gt; None:  # noqa: FBT001\n        \"\"\"Handle auto-reload checkbox toggle.\"\"\"\n        if not checked:\n            # self._controller.stop_file_reload()\n            self._controller.stop_file_watch()\n            self._controller.stop_file_reload()\n        elif (self._current_process and\n              self._current_process.pid and\n              self._current_process.active):\n\n            self._controller.stop_file_reload()\n            self._controller.start_file_watch(self._current_process.output)\n            # self._controller.start_file_reload(\n            #     self._current_process.output, DEFAULT_RELOAD_INTERVAL)\n\n    def _clean_inactive_processes(self) -&gt; None:\n        \"\"\"Clean all inactive processes from a database.\"\"\"\n        if self._is_loading:\n            return\n\n        reply = QtWidgets.QMessageBox.question(\n            self,\n            \"Confirm Cleanup\",\n            (\n                \"This will remove all inactive processes from the database \"\n                \"and delete their output files. Continue?\"\n            ),\n            (\n                QtWidgets.QMessageBox.StandardButton.Yes\n                | QtWidgets.QMessageBox.StandardButton.No\n            ),\n            QtWidgets.QMessageBox.StandardButton.No,\n        )\n\n        if reply != QtWidgets.QMessageBox.StandardButton.Yes:\n            return\n\n        self._set_loading_state(loading=True)\n        self._status_bar.showMessage(\"Cleaning inactive processes...\")\n\n        self._controller.clean_inactive()\n\n    def _delete_selected_process(self) -&gt; None:\n        \"\"\"Delete the selected process from database and its output file.\"\"\"\n        if self._is_loading:\n            return\n        selection = self._tree_view.selectionModel()\n        if not selection.hasSelection():\n            QtWidgets.QMessageBox.information(\n                self,\n                \"No Selection\",\n                \"Please select a process to delete.\"\n            )\n            return\n        indexes = selection.selectedRows()\n        if not indexes:\n            return\n        process = self._tree_model.get_process_at_index(indexes[0])\n        if not process:\n            return\n        reply = QtWidgets.QMessageBox.question(\n            self,\n            \"Confirm Deletion\",\n            f\"Delete process '{process.name}' \"\n            f\"(PID: {process.pid}) and its output file?\",\n            QtWidgets.QMessageBox.StandardButton.Yes\n            | QtWidgets.QMessageBox.StandardButton.No,\n            QtWidgets.QMessageBox.StandardButton.No,\n        )\n\n        if reply != QtWidgets.QMessageBox.StandardButton.Yes:\n            return\n\n        self._set_loading_state(loading=True)\n        self._status_bar.showMessage(\"Deleting process...\")\n\n        # Only top-level processes exist in DB -&gt; require hash to delete\n        if process.hash:\n            self._controller.delete_single(process.hash)\n        else:\n            self._status_bar.showMessage(\n                \"Cannot delete a descendant process from DB\")\n            self._set_loading_state(loading=False)\n\n    def _on_cleanup_finished(\n            self,\n            deleted_proc: int) -&gt; None:\n        \"\"\"Handle completion of cleanup operation.\"\"\"\n        self._refresh_data()\n        self._status_bar.showMessage(\n            f\"Deleted {deleted_proc} inactive processes.\")\n\n    def showEvent(self, event: QtGui.QShowEvent) -&gt; None:  # noqa: N802\n        \"\"\"Apply stylesheet when the window is shown.\"\"\"\n        self.setStyleSheet(load_stylesheet())\n        super().showEvent(event)\n        self._controller.start_timers()\n        self._refresh_data()\n\n    def closeEvent(self, event: QtGui.QCloseEvent) -&gt; None:  # noqa: N802\n        \"\"\"Clean up timers and threads when closing.\"\"\"\n        # Delegate shutdown to controller (stops timers and waits for workers)\n        with contextlib.suppress(Exception):\n            self._controller.shutdown()\n        super().closeEvent(event)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorWindow.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initialize the main window.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(self, parent=None):  # noqa: ANN001\n    \"\"\"Initialize the main window.\"\"\"\n    super().__init__(parent)\n    self._log = getLogger(self.__class__.__name__)\n    self.setWindowTitle(\"AYON Process Monitor\")\n    self.setMinimumSize(1000, 600)\n\n    # Controller instance (owns manager, thread pool, timers)\n    self._controller = ProcessMonitorController(self)\n\n    # Connect controller signals to UI slots\n    # ANSI to HTML converter\n    self._ansi_converter = AnsiToHtmlConverter()\n\n    self._controller.processes_refreshed.connect(\n        self._on_processes_refreshed\n    )\n    self._controller.file_content.connect(self._on_file_content)\n    self._controller.cleanup_finished.connect(self._on_cleanup_finished)\n    self._controller.error.connect(self._on_error)\n    # New: descendants\n    self._controller.descendants_refreshed.connect(\n        self._on_descendants_refreshed\n    )\n\n    self._current_process = None\n    self._is_loading = False\n    # Track last selection to restore across refreshes (including children)\n    self._last_selected_hashes: set[str] = set()\n\n    self._setup_ui()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorWindow.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Clean up timers and threads when closing.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent) -&gt; None:  # noqa: N802\n    \"\"\"Clean up timers and threads when closing.\"\"\"\n    # Delegate shutdown to controller (stops timers and waits for workers)\n    with contextlib.suppress(Exception):\n        self._controller.shutdown()\n    super().closeEvent(event)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessMonitorWindow.showEvent","title":"<code>showEvent(event)</code>","text":"<p>Apply stylesheet when the window is shown.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def showEvent(self, event: QtGui.QShowEvent) -&gt; None:  # noqa: N802\n    \"\"\"Apply stylesheet when the window is shown.\"\"\"\n    self.setStyleSheet(load_stylesheet())\n    super().showEvent(event)\n    self._controller.start_timers()\n    self._refresh_data()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessRefreshWorker","title":"<code>ProcessRefreshWorker</code>","text":"<p>               Bases: <code>QRunnable</code></p> <p>Worker thread for refreshing process data from the database.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessRefreshWorker(QRunnable):\n    \"\"\"Worker thread for refreshing process data from the database.\"\"\"\n\n    def __init__(self, manager: ProcessManager):\n        \"\"\"Initialize the worker.\"\"\"\n        super().__init__()\n        self.signals = ProcessRefreshWorkerSignals()\n        self.signature = self.__class__.__name__\n        self._manager = manager\n        self._log = getLogger(self.signature)\n\n    @Slot()\n    def run(self) -&gt; None:\n        \"\"\"Refresh process data in background thread.\"\"\"\n        with CatchTime() as timer:\n            try:\n                processes = self._manager.get_all_process_info()\n                self.signals.finished.emit(processes)\n            except Exception as e:  # noqa: BLE001\n                self.signals.error.emit(str(e))\n        self._log.debug(\n            \"Refresh from db completed in %s\", timer.readout)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessRefreshWorker.__init__","title":"<code>__init__(manager)</code>","text":"<p>Initialize the worker.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(self, manager: ProcessManager):\n    \"\"\"Initialize the worker.\"\"\"\n    super().__init__()\n    self.signals = ProcessRefreshWorkerSignals()\n    self.signature = self.__class__.__name__\n    self._manager = manager\n    self._log = getLogger(self.signature)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessRefreshWorker.run","title":"<code>run()</code>","text":"<p>Refresh process data in background thread.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>@Slot()\ndef run(self) -&gt; None:\n    \"\"\"Refresh process data in background thread.\"\"\"\n    with CatchTime() as timer:\n        try:\n            processes = self._manager.get_all_process_info()\n            self.signals.finished.emit(processes)\n        except Exception as e:  # noqa: BLE001\n            self.signals.error.emit(str(e))\n    self._log.debug(\n        \"Refresh from db completed in %s\", timer.readout)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessRefreshWorkerSignals","title":"<code>ProcessRefreshWorkerSignals</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Signals for ProcessRefreshWorker.</p> <p>Signals can be defined only in classes derived from QObject.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessRefreshWorkerSignals(QtCore.QObject):\n    \"\"\"Signals for ProcessRefreshWorker.\n\n    Signals can be defined only in classes derived from QObject.\n    \"\"\"\n    finished = QtCore.Signal(list)  # Emits list of ProcessInfo\n    error = QtCore.Signal(str)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel","title":"<code>ProcessTreeModel</code>","text":"<p>               Bases: <code>QStandardItemModel</code></p> <p>Model for displaying process information.</p> <p>Each row represents a ProcessInfo. ProcessInfo objects are stored in Qt.UserRole on the first item of the row for easy retrieval.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>class ProcessTreeModel(QtGui.QStandardItemModel):\n    \"\"\"Model for displaying process information.\n\n    Each row represents a ProcessInfo. ProcessInfo objects are stored in\n    Qt.UserRole on the first item of the row for easy retrieval.\n    \"\"\"\n\n    _running_icon: QtGui.QIcon\n    _stopped_icon: QtGui.QIcon\n    _unknown_icon: QtGui.QIcon\n    _child_running_icon: QtGui.QIcon\n    ICON_SIZE = 12\n\n    def __init__(\n            self,\n            manager: ProcessManager,\n            parent: Optional[QtCore.QObject] = None,\n            ) -&gt; None:\n        \"\"\"Initialize the model.\n\n        Args:\n            manager (ProcessManager): Process manager\n            parent (Optional[QtCore.QObject]): Parent QObject.\n\n        \"\"\"\n        super().__init__(parent)\n        self._generate_icons(size=self.ICON_SIZE)\n        self._processes: list[ProcessInfo] = []\n        self._manager = manager\n        # map of top-level process hash to its first-column item\n        self._top_item_by_hash: dict[str, QtGui.QStandardItem] = {}\n        # Columns\n        self.headers = [\n            \"Name\", \"Executable\", \"PID\", \"Status\", \"Created\", \"Start Time\",\n            \"Output File\", \"Hash\"\n        ]\n        self.columns = enum.IntEnum(  # type: ignore[misc]\n            \"columns\",\n            {\n                name.replace(\" \", \"_\").upper(): i\n                for i, name in enumerate(self.headers)\n            },\n        )\n        self.setColumnCount(len(self.headers))\n        self.setHorizontalHeaderLabels(self.headers)\n\n    def _status_icon(self, process: ProcessInfo) -&gt; QtGui.QIcon:\n        \"\"\"Return a small colored circle icon representing process status.\n\n        Args:\n            process (ProcessInfo): ProcessInfo object.\n\n        Returns:\n            QtGui.QIcon: Colored circle icon.\n\n        \"\"\"\n        # If top-level process has children, prefer child-running state\n        if process.hash:\n            parent_item = self._top_item_by_hash.get(process.hash)\n            if parent_item is not None:\n                for i in range(parent_item.rowCount()):\n                    child = parent_item.child(i, self.columns.NAME)\n                    if child is None:\n                        continue\n                    cproc: Optional[ProcessInfo] = child.data(\n                        QtCore.Qt.ItemDataRole.UserRole)\n                    if cproc and cproc.pid and cproc.active:\n                        return self._child_running_icon\n\n        if process.pid:\n            return self._running_icon if process.active else self._stopped_icon\n        return self._unknown_icon\n\n    @classmethod\n    def _generate_icons(cls, size: int = 12) -&gt; None:\n        \"\"\"Generate static icons for process statuses.\n\n        Args:\n            size (int): Size of the icons in pixels.\n\n        \"\"\"\n        if not hasattr(cls, \"_running_icon\"):\n            cls._running_icon = cls._create_icon(\n                QtGui.QColor(0, 180, 0), size)  # green = running\n        if not hasattr(cls, \"_stopped_icon\"):\n            cls._stopped_icon = cls._create_icon(\n                QtGui.QColor(200, 0, 0), size)  # red = stopped\n        if not hasattr(cls, \"_unknown_icon\"):\n            cls._unknown_icon = cls._create_icon(\n                QtGui.QColor(140, 140, 140), size)  # gray = unknown\n        if not hasattr(cls, \"_child_running_icon\"):\n            # yellow = some child running\n            cls._child_running_icon = cls._create_icon(\n                QtGui.QColor(200, 180, 0), size)\n\n    @staticmethod\n    def _create_icon(color: QtGui.QColor, size: int = 12) -&gt; QtGui.QIcon:\n        \"\"\"Create a colored circle icon.\n\n        Args:\n            color (QtGui.QColor): Color of the circle.\n            size (int): Size of the icon in pixels.\n\n        Returns:\n            QtGui.QIcon: Colored circle icon.\n\n        \"\"\"\n        pix = QtGui.QPixmap(size, size)\n        pix.fill(QtCore.Qt.GlobalColor.transparent)\n        painter = QtGui.QPainter(pix)\n        painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)\n        painter.setBrush(QtGui.QBrush(color))\n        painter.setPen(QtCore.Qt.PenStyle.NoPen)\n        painter.drawEllipse(1, 1, size - 2, size - 2)\n        painter.end()\n        return QtGui.QIcon(pix)\n\n    def update_processes(self, processes: list[ProcessInfo]) -&gt; None:\n        \"\"\"Replace current content with provided processes.\n\n        Args:\n            processes (list[ProcessInfo]): List of ProcessInfo objects.\n\n        \"\"\"\n        self._processes = list(processes)\n        root_item = self.invisibleRootItem()\n        root_item.removeRows(0, root_item.rowCount())\n        self._top_item_by_hash.clear()\n\n        for process in self._processes:\n            row_items: list[QtGui.QStandardItem] = []\n            bg = self._data_background_role(process)\n            for col in range(len(self.headers)):\n                text = self._data_display_role(col, process)\n                item = QtGui.QStandardItem(\n                    str(text) if text is not None else \"\"\n                )\n                item.setEditable(False)\n                # Store ProcessInfo in UserRole on the first column item\n                if col == self.columns.NAME:\n                    item.setData(process, QtCore.Qt.ItemDataRole.UserRole)\n                    item.setIcon(self._status_icon(process))\n                    if process.hash:\n                        self._top_item_by_hash[process.hash] = item\n                # Set background color for entire row via individual items\n                if bg is not None:\n                    item.setBackground(bg)\n                row_items.append(item)\n            root_item.appendRow(row_items)\n\n    def update_descendants(\n        self, parent_hash: str, descendants: list[ProcessInfo]\n    ) -&gt; None:\n        \"\"\"Update descendant processes under a given parent process.\n\n        Args:\n            parent_hash (str): Hash of the parent process.\n            descendants (list[ProcessInfo]): List of descendant\n                ProcessInfo objects.\n\n        \"\"\"\n        parent_item = self._top_item_by_hash.get(parent_hash)\n        if parent_item is None:\n            return\n        # remove previous children\n        parent_item.removeRows(0, parent_item.rowCount())\n\n        for child_proc in descendants:\n            child_items: list[QtGui.QStandardItem] = []\n            bg = self._data_background_role(child_proc)\n            for col in range(len(self.headers)):\n                text = self._data_display_role(col, child_proc)\n                citem = QtGui.QStandardItem(\n                    str(text) if text is not None else \"\"\n                )\n                citem.setEditable(False)\n                if col == self.columns.NAME:\n                    citem.setData(child_proc, QtCore.Qt.ItemDataRole.UserRole)\n                    citem.setIcon(self._status_icon(child_proc))\n                    # Make descendant name slightly italic to hint hierarchy\n                    font = citem.font()\n                    font.setItalic(True)\n                    citem.setFont(font)\n                if bg is not None:\n                    citem.setBackground(bg)\n                child_items.append(citem)\n            parent_item.appendRow(child_items)\n\n        # After updating children, refresh parent's icon\n        # (parent ProcessInfo stored in UserRole)\n        with contextlib.suppress(Exception):\n            parent_proc: Optional[ProcessInfo] = parent_item.data(\n                QtCore.Qt.ItemDataRole.UserRole\n            )\n            if parent_proc is not None:\n                parent_item.setIcon(self._status_icon(parent_proc))\n\n    def get_process_at_row(self, row: int) -&gt; Optional[ProcessInfo]:\n        \"\"\"Get the ProcessInfo stored at the given row.\n\n        Args:\n            row (int): Row index.\n\n        Returns:\n            Optional[ProcessInfo]: ProcessInfo object or None if not found.\n\n        \"\"\"\n        item = self.item(row, self.columns.NAME)\n        return (\n            None\n            if item is None\n            else item.data(QtCore.Qt.ItemDataRole.UserRole)\n        )\n\n    def get_process_at_index(\n        self, index: QtCore.QModelIndex\n    ) -&gt; Optional[ProcessInfo]:\n        \"\"\"Get the ProcessInfo stored at the given index.\n\n        Args:\n            index (QtCore.QModelIndex): Model index.\n\n        Returns:\n            Optional[ProcessInfo]: ProcessInfo object or None if not found.\n\n        \"\"\"\n        if not index.isValid():\n            return None\n        first_col_index = index.sibling(index.row(), self.columns.NAME)\n        item = self.itemFromIndex(first_col_index)\n        return None if item is None else item.data(\n            QtCore.Qt.ItemDataRole.UserRole)\n\n    def find_indexes_by_hashes(\n        self, hashes: set[str]\n    ) -&gt; list[QtCore.QModelIndex]:\n        \"\"\"Find model indexes for processes matching given hashes.\n\n        Args:\n            hashes (set[str]): Set of process hashes to search for.\n\n        Returns:\n            list[QtCore.QModelIndex]: List of matching model indexes.\n\n        \"\"\"\n        results: list[QtCore.QModelIndex] = []\n        root = self.invisibleRootItem()\n        for r in range(root.rowCount()):\n            top_item = root.child(r, self.columns.NAME)\n            if top_item is None:\n                continue\n            proc: Optional[ProcessInfo] = top_item.data(\n                QtCore.Qt.ItemDataRole.UserRole\n            )\n            if proc and proc.hash and proc.hash in hashes:\n                results.append(self.indexFromItem(top_item))\n            # children\n            for cr in range(top_item.rowCount()):\n                child = top_item.child(cr, self.columns.NAME)\n                if child is None:\n                    continue\n                cproc: Optional[ProcessInfo] = child.data(\n                    QtCore.Qt.ItemDataRole.UserRole\n                )\n                if cproc and cproc.hash and cproc.hash in hashes:\n                    results.append(self.indexFromItem(child))\n        return results\n\n    def get_index_by_hash(self, hash_: str) -&gt; Optional[QtCore.QModelIndex]:\n        \"\"\"Get model index for process matching given hash.\n\n        Args:\n            hash_ (str): Process hash to search for.\n\n        Returns:\n            Optional[QtCore.QModelIndex]: Matching model index or None\n                if not found.\n\n        \"\"\"\n        item = self._top_item_by_hash.get(hash_)\n        return self.indexFromItem(item) if item else None\n\n    def _data_display_role(  # noqa: C901, PLR0911, PLR0912\n        self, column: int, process: ProcessInfo\n    ) -&gt; Optional[str]:\n        \"\"\"Get display text for a given column and process.\n\n        Args:\n            column (int): Column index.\n            process (ProcessInfo): ProcessInfo object.\n\n        Returns:\n            Optional[str]: Display text or None if column is invalid.\n\n        \"\"\"\n        if column == self.columns.NAME:\n            return process.name\n        if column == self.columns.EXECUTABLE:\n            return process.executable.as_posix() or \"N/A\"\n        if column == self.columns.PID:\n            return str(process.pid) if process.pid else \"N/A\"\n        if column == self.columns.STATUS:\n            if process.pid:\n                return \"Running\" if process.active else \"Stopped\"\n            return \"Unknown\"\n        if column == self.columns.CREATED:\n            if process.created_at:\n                try:\n                    # Parse the UTC timestamp from SQLite and convert\n                    # to local timezone\n                    # SQLite CURRENT_TIMESTAMP format is \"YYYY-MM-DD HH:MM:SS\"\n                    utc_dt = datetime.strptime(  # noqa: DTZ007\n                        process.created_at, \"%Y-%m-%d %H:%M:%S\"\n                    )\n                    # Assume it is UTC and convert to local timezone\n                    utc_dt = utc_dt.replace(tzinfo=timezone.utc)\n                    local_dt = utc_dt.astimezone()\n                    return local_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n                except (ValueError, AttributeError):\n                    # If parsing fails, return the original string\n                    return process.created_at\n            return \"N/A\"\n        if column == self.columns.START_TIME:\n            if process.start_time:\n                try:\n                    return datetime.fromtimestamp(\n                        process.start_time,\n                        tz=datetime.now().astimezone().tzinfo,\n                    ).strftime(\"%Y-%m-%d %H:%M:%S\")\n                except (OSError, OverflowError, ValueError):\n                    return str(process.start_time)\n            return \"N/A\"\n        if column == self.columns.OUTPUT_FILE:\n            return str(process.output) if process.output else \"N/A\"\n        if column == self.columns.HASH:\n            with contextlib.suppress(Exception):\n                return process.hash or self._manager.get_process_info_hash(\n                    process\n                )\n            return \"N/A\"\n        return None\n\n    @staticmethod\n    def _data_background_role(process: ProcessInfo) -&gt; QtGui.QColor:\n        if process.pid:\n            is_running = process.active\n            if is_running:\n                return QtGui.QColor(200, 255, 200)  # Light green\n\n            return QtGui.QColor(255, 200, 200)  # Light red\n        return QtGui.QColor(240, 240, 240)  # Light gray\n\n    def sort(  # noqa: C901\n        self,\n        column: int,\n        order: QtCore.Qt.SortOrder = QtCore.Qt.SortOrder.AscendingOrder,\n    ) -&gt; None:\n        \"\"\"Sort the model based on a column and order.\n\n        Args:\n            column (int): Column index to sort by.\n            order (QtCore.Qt.SortOrder): Sort order (Ascending or Descending).\n\n        \"\"\"\n        if not self._processes:\n            return\n        reverse = order == QtCore.Qt.SortOrder.DescendingOrder\n\n        def key_func(  # noqa: PLR0911\n            process: ProcessInfo,\n        ) -&gt; Union[str, int, float]:\n            \"\"\"Key function for sorting based on column.\n\n            Returns:\n                Union[str, int]: Value to sort by.\n\n            \"\"\"\n            if column == self.columns.NAME:\n                return process.name or \"\"\n            if column == self.columns.EXECUTABLE:\n                return (\n                    process.executable.as_posix() if process.executable else \"\"\n                )\n            if column == self.columns.PID:\n                return process.pid or 0\n            if column == self.columns.STATUS:\n                return process.active\n            if column == self.columns.CREATED:\n                return process.created_at or \"\"\n            if column == self.columns.START_TIME:\n                return process.start_time or 0\n            if column == self.columns.OUTPUT_FILE:\n                return process.output.as_posix() if process.output else \"\"\n            if column == self.columns.HASH:\n                return process.hash or \"\"\n\n            return \"\"\n\n        sorted_processes = sorted(\n            self._processes, key=key_func, reverse=reverse)\n        self.update_processes(sorted_processes)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.__init__","title":"<code>__init__(manager, parent=None)</code>","text":"<p>Initialize the model.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>ProcessManager</code> <p>Process manager</p> required <code>parent</code> <code>Optional[QObject]</code> <p>Parent QObject.</p> <code>None</code> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def __init__(\n        self,\n        manager: ProcessManager,\n        parent: Optional[QtCore.QObject] = None,\n        ) -&gt; None:\n    \"\"\"Initialize the model.\n\n    Args:\n        manager (ProcessManager): Process manager\n        parent (Optional[QtCore.QObject]): Parent QObject.\n\n    \"\"\"\n    super().__init__(parent)\n    self._generate_icons(size=self.ICON_SIZE)\n    self._processes: list[ProcessInfo] = []\n    self._manager = manager\n    # map of top-level process hash to its first-column item\n    self._top_item_by_hash: dict[str, QtGui.QStandardItem] = {}\n    # Columns\n    self.headers = [\n        \"Name\", \"Executable\", \"PID\", \"Status\", \"Created\", \"Start Time\",\n        \"Output File\", \"Hash\"\n    ]\n    self.columns = enum.IntEnum(  # type: ignore[misc]\n        \"columns\",\n        {\n            name.replace(\" \", \"_\").upper(): i\n            for i, name in enumerate(self.headers)\n        },\n    )\n    self.setColumnCount(len(self.headers))\n    self.setHorizontalHeaderLabels(self.headers)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.find_indexes_by_hashes","title":"<code>find_indexes_by_hashes(hashes)</code>","text":"<p>Find model indexes for processes matching given hashes.</p> <p>Parameters:</p> Name Type Description Default <code>hashes</code> <code>set[str]</code> <p>Set of process hashes to search for.</p> required <p>Returns:</p> Type Description <code>list[QModelIndex]</code> <p>list[QtCore.QModelIndex]: List of matching model indexes.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def find_indexes_by_hashes(\n    self, hashes: set[str]\n) -&gt; list[QtCore.QModelIndex]:\n    \"\"\"Find model indexes for processes matching given hashes.\n\n    Args:\n        hashes (set[str]): Set of process hashes to search for.\n\n    Returns:\n        list[QtCore.QModelIndex]: List of matching model indexes.\n\n    \"\"\"\n    results: list[QtCore.QModelIndex] = []\n    root = self.invisibleRootItem()\n    for r in range(root.rowCount()):\n        top_item = root.child(r, self.columns.NAME)\n        if top_item is None:\n            continue\n        proc: Optional[ProcessInfo] = top_item.data(\n            QtCore.Qt.ItemDataRole.UserRole\n        )\n        if proc and proc.hash and proc.hash in hashes:\n            results.append(self.indexFromItem(top_item))\n        # children\n        for cr in range(top_item.rowCount()):\n            child = top_item.child(cr, self.columns.NAME)\n            if child is None:\n                continue\n            cproc: Optional[ProcessInfo] = child.data(\n                QtCore.Qt.ItemDataRole.UserRole\n            )\n            if cproc and cproc.hash and cproc.hash in hashes:\n                results.append(self.indexFromItem(child))\n    return results\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.get_index_by_hash","title":"<code>get_index_by_hash(hash_)</code>","text":"<p>Get model index for process matching given hash.</p> <p>Parameters:</p> Name Type Description Default <code>hash_</code> <code>str</code> <p>Process hash to search for.</p> required <p>Returns:</p> Type Description <code>Optional[QModelIndex]</code> <p>Optional[QtCore.QModelIndex]: Matching model index or None if not found.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def get_index_by_hash(self, hash_: str) -&gt; Optional[QtCore.QModelIndex]:\n    \"\"\"Get model index for process matching given hash.\n\n    Args:\n        hash_ (str): Process hash to search for.\n\n    Returns:\n        Optional[QtCore.QModelIndex]: Matching model index or None\n            if not found.\n\n    \"\"\"\n    item = self._top_item_by_hash.get(hash_)\n    return self.indexFromItem(item) if item else None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.get_process_at_index","title":"<code>get_process_at_index(index)</code>","text":"<p>Get the ProcessInfo stored at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex</code> <p>Model index.</p> required <p>Returns:</p> Type Description <code>Optional[ProcessInfo]</code> <p>Optional[ProcessInfo]: ProcessInfo object or None if not found.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def get_process_at_index(\n    self, index: QtCore.QModelIndex\n) -&gt; Optional[ProcessInfo]:\n    \"\"\"Get the ProcessInfo stored at the given index.\n\n    Args:\n        index (QtCore.QModelIndex): Model index.\n\n    Returns:\n        Optional[ProcessInfo]: ProcessInfo object or None if not found.\n\n    \"\"\"\n    if not index.isValid():\n        return None\n    first_col_index = index.sibling(index.row(), self.columns.NAME)\n    item = self.itemFromIndex(first_col_index)\n    return None if item is None else item.data(\n        QtCore.Qt.ItemDataRole.UserRole)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.get_process_at_row","title":"<code>get_process_at_row(row)</code>","text":"<p>Get the ProcessInfo stored at the given row.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Row index.</p> required <p>Returns:</p> Type Description <code>Optional[ProcessInfo]</code> <p>Optional[ProcessInfo]: ProcessInfo object or None if not found.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def get_process_at_row(self, row: int) -&gt; Optional[ProcessInfo]:\n    \"\"\"Get the ProcessInfo stored at the given row.\n\n    Args:\n        row (int): Row index.\n\n    Returns:\n        Optional[ProcessInfo]: ProcessInfo object or None if not found.\n\n    \"\"\"\n    item = self.item(row, self.columns.NAME)\n    return (\n        None\n        if item is None\n        else item.data(QtCore.Qt.ItemDataRole.UserRole)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.sort","title":"<code>sort(column, order=QtCore.Qt.SortOrder.AscendingOrder)</code>","text":"<p>Sort the model based on a column and order.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>int</code> <p>Column index to sort by.</p> required <code>order</code> <code>SortOrder</code> <p>Sort order (Ascending or Descending).</p> <code>AscendingOrder</code> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def sort(  # noqa: C901\n    self,\n    column: int,\n    order: QtCore.Qt.SortOrder = QtCore.Qt.SortOrder.AscendingOrder,\n) -&gt; None:\n    \"\"\"Sort the model based on a column and order.\n\n    Args:\n        column (int): Column index to sort by.\n        order (QtCore.Qt.SortOrder): Sort order (Ascending or Descending).\n\n    \"\"\"\n    if not self._processes:\n        return\n    reverse = order == QtCore.Qt.SortOrder.DescendingOrder\n\n    def key_func(  # noqa: PLR0911\n        process: ProcessInfo,\n    ) -&gt; Union[str, int, float]:\n        \"\"\"Key function for sorting based on column.\n\n        Returns:\n            Union[str, int]: Value to sort by.\n\n        \"\"\"\n        if column == self.columns.NAME:\n            return process.name or \"\"\n        if column == self.columns.EXECUTABLE:\n            return (\n                process.executable.as_posix() if process.executable else \"\"\n            )\n        if column == self.columns.PID:\n            return process.pid or 0\n        if column == self.columns.STATUS:\n            return process.active\n        if column == self.columns.CREATED:\n            return process.created_at or \"\"\n        if column == self.columns.START_TIME:\n            return process.start_time or 0\n        if column == self.columns.OUTPUT_FILE:\n            return process.output.as_posix() if process.output else \"\"\n        if column == self.columns.HASH:\n            return process.hash or \"\"\n\n        return \"\"\n\n    sorted_processes = sorted(\n        self._processes, key=key_func, reverse=reverse)\n    self.update_processes(sorted_processes)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.update_descendants","title":"<code>update_descendants(parent_hash, descendants)</code>","text":"<p>Update descendant processes under a given parent process.</p> <p>Parameters:</p> Name Type Description Default <code>parent_hash</code> <code>str</code> <p>Hash of the parent process.</p> required <code>descendants</code> <code>list[ProcessInfo]</code> <p>List of descendant ProcessInfo objects.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def update_descendants(\n    self, parent_hash: str, descendants: list[ProcessInfo]\n) -&gt; None:\n    \"\"\"Update descendant processes under a given parent process.\n\n    Args:\n        parent_hash (str): Hash of the parent process.\n        descendants (list[ProcessInfo]): List of descendant\n            ProcessInfo objects.\n\n    \"\"\"\n    parent_item = self._top_item_by_hash.get(parent_hash)\n    if parent_item is None:\n        return\n    # remove previous children\n    parent_item.removeRows(0, parent_item.rowCount())\n\n    for child_proc in descendants:\n        child_items: list[QtGui.QStandardItem] = []\n        bg = self._data_background_role(child_proc)\n        for col in range(len(self.headers)):\n            text = self._data_display_role(col, child_proc)\n            citem = QtGui.QStandardItem(\n                str(text) if text is not None else \"\"\n            )\n            citem.setEditable(False)\n            if col == self.columns.NAME:\n                citem.setData(child_proc, QtCore.Qt.ItemDataRole.UserRole)\n                citem.setIcon(self._status_icon(child_proc))\n                # Make descendant name slightly italic to hint hierarchy\n                font = citem.font()\n                font.setItalic(True)\n                citem.setFont(font)\n            if bg is not None:\n                citem.setBackground(bg)\n            child_items.append(citem)\n        parent_item.appendRow(child_items)\n\n    # After updating children, refresh parent's icon\n    # (parent ProcessInfo stored in UserRole)\n    with contextlib.suppress(Exception):\n        parent_proc: Optional[ProcessInfo] = parent_item.data(\n            QtCore.Qt.ItemDataRole.UserRole\n        )\n        if parent_proc is not None:\n            parent_item.setIcon(self._status_icon(parent_proc))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.ProcessTreeModel.update_processes","title":"<code>update_processes(processes)</code>","text":"<p>Replace current content with provided processes.</p> <p>Parameters:</p> Name Type Description Default <code>processes</code> <code>list[ProcessInfo]</code> <p>List of ProcessInfo objects.</p> required Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def update_processes(self, processes: list[ProcessInfo]) -&gt; None:\n    \"\"\"Replace current content with provided processes.\n\n    Args:\n        processes (list[ProcessInfo]): List of ProcessInfo objects.\n\n    \"\"\"\n    self._processes = list(processes)\n    root_item = self.invisibleRootItem()\n    root_item.removeRows(0, root_item.rowCount())\n    self._top_item_by_hash.clear()\n\n    for process in self._processes:\n        row_items: list[QtGui.QStandardItem] = []\n        bg = self._data_background_role(process)\n        for col in range(len(self.headers)):\n            text = self._data_display_role(col, process)\n            item = QtGui.QStandardItem(\n                str(text) if text is not None else \"\"\n            )\n            item.setEditable(False)\n            # Store ProcessInfo in UserRole on the first column item\n            if col == self.columns.NAME:\n                item.setData(process, QtCore.Qt.ItemDataRole.UserRole)\n                item.setIcon(self._status_icon(process))\n                if process.hash:\n                    self._top_item_by_hash[process.hash] = item\n            # Set background color for entire row via individual items\n            if bg is not None:\n                item.setBackground(bg)\n            row_items.append(item)\n        root_item.appendRow(row_items)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/process_monitor.html#client.ayon_applications.ui.process_monitor.main","title":"<code>main()</code>","text":"<p>Helper function to debug the tool.</p> Source code in <code>client/ayon_applications/ui/process_monitor.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Helper function to debug the tool.\"\"\"\n    app = get_ayon_qt_app()\n\n    window = ProcessMonitorWindow()\n    window.show()\n\n    app.exec_()\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/index.html#server.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> Source code in <code>server/addon.py</code> <pre><code>class ApplicationsAddon(BaseServerAddon):\n    settings_model = ApplicationsAddonSettings\n    # TODO remove this attribute when attributes support is removed\n    has_attributes = True\n\n    def initialize(self):\n        EventStream.subscribe(\n            \"bundle.updated\",\n            self._on_bundle_updated,\n            all_nodes=True,\n        )\n\n    async def get_simple_actions(\n        self,\n        project_name: str | None = None,\n        variant: str = \"production\",\n    ) -&gt; list[\"SimpleActionManifest\"]:\n        return await get_action_manifests(\n            self,\n            project_name=project_name,\n            variant=variant,\n        )\n\n    async def get_dynamic_actions(\n        self,\n        context: ActionContext,\n        variant: str = \"production\",\n    ) -&gt; list[\"DynamicActionManifest\"]:\n        return await get_dynamic_action_manifests(\n            self,\n            context=context,\n            variant=variant,\n        )\n\n    async def execute_action(\n        self,\n        executor: \"ActionExecutor\",\n    ) -&gt; \"ExecuteResponseModel\":\n        \"\"\"Execute an action provided by the addon\"\"\"\n        context = executor.context\n        project_name = context.project_name\n        entity_id = context.entity_ids[0]\n\n        bundle_args = []\n        if executor.variant not in (\"production\", \"staging\"):\n            bundle_args = [\"--bundle\", executor.variant]\n\n        if executor.identifier == DEBUG_TERMINAL_ID:\n            args = [\n                \"addon\", \"applications\", \"launch-debug-terminal\",\n                \"--project\", project_name,\n                \"--task-id\", entity_id,\n            ]\n            args.extend(bundle_args)\n            return await executor.get_launcher_action_response(\n                args=args\n            )\n\n        app_name = entity_id_arg = command = None\n        skip_last_workfile = None\n        if executor.identifier.startswith(IDENTIFIER_PREFIX):\n            app_name = executor.identifier.removeprefix(IDENTIFIER_PREFIX)\n            command = \"launch-by-id\"\n            entity_id_arg = \"--task-id\"\n            config = await self.get_action_config(\n                executor.identifier,\n                executor.context,\n                executor.user,\n                executor.variant,\n            )\n            skip_last_workfile = config.get(\"skip_last_workfile\")\n\n        elif executor.identifier.startswith(IDENTIFIER_WORKFILE_PREFIX):\n            app_name = executor.identifier.removeprefix(\n                IDENTIFIER_WORKFILE_PREFIX\n            )\n            command = \"launch-by-workfile-id\"\n            entity_id_arg = \"--workfile-id\"\n\n        if not app_name:\n            return await executor.get_simple_response(\n                message=\"Failed to launch application.\"\n                \" Unknown action identifier.\",\n                success=False,\n            )\n\n        args = [\n            \"addon\", \"applications\", command,\n            \"--app\", app_name,\n            \"--project\", project_name,\n            entity_id_arg, entity_id,\n        ]\n        args.extend(bundle_args)\n        if skip_last_workfile is not None:\n            args.extend([\n                \"--use-last-workfile\", str(int(not skip_last_workfile))\n            ])\n        # 'get_launcher_response' is available since AYON 1.8.3\n        if hasattr(executor, \"get_launcher_response\"):\n            return await executor.get_launcher_response(args=args)\n        # Backwards compatibility\n        return await executor.get_launcher_action_response(args=args)\n\n    async def get_default_settings(self):\n        return self.get_settings_model()(**DEFAULT_VALUES)\n\n    async def pre_setup(self):\n        \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        old_addon = app_defs.versions.get(\"0.1.0\")\n        if old_addon is not None:\n            # Override 'create_applications_attribute' for older versions\n            #   - avoid infinite server restart loop\n            old_addon.create_applications_attribute = (\n                self.create_applications_attribute\n            )\n\n        # Update older versions of applications addon to use new\n        #   '_update_enums'\n        # - new function skips newer addon versions without 'has_attributes'\n        version_objs, _invalid_versions = parse_versions(app_defs.versions)\n        for addon_version, version_obj in version_objs:\n            # Last release with only old attribute system\n            if version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n                addon = app_defs.versions[addon_version]\n                addon._update_enums = self._update_enums\n\n    async def create_action_config_hash(\n        self,\n        identifier: str,\n        context: ActionContext,\n        user: UserEntity,\n        variant: str,\n    ) -&gt; str:\n        \"\"\"Create a hash for action config store\"\"\"\n        if not identifier.startswith(IDENTIFIER_PREFIX):\n            return await super().create_action_config_hash(\n                identifier, context, user, variant\n            )\n\n        # Change identifier to only app name and one task id\n        identifier = identifier.removeprefix(IDENTIFIER_PREFIX)\n        hash_content = [\n            user.name,\n            identifier,\n            context.project_name,\n            context.entity_ids[0],\n        ]\n        logger.trace(f\"Creating config hash from {hash_content}\")\n        return hash_data(hash_content)\n\n    async def set_action_config(\n        self,\n        identifier: str,\n        context: ActionContext,\n        user: UserEntity,\n        variant: str,\n        config: dict[str, Any],\n    ) -&gt; None:\n        if not identifier.startswith(IDENTIFIER_PREFIX):\n            await super().set_action_config(\n                identifier, context, user, variant, config\n            )\n            return\n\n        if not context.entity_ids:\n            return\n\n        # Unset 'skip_last_workfile' if it is set to 'False'\n        if config.get(\"skip_last_workfile\") is False:\n            config.pop(\"skip_last_workfile\")\n\n        identifier = identifier.removeprefix(IDENTIFIER_PREFIX)\n        for entity_id in context.entity_ids:\n            config_hash = hash_data([\n                user.name,\n                identifier,\n                context.project_name,\n                entity_id,\n            ])\n            await set_action_config(\n                config_hash,\n                config,\n                addon_name=self.name,\n                addon_version=self.version,\n                identifier=identifier,\n                project_name=context.project_name,\n                user_name=user.name,\n            )\n\n    async def convert_settings_overrides(\n        self,\n        source_version: str,\n        overrides: dict[str, Any],\n    ) -&gt; dict[str, Any]:\n        overrides = await super().convert_settings_overrides(\n            source_version, overrides\n        )\n        # Since 1.0.0 the project applications and tools are\n        #   using settings instead of attributes.\n        # Disable automatically project applications and tools\n        #   when converting settings of version &lt; 1.0.0 so we don't break\n        #   productions on update\n        if parse_version(source_version) &lt; (1, 0, 0):\n            prj_apps = overrides.setdefault(\"project_applications\", {})\n            prj_apps[\"enabled\"] = False\n            prj_tools = overrides.setdefault(\"project_tools\", {})\n            prj_tools[\"enabled\"] = False\n        return overrides\n\n    # --------------------------------------\n    # Backwards compatibility for attributes\n    # --------------------------------------\n    def _sort_versions(self, addon_versions, reverse=False):\n        version_objs, invalid_versions = parse_versions(addon_versions)\n\n        valid_versions = [\n            addon_version\n            for addon_version, version_obj in (\n                sorted(version_objs, key=lambda x: x[1])\n            )\n        ]\n        sorted_versions = list(sorted(invalid_versions)) + valid_versions\n        if reverse:\n            sorted_versions = reversed(sorted_versions)\n        for addon_version in sorted_versions:\n            yield addon_version\n\n    def _merge_groups(self, output, new_groups):\n        groups_by_name = {\n            o_group[\"name\"]: o_group\n            for o_group in output\n        }\n        extend_groups = []\n        for new_group in new_groups:\n            group_name = new_group[\"name\"]\n            if group_name not in groups_by_name:\n                extend_groups.append(new_group)\n                continue\n            existing_group = groups_by_name[group_name]\n            existing_variants = existing_group[\"variants\"]\n            existing_variants_by_name = {\n                variant[\"name\"]: variant\n                for variant in existing_variants\n            }\n            for new_variant in new_group[\"variants\"]:\n                if new_variant[\"name\"] not in existing_variants_by_name:\n                    existing_variants.append(new_variant)\n\n        output.extend(extend_groups)\n\n    def _get_enum_items_from_groups(self, groups):\n        label_by_name = {}\n        for group in groups:\n            group_name = group[\"name\"]\n            group_label = group.get(\n                \"label\", LABELS_BY_GROUP_NAME.get(group_name)\n            ) or group_name\n            for variant in group[\"variants\"]:\n                variant_name = variant[\"name\"]\n                if not variant_name:\n                    continue\n                variant_label = variant[\"label\"] or variant_name\n                full_name = f\"{group_name}/{variant_name}\"\n                full_label = f\"{group_label} {variant_label}\"\n                label_by_name[full_name] = full_label\n\n        return [\n            {\"value\": full_name, \"label\": label_by_name[full_name]}\n            for full_name in sorted(label_by_name)\n        ]\n\n    def _addon_has_attributes(self, addon, addon_version):\n        version_obj = parse_version(addon_version)\n        if version_obj is None or version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            return True\n\n        return getattr(addon, \"has_attributes\", False)\n\n    async def _update_enums(self):\n        \"\"\"Updates applications and tools enums based on the addon settings.\n        This method is called when the addon is started (after we are sure\n        that the 'applications' and 'tools' attributes exist) and when\n        the addon settings are updated (using on_settings_updated method).\n        \"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        all_applications = []\n        all_tools = []\n        for addon_version in self._sort_versions(\n            app_defs.versions.keys(), reverse=True\n        ):\n            addon = app_defs.versions[addon_version]\n            if not self._addon_has_attributes(addon, addon_version):\n                continue\n\n            for variant in (\"production\", \"staging\"):\n                settings_model = await addon.get_studio_settings(variant)\n                studio_settings = settings_model.dict()\n                application_settings = studio_settings[\"applications\"]\n                app_groups = application_settings.pop(\"additional_apps\")\n                for group_name, value in application_settings.items():\n                    value[\"name\"] = group_name\n                    app_groups.append(value)\n                self._merge_groups(all_applications, app_groups)\n                self._merge_groups(all_tools, studio_settings[\"tool_groups\"])\n\n        apps_attrib_name = \"applications\"\n        tools_attrib_name = \"tools\"\n\n        apps_enum = self._get_enum_items_from_groups(all_applications)\n        tools_enum = self._get_enum_items_from_groups(all_tools)\n\n        apps_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Applications\",\n            \"enum\": apps_enum,\n        }\n        tools_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Tools\",\n            \"enum\": tools_enum,\n        }\n\n        apps_scope = [\"project\"]\n        tools_scope = [\"project\", \"folder\", \"task\"]\n\n        apps_matches = False\n        tools_matches = False\n\n        async for row in Postgres.iterate(\n            \"SELECT name, position, scope, data from public.attributes\"\n        ):\n            if row[\"name\"] == apps_attrib_name:\n                # Check if scope is matching ftrack addon requirements\n                if (\n                    set(row[\"scope\"]) == set(apps_scope)\n                    and row[\"data\"].get(\"enum\") == apps_enum\n                ):\n                    apps_matches = True\n\n            elif row[\"name\"] == tools_attrib_name:\n                if (\n                    set(row[\"scope\"]) == set(tools_scope)\n                    and row[\"data\"].get(\"enum\") == tools_enum\n                ):\n                    tools_matches = True\n\n        if apps_matches and tools_matches:\n            return\n\n        if not apps_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                apps_scope,\n                apps_attribute_data,\n                apps_attrib_name,\n            )\n\n        if not tools_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                tools_scope,\n                tools_attribute_data,\n                tools_attrib_name,\n            )\n\n        # Reset attributes cache on server\n        await attribute_library.load()\n\n    # --------------------------------------------\n    # Auto-fill of host_name in workfiles entities\n    # --------------------------------------------\n    async def _workfile_entities_auto_filled(self) -&gt; bool:\n        async for _ in Postgres.iterate(\n            \"SELECT * FROM public.addon_data\"\n            \" WHERE addon_name = $1 AND key = $2\",\n            self.name,\n            \"workfile_entities_host_name_filled\",\n        ):\n            return True\n        return False\n\n    async def _on_bundle_updated(\n        self, event: EventModel, *args, **kwargs\n    ) -&gt; None:\n        if await self._workfile_entities_auto_filled():\n            return\n\n        if not event.summary.get(\"isProduction\"):\n            return\n\n        addons = event.payload.get(\"addons\", {})\n        addon_version = addons.get(self.name)\n        if addon_version != self.version:\n            return\n\n        await self._autofill_workfile_entities()\n\n    async def _autofill_workfile_entities(self):\n        project_names = [\n            project.name\n            for project in await get_project_list()\n        ]\n        for project_name in project_names:\n            query = f\"\"\"\n                SELECT id, attrib, path FROM project_{project_name}.workfiles\n                WHERE data-&gt;'host_name' IS NULL;\n            \"\"\"\n            workfile_entities = [\n                row\n                async for row in Postgres.iterate(query)\n            ]\n            changes = []\n            for workfile_entity in workfile_entities:\n                ext = workfile_entity[\"attrib\"].get(\"extension\")\n                if not ext:\n                    ext = os.path.splitext(workfile_entity[\"path\"])[-1]\n                if not ext:\n                    continue\n                mapped_host_name = EXT_TO_HOST_MAPPING.get(ext.lower())\n                if mapped_host_name:\n                    changes.append((workfile_entity[\"id\"], mapped_host_name))\n\n            for chunk in create_chunks(changes):\n                async with Postgres.transaction():\n                    for (workfile_id, host_name) in chunk:\n                        await Postgres.execute(\n                            f\"UPDATE project_{project_name}.workfiles\"\n                            \" SET data = jsonb_set(data, '{host_name}', $1)\"\n                            \" WHERE id = $2;\",\n                            host_name,\n                            workfile_id\n                        )\n\n        await Postgres.execute(\n            \"INSERT INTO public.addon_data\"\n            \" (addon_name, addon_version, key, data)\"\n            \" VALUES ($1, $2, $3, $4)\",\n            self.name,\n            self.version,\n            \"workfile_entities_host_name_filled\",\n            {\n                \"project_names\": project_names,\n            }\n        )\n</code></pre>"},{"location":"autoapi/server/index.html#server.ApplicationsAddon.create_action_config_hash","title":"<code>create_action_config_hash(identifier, context, user, variant)</code>  <code>async</code>","text":"<p>Create a hash for action config store</p> Source code in <code>server/addon.py</code> <pre><code>async def create_action_config_hash(\n    self,\n    identifier: str,\n    context: ActionContext,\n    user: UserEntity,\n    variant: str,\n) -&gt; str:\n    \"\"\"Create a hash for action config store\"\"\"\n    if not identifier.startswith(IDENTIFIER_PREFIX):\n        return await super().create_action_config_hash(\n            identifier, context, user, variant\n        )\n\n    # Change identifier to only app name and one task id\n    identifier = identifier.removeprefix(IDENTIFIER_PREFIX)\n    hash_content = [\n        user.name,\n        identifier,\n        context.project_name,\n        context.entity_ids[0],\n    ]\n    logger.trace(f\"Creating config hash from {hash_content}\")\n    return hash_data(hash_content)\n</code></pre>"},{"location":"autoapi/server/index.html#server.ApplicationsAddon.execute_action","title":"<code>execute_action(executor)</code>  <code>async</code>","text":"<p>Execute an action provided by the addon</p> Source code in <code>server/addon.py</code> <pre><code>async def execute_action(\n    self,\n    executor: \"ActionExecutor\",\n) -&gt; \"ExecuteResponseModel\":\n    \"\"\"Execute an action provided by the addon\"\"\"\n    context = executor.context\n    project_name = context.project_name\n    entity_id = context.entity_ids[0]\n\n    bundle_args = []\n    if executor.variant not in (\"production\", \"staging\"):\n        bundle_args = [\"--bundle\", executor.variant]\n\n    if executor.identifier == DEBUG_TERMINAL_ID:\n        args = [\n            \"addon\", \"applications\", \"launch-debug-terminal\",\n            \"--project\", project_name,\n            \"--task-id\", entity_id,\n        ]\n        args.extend(bundle_args)\n        return await executor.get_launcher_action_response(\n            args=args\n        )\n\n    app_name = entity_id_arg = command = None\n    skip_last_workfile = None\n    if executor.identifier.startswith(IDENTIFIER_PREFIX):\n        app_name = executor.identifier.removeprefix(IDENTIFIER_PREFIX)\n        command = \"launch-by-id\"\n        entity_id_arg = \"--task-id\"\n        config = await self.get_action_config(\n            executor.identifier,\n            executor.context,\n            executor.user,\n            executor.variant,\n        )\n        skip_last_workfile = config.get(\"skip_last_workfile\")\n\n    elif executor.identifier.startswith(IDENTIFIER_WORKFILE_PREFIX):\n        app_name = executor.identifier.removeprefix(\n            IDENTIFIER_WORKFILE_PREFIX\n        )\n        command = \"launch-by-workfile-id\"\n        entity_id_arg = \"--workfile-id\"\n\n    if not app_name:\n        return await executor.get_simple_response(\n            message=\"Failed to launch application.\"\n            \" Unknown action identifier.\",\n            success=False,\n        )\n\n    args = [\n        \"addon\", \"applications\", command,\n        \"--app\", app_name,\n        \"--project\", project_name,\n        entity_id_arg, entity_id,\n    ]\n    args.extend(bundle_args)\n    if skip_last_workfile is not None:\n        args.extend([\n            \"--use-last-workfile\", str(int(not skip_last_workfile))\n        ])\n    # 'get_launcher_response' is available since AYON 1.8.3\n    if hasattr(executor, \"get_launcher_response\"):\n        return await executor.get_launcher_response(args=args)\n    # Backwards compatibility\n    return await executor.get_launcher_action_response(args=args)\n</code></pre>"},{"location":"autoapi/server/index.html#server.ApplicationsAddon.pre_setup","title":"<code>pre_setup()</code>  <code>async</code>","text":"<p>Make sure older version of addon use the new way of attributes.</p> Source code in <code>server/addon.py</code> <pre><code>async def pre_setup(self):\n    \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n    instance = AddonLibrary.getinstance()\n    app_defs = instance.data.get(self.name)\n    old_addon = app_defs.versions.get(\"0.1.0\")\n    if old_addon is not None:\n        # Override 'create_applications_attribute' for older versions\n        #   - avoid infinite server restart loop\n        old_addon.create_applications_attribute = (\n            self.create_applications_attribute\n        )\n\n    # Update older versions of applications addon to use new\n    #   '_update_enums'\n    # - new function skips newer addon versions without 'has_attributes'\n    version_objs, _invalid_versions = parse_versions(app_defs.versions)\n    for addon_version, version_obj in version_objs:\n        # Last release with only old attribute system\n        if version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            addon = app_defs.versions[addon_version]\n            addon._update_enums = self._update_enums\n</code></pre>"},{"location":"autoapi/server/_backwards.html","title":"_backwards","text":"<p>Backwards compatibility for applications addon.</p> <p>This should have been backwards compatibility fix for older addons using attributes for applications and tools. But the first release of addon that allows to disable kept the attributes in play and the fix was not needed.</p> <p>This is preparation for following release of applications addon that will completely remove the attributes and use only settings.</p> <p>TODO (Added 2024/08/05). Use this code when attributes are removed from the addon, or remove the file in future if plans changed.</p>"},{"location":"autoapi/server/_backwards.html#server._backwards.ApplicationsLE_0_2","title":"<code>ApplicationsLE_0_2</code>","text":"Source code in <code>server/_backwards.py</code> <pre><code>class ApplicationsLE_0_2:\n    def __init__(self, addon_obj):\n        self._addon_obj = addon_obj\n\n    def _sort_versions(self, addon_versions, reverse=False):\n        version_objs, invalid_versions = parse_versions(addon_versions)\n\n        valid_versions = [\n            addon_version\n            for addon_version, version_obj in (\n                sorted(version_objs, key=lambda x: x[1])\n            )\n            # Skip versions greater than 0.2\n            if (version_obj.major, version_obj.minor) &lt;= (0, 2)\n        ]\n        sorted_versions = list(sorted(invalid_versions)) + valid_versions\n        if reverse:\n            sorted_versions = reversed(sorted_versions)\n        for addon_version in sorted_versions:\n            yield addon_version\n\n    def _merge_groups(self, output, new_groups):\n        groups_by_name = {\n            o_group[\"name\"]: o_group\n            for o_group in output\n        }\n        extend_groups = []\n        for new_group in new_groups:\n            group_name = new_group[\"name\"]\n            if group_name not in groups_by_name:\n                extend_groups.append(new_group)\n                continue\n            existing_group = groups_by_name[group_name]\n            existing_variants = existing_group[\"variants\"]\n            existing_variants_by_name = {\n                variant[\"name\"]: variant\n                for variant in existing_variants\n            }\n            for new_variant in new_group[\"variants\"]:\n                if new_variant[\"name\"] not in existing_variants_by_name:\n                    existing_variants.append(new_variant)\n\n        output.extend(extend_groups)\n\n    def _get_enum_items_from_groups(self, groups):\n        label_by_name = {}\n        for group in groups:\n            group_name = group[\"name\"]\n            group_label = group[\"label\"] or group_name\n            for variant in group[\"variants\"]:\n                variant_name = variant[\"name\"]\n                if not variant_name:\n                    continue\n                variant_label = variant[\"label\"] or variant_name\n                full_name = f\"{group_name}/{variant_name}\"\n                full_label = f\"{group_label} {variant_label}\"\n                label_by_name[full_name] = full_label\n\n        return [\n            {\"value\": full_name, \"label\": label_by_name[full_name]}\n            for full_name in sorted(label_by_name)\n        ]\n\n    def _addon_has_attributes(self, addon, addon_version):\n        version_obj = parse_version(addon_version)\n        if version_obj is None or version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            return True\n        return getattr(addon, \"has_attributes\", False)\n\n    async def _update_enums(self):\n        \"\"\"Updates applications and tools enums based on the addon settings.\n        This method is called when the addon is started (after we are sure\n        that the 'applications' and 'tools' attributes exist) and when\n        the addon settings are updated (using on_settings_updated method).\n        \"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self._addon_obj.name)\n        all_applications = []\n        all_tools = []\n        for addon_version in self._sort_versions(\n            app_defs.versions.keys(), reverse=True\n        ):\n            addon = app_defs.versions[addon_version]\n            if not self._addon_has_attributes(addon):\n                continue\n\n            for variant in (\"production\", \"staging\"):\n                settings_model = await addon.get_studio_settings(variant)\n                studio_settings = settings_model.dict()\n                application_settings = studio_settings[\"applications\"]\n                app_groups = application_settings.pop(\"additional_apps\")\n                for group_name, value in application_settings.items():\n                    value[\"name\"] = group_name\n                    app_groups.append(value)\n                self._merge_groups(all_applications, app_groups)\n                self._merge_groups(all_tools, studio_settings[\"tool_groups\"])\n\n        apps_attrib_name = \"applications\"\n        tools_attrib_name = \"tools\"\n\n        apps_enum = self._get_enum_items_from_groups(all_applications)\n        tools_enum = self._get_enum_items_from_groups(all_tools)\n\n        apps_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Applications\",\n            \"enum\": apps_enum,\n        }\n        tools_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Tools\",\n            \"enum\": tools_enum,\n        }\n\n        apps_scope = [\"project\"]\n        tools_scope = [\"project\", \"folder\", \"task\"]\n\n        apps_matches = False\n        tools_matches = False\n\n        async for row in Postgres.iterate(\n            \"SELECT name, position, scope, data from public.attributes\"\n        ):\n            if row[\"name\"] == apps_attrib_name:\n                # Check if scope is matching ftrack addon requirements\n                if (\n                    set(row[\"scope\"]) == set(apps_scope)\n                    and row[\"data\"].get(\"enum\") == apps_enum\n                ):\n                    apps_matches = True\n\n            elif row[\"name\"] == tools_attrib_name:\n                if (\n                    set(row[\"scope\"]) == set(tools_scope)\n                    and row[\"data\"].get(\"enum\") == tools_enum\n                ):\n                    tools_matches = True\n\n        if apps_matches and tools_matches:\n            return\n\n        if not apps_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                apps_scope,\n                apps_attribute_data,\n                apps_attrib_name,\n            )\n\n        if not tools_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                tools_scope,\n                tools_attribute_data,\n                tools_attrib_name,\n            )\n\n        # Reset attributes cache on server\n        await attribute_library.load()\n</code></pre>"},{"location":"autoapi/server/actions.html","title":"actions","text":""},{"location":"autoapi/server/addon.html","title":"addon","text":"<p>Server side of the Applications addon.</p> <p>This module contains the server side of the Applications addon. It is responsible for managing settings and initial setup of addon.</p>"},{"location":"autoapi/server/addon.html#server.addon--attributes-backward-compatibility","title":"Attributes backward compatibility","text":"<p>Current and previous versions of applications addon did use AYON attributes to define applications and tools for a project and task.</p> <p>This system was replaced with a new system using settings. This change is not 100% backwards compatible, we need to make sure that older versions of the addon don't break initialization.</p> <p>Older versions of the addon used settings of other versions, but the settings structure did change which can cause that combination of old and new Applications addon on server can cause crashes.</p> <p>First version introduction settings does support both settings and attributes so the handling of older versions is part of the addon, but following versions have to find some clever way how to avoid the issues.</p> <p>Version stored under 'ATTRIBUTES_VERSION_MILESTONE' should be last released version that used only old attribute system.</p>"},{"location":"autoapi/server/addon.html#server.addon.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> Source code in <code>server/addon.py</code> <pre><code>class ApplicationsAddon(BaseServerAddon):\n    settings_model = ApplicationsAddonSettings\n    # TODO remove this attribute when attributes support is removed\n    has_attributes = True\n\n    def initialize(self):\n        EventStream.subscribe(\n            \"bundle.updated\",\n            self._on_bundle_updated,\n            all_nodes=True,\n        )\n\n    async def get_simple_actions(\n        self,\n        project_name: str | None = None,\n        variant: str = \"production\",\n    ) -&gt; list[\"SimpleActionManifest\"]:\n        return await get_action_manifests(\n            self,\n            project_name=project_name,\n            variant=variant,\n        )\n\n    async def get_dynamic_actions(\n        self,\n        context: ActionContext,\n        variant: str = \"production\",\n    ) -&gt; list[\"DynamicActionManifest\"]:\n        return await get_dynamic_action_manifests(\n            self,\n            context=context,\n            variant=variant,\n        )\n\n    async def execute_action(\n        self,\n        executor: \"ActionExecutor\",\n    ) -&gt; \"ExecuteResponseModel\":\n        \"\"\"Execute an action provided by the addon\"\"\"\n        context = executor.context\n        project_name = context.project_name\n        entity_id = context.entity_ids[0]\n\n        bundle_args = []\n        if executor.variant not in (\"production\", \"staging\"):\n            bundle_args = [\"--bundle\", executor.variant]\n\n        if executor.identifier == DEBUG_TERMINAL_ID:\n            args = [\n                \"addon\", \"applications\", \"launch-debug-terminal\",\n                \"--project\", project_name,\n                \"--task-id\", entity_id,\n            ]\n            args.extend(bundle_args)\n            return await executor.get_launcher_action_response(\n                args=args\n            )\n\n        app_name = entity_id_arg = command = None\n        skip_last_workfile = None\n        if executor.identifier.startswith(IDENTIFIER_PREFIX):\n            app_name = executor.identifier.removeprefix(IDENTIFIER_PREFIX)\n            command = \"launch-by-id\"\n            entity_id_arg = \"--task-id\"\n            config = await self.get_action_config(\n                executor.identifier,\n                executor.context,\n                executor.user,\n                executor.variant,\n            )\n            skip_last_workfile = config.get(\"skip_last_workfile\")\n\n        elif executor.identifier.startswith(IDENTIFIER_WORKFILE_PREFIX):\n            app_name = executor.identifier.removeprefix(\n                IDENTIFIER_WORKFILE_PREFIX\n            )\n            command = \"launch-by-workfile-id\"\n            entity_id_arg = \"--workfile-id\"\n\n        if not app_name:\n            return await executor.get_simple_response(\n                message=\"Failed to launch application.\"\n                \" Unknown action identifier.\",\n                success=False,\n            )\n\n        args = [\n            \"addon\", \"applications\", command,\n            \"--app\", app_name,\n            \"--project\", project_name,\n            entity_id_arg, entity_id,\n        ]\n        args.extend(bundle_args)\n        if skip_last_workfile is not None:\n            args.extend([\n                \"--use-last-workfile\", str(int(not skip_last_workfile))\n            ])\n        # 'get_launcher_response' is available since AYON 1.8.3\n        if hasattr(executor, \"get_launcher_response\"):\n            return await executor.get_launcher_response(args=args)\n        # Backwards compatibility\n        return await executor.get_launcher_action_response(args=args)\n\n    async def get_default_settings(self):\n        return self.get_settings_model()(**DEFAULT_VALUES)\n\n    async def pre_setup(self):\n        \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        old_addon = app_defs.versions.get(\"0.1.0\")\n        if old_addon is not None:\n            # Override 'create_applications_attribute' for older versions\n            #   - avoid infinite server restart loop\n            old_addon.create_applications_attribute = (\n                self.create_applications_attribute\n            )\n\n        # Update older versions of applications addon to use new\n        #   '_update_enums'\n        # - new function skips newer addon versions without 'has_attributes'\n        version_objs, _invalid_versions = parse_versions(app_defs.versions)\n        for addon_version, version_obj in version_objs:\n            # Last release with only old attribute system\n            if version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n                addon = app_defs.versions[addon_version]\n                addon._update_enums = self._update_enums\n\n    async def create_action_config_hash(\n        self,\n        identifier: str,\n        context: ActionContext,\n        user: UserEntity,\n        variant: str,\n    ) -&gt; str:\n        \"\"\"Create a hash for action config store\"\"\"\n        if not identifier.startswith(IDENTIFIER_PREFIX):\n            return await super().create_action_config_hash(\n                identifier, context, user, variant\n            )\n\n        # Change identifier to only app name and one task id\n        identifier = identifier.removeprefix(IDENTIFIER_PREFIX)\n        hash_content = [\n            user.name,\n            identifier,\n            context.project_name,\n            context.entity_ids[0],\n        ]\n        logger.trace(f\"Creating config hash from {hash_content}\")\n        return hash_data(hash_content)\n\n    async def set_action_config(\n        self,\n        identifier: str,\n        context: ActionContext,\n        user: UserEntity,\n        variant: str,\n        config: dict[str, Any],\n    ) -&gt; None:\n        if not identifier.startswith(IDENTIFIER_PREFIX):\n            await super().set_action_config(\n                identifier, context, user, variant, config\n            )\n            return\n\n        if not context.entity_ids:\n            return\n\n        # Unset 'skip_last_workfile' if it is set to 'False'\n        if config.get(\"skip_last_workfile\") is False:\n            config.pop(\"skip_last_workfile\")\n\n        identifier = identifier.removeprefix(IDENTIFIER_PREFIX)\n        for entity_id in context.entity_ids:\n            config_hash = hash_data([\n                user.name,\n                identifier,\n                context.project_name,\n                entity_id,\n            ])\n            await set_action_config(\n                config_hash,\n                config,\n                addon_name=self.name,\n                addon_version=self.version,\n                identifier=identifier,\n                project_name=context.project_name,\n                user_name=user.name,\n            )\n\n    async def convert_settings_overrides(\n        self,\n        source_version: str,\n        overrides: dict[str, Any],\n    ) -&gt; dict[str, Any]:\n        overrides = await super().convert_settings_overrides(\n            source_version, overrides\n        )\n        # Since 1.0.0 the project applications and tools are\n        #   using settings instead of attributes.\n        # Disable automatically project applications and tools\n        #   when converting settings of version &lt; 1.0.0 so we don't break\n        #   productions on update\n        if parse_version(source_version) &lt; (1, 0, 0):\n            prj_apps = overrides.setdefault(\"project_applications\", {})\n            prj_apps[\"enabled\"] = False\n            prj_tools = overrides.setdefault(\"project_tools\", {})\n            prj_tools[\"enabled\"] = False\n        return overrides\n\n    # --------------------------------------\n    # Backwards compatibility for attributes\n    # --------------------------------------\n    def _sort_versions(self, addon_versions, reverse=False):\n        version_objs, invalid_versions = parse_versions(addon_versions)\n\n        valid_versions = [\n            addon_version\n            for addon_version, version_obj in (\n                sorted(version_objs, key=lambda x: x[1])\n            )\n        ]\n        sorted_versions = list(sorted(invalid_versions)) + valid_versions\n        if reverse:\n            sorted_versions = reversed(sorted_versions)\n        for addon_version in sorted_versions:\n            yield addon_version\n\n    def _merge_groups(self, output, new_groups):\n        groups_by_name = {\n            o_group[\"name\"]: o_group\n            for o_group in output\n        }\n        extend_groups = []\n        for new_group in new_groups:\n            group_name = new_group[\"name\"]\n            if group_name not in groups_by_name:\n                extend_groups.append(new_group)\n                continue\n            existing_group = groups_by_name[group_name]\n            existing_variants = existing_group[\"variants\"]\n            existing_variants_by_name = {\n                variant[\"name\"]: variant\n                for variant in existing_variants\n            }\n            for new_variant in new_group[\"variants\"]:\n                if new_variant[\"name\"] not in existing_variants_by_name:\n                    existing_variants.append(new_variant)\n\n        output.extend(extend_groups)\n\n    def _get_enum_items_from_groups(self, groups):\n        label_by_name = {}\n        for group in groups:\n            group_name = group[\"name\"]\n            group_label = group.get(\n                \"label\", LABELS_BY_GROUP_NAME.get(group_name)\n            ) or group_name\n            for variant in group[\"variants\"]:\n                variant_name = variant[\"name\"]\n                if not variant_name:\n                    continue\n                variant_label = variant[\"label\"] or variant_name\n                full_name = f\"{group_name}/{variant_name}\"\n                full_label = f\"{group_label} {variant_label}\"\n                label_by_name[full_name] = full_label\n\n        return [\n            {\"value\": full_name, \"label\": label_by_name[full_name]}\n            for full_name in sorted(label_by_name)\n        ]\n\n    def _addon_has_attributes(self, addon, addon_version):\n        version_obj = parse_version(addon_version)\n        if version_obj is None or version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            return True\n\n        return getattr(addon, \"has_attributes\", False)\n\n    async def _update_enums(self):\n        \"\"\"Updates applications and tools enums based on the addon settings.\n        This method is called when the addon is started (after we are sure\n        that the 'applications' and 'tools' attributes exist) and when\n        the addon settings are updated (using on_settings_updated method).\n        \"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        all_applications = []\n        all_tools = []\n        for addon_version in self._sort_versions(\n            app_defs.versions.keys(), reverse=True\n        ):\n            addon = app_defs.versions[addon_version]\n            if not self._addon_has_attributes(addon, addon_version):\n                continue\n\n            for variant in (\"production\", \"staging\"):\n                settings_model = await addon.get_studio_settings(variant)\n                studio_settings = settings_model.dict()\n                application_settings = studio_settings[\"applications\"]\n                app_groups = application_settings.pop(\"additional_apps\")\n                for group_name, value in application_settings.items():\n                    value[\"name\"] = group_name\n                    app_groups.append(value)\n                self._merge_groups(all_applications, app_groups)\n                self._merge_groups(all_tools, studio_settings[\"tool_groups\"])\n\n        apps_attrib_name = \"applications\"\n        tools_attrib_name = \"tools\"\n\n        apps_enum = self._get_enum_items_from_groups(all_applications)\n        tools_enum = self._get_enum_items_from_groups(all_tools)\n\n        apps_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Applications\",\n            \"enum\": apps_enum,\n        }\n        tools_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Tools\",\n            \"enum\": tools_enum,\n        }\n\n        apps_scope = [\"project\"]\n        tools_scope = [\"project\", \"folder\", \"task\"]\n\n        apps_matches = False\n        tools_matches = False\n\n        async for row in Postgres.iterate(\n            \"SELECT name, position, scope, data from public.attributes\"\n        ):\n            if row[\"name\"] == apps_attrib_name:\n                # Check if scope is matching ftrack addon requirements\n                if (\n                    set(row[\"scope\"]) == set(apps_scope)\n                    and row[\"data\"].get(\"enum\") == apps_enum\n                ):\n                    apps_matches = True\n\n            elif row[\"name\"] == tools_attrib_name:\n                if (\n                    set(row[\"scope\"]) == set(tools_scope)\n                    and row[\"data\"].get(\"enum\") == tools_enum\n                ):\n                    tools_matches = True\n\n        if apps_matches and tools_matches:\n            return\n\n        if not apps_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                apps_scope,\n                apps_attribute_data,\n                apps_attrib_name,\n            )\n\n        if not tools_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                tools_scope,\n                tools_attribute_data,\n                tools_attrib_name,\n            )\n\n        # Reset attributes cache on server\n        await attribute_library.load()\n\n    # --------------------------------------------\n    # Auto-fill of host_name in workfiles entities\n    # --------------------------------------------\n    async def _workfile_entities_auto_filled(self) -&gt; bool:\n        async for _ in Postgres.iterate(\n            \"SELECT * FROM public.addon_data\"\n            \" WHERE addon_name = $1 AND key = $2\",\n            self.name,\n            \"workfile_entities_host_name_filled\",\n        ):\n            return True\n        return False\n\n    async def _on_bundle_updated(\n        self, event: EventModel, *args, **kwargs\n    ) -&gt; None:\n        if await self._workfile_entities_auto_filled():\n            return\n\n        if not event.summary.get(\"isProduction\"):\n            return\n\n        addons = event.payload.get(\"addons\", {})\n        addon_version = addons.get(self.name)\n        if addon_version != self.version:\n            return\n\n        await self._autofill_workfile_entities()\n\n    async def _autofill_workfile_entities(self):\n        project_names = [\n            project.name\n            for project in await get_project_list()\n        ]\n        for project_name in project_names:\n            query = f\"\"\"\n                SELECT id, attrib, path FROM project_{project_name}.workfiles\n                WHERE data-&gt;'host_name' IS NULL;\n            \"\"\"\n            workfile_entities = [\n                row\n                async for row in Postgres.iterate(query)\n            ]\n            changes = []\n            for workfile_entity in workfile_entities:\n                ext = workfile_entity[\"attrib\"].get(\"extension\")\n                if not ext:\n                    ext = os.path.splitext(workfile_entity[\"path\"])[-1]\n                if not ext:\n                    continue\n                mapped_host_name = EXT_TO_HOST_MAPPING.get(ext.lower())\n                if mapped_host_name:\n                    changes.append((workfile_entity[\"id\"], mapped_host_name))\n\n            for chunk in create_chunks(changes):\n                async with Postgres.transaction():\n                    for (workfile_id, host_name) in chunk:\n                        await Postgres.execute(\n                            f\"UPDATE project_{project_name}.workfiles\"\n                            \" SET data = jsonb_set(data, '{host_name}', $1)\"\n                            \" WHERE id = $2;\",\n                            host_name,\n                            workfile_id\n                        )\n\n        await Postgres.execute(\n            \"INSERT INTO public.addon_data\"\n            \" (addon_name, addon_version, key, data)\"\n            \" VALUES ($1, $2, $3, $4)\",\n            self.name,\n            self.version,\n            \"workfile_entities_host_name_filled\",\n            {\n                \"project_names\": project_names,\n            }\n        )\n</code></pre>"},{"location":"autoapi/server/addon.html#server.addon.ApplicationsAddon.create_action_config_hash","title":"<code>create_action_config_hash(identifier, context, user, variant)</code>  <code>async</code>","text":"<p>Create a hash for action config store</p> Source code in <code>server/addon.py</code> <pre><code>async def create_action_config_hash(\n    self,\n    identifier: str,\n    context: ActionContext,\n    user: UserEntity,\n    variant: str,\n) -&gt; str:\n    \"\"\"Create a hash for action config store\"\"\"\n    if not identifier.startswith(IDENTIFIER_PREFIX):\n        return await super().create_action_config_hash(\n            identifier, context, user, variant\n        )\n\n    # Change identifier to only app name and one task id\n    identifier = identifier.removeprefix(IDENTIFIER_PREFIX)\n    hash_content = [\n        user.name,\n        identifier,\n        context.project_name,\n        context.entity_ids[0],\n    ]\n    logger.trace(f\"Creating config hash from {hash_content}\")\n    return hash_data(hash_content)\n</code></pre>"},{"location":"autoapi/server/addon.html#server.addon.ApplicationsAddon.execute_action","title":"<code>execute_action(executor)</code>  <code>async</code>","text":"<p>Execute an action provided by the addon</p> Source code in <code>server/addon.py</code> <pre><code>async def execute_action(\n    self,\n    executor: \"ActionExecutor\",\n) -&gt; \"ExecuteResponseModel\":\n    \"\"\"Execute an action provided by the addon\"\"\"\n    context = executor.context\n    project_name = context.project_name\n    entity_id = context.entity_ids[0]\n\n    bundle_args = []\n    if executor.variant not in (\"production\", \"staging\"):\n        bundle_args = [\"--bundle\", executor.variant]\n\n    if executor.identifier == DEBUG_TERMINAL_ID:\n        args = [\n            \"addon\", \"applications\", \"launch-debug-terminal\",\n            \"--project\", project_name,\n            \"--task-id\", entity_id,\n        ]\n        args.extend(bundle_args)\n        return await executor.get_launcher_action_response(\n            args=args\n        )\n\n    app_name = entity_id_arg = command = None\n    skip_last_workfile = None\n    if executor.identifier.startswith(IDENTIFIER_PREFIX):\n        app_name = executor.identifier.removeprefix(IDENTIFIER_PREFIX)\n        command = \"launch-by-id\"\n        entity_id_arg = \"--task-id\"\n        config = await self.get_action_config(\n            executor.identifier,\n            executor.context,\n            executor.user,\n            executor.variant,\n        )\n        skip_last_workfile = config.get(\"skip_last_workfile\")\n\n    elif executor.identifier.startswith(IDENTIFIER_WORKFILE_PREFIX):\n        app_name = executor.identifier.removeprefix(\n            IDENTIFIER_WORKFILE_PREFIX\n        )\n        command = \"launch-by-workfile-id\"\n        entity_id_arg = \"--workfile-id\"\n\n    if not app_name:\n        return await executor.get_simple_response(\n            message=\"Failed to launch application.\"\n            \" Unknown action identifier.\",\n            success=False,\n        )\n\n    args = [\n        \"addon\", \"applications\", command,\n        \"--app\", app_name,\n        \"--project\", project_name,\n        entity_id_arg, entity_id,\n    ]\n    args.extend(bundle_args)\n    if skip_last_workfile is not None:\n        args.extend([\n            \"--use-last-workfile\", str(int(not skip_last_workfile))\n        ])\n    # 'get_launcher_response' is available since AYON 1.8.3\n    if hasattr(executor, \"get_launcher_response\"):\n        return await executor.get_launcher_response(args=args)\n    # Backwards compatibility\n    return await executor.get_launcher_action_response(args=args)\n</code></pre>"},{"location":"autoapi/server/addon.html#server.addon.ApplicationsAddon.pre_setup","title":"<code>pre_setup()</code>  <code>async</code>","text":"<p>Make sure older version of addon use the new way of attributes.</p> Source code in <code>server/addon.py</code> <pre><code>async def pre_setup(self):\n    \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n    instance = AddonLibrary.getinstance()\n    app_defs = instance.data.get(self.name)\n    old_addon = app_defs.versions.get(\"0.1.0\")\n    if old_addon is not None:\n        # Override 'create_applications_attribute' for older versions\n        #   - avoid infinite server restart loop\n        old_addon.create_applications_attribute = (\n            self.create_applications_attribute\n        )\n\n    # Update older versions of applications addon to use new\n    #   '_update_enums'\n    # - new function skips newer addon versions without 'has_attributes'\n    version_objs, _invalid_versions = parse_versions(app_defs.versions)\n    for addon_version, version_obj in version_objs:\n        # Last release with only old attribute system\n        if version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            addon = app_defs.versions[addon_version]\n            addon._update_enums = self._update_enums\n</code></pre>"},{"location":"autoapi/server/constants.html","title":"constants","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""},{"location":"autoapi/server/settings.html#server.settings.ApplicationsSettings","title":"<code>ApplicationsSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Applications settings</p> Source code in <code>server/settings.py</code> <pre><code>class ApplicationsSettings(BaseSettingsModel):\n    \"\"\"Applications settings\"\"\"\n\n    maya: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Maya\")\n    adsk_3dsmax: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"3ds Max\")\n    flame: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Flame\")\n    gaffer: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Gaffer\")\n    nuke: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke\")\n    nukeassist: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke Assist\")\n    nukex: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke X\")\n    nukestudio: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke Studio\")\n    hiero: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Hiero\")\n    fusion: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Fusion\")\n    resolve: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Resolve\")\n    houdini: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Houdini\")\n    blender: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Blender\")\n    harmony: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Harmony\")\n    tvpaint: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"TVPaint\")\n    photoshop: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Photoshop\")\n    aftereffects: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"After Effects\")\n    premiere: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Premiere\")\n    celaction: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Celaction 2D\")\n    substancepainter: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Substance Painter\")\n    substancedesigner: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Substance Designer\")\n    speedtree: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Speedtree\")\n    unreal: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Unreal Editor\")\n    wrap: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Wrap\")\n    openrv: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"OpenRV\")\n    marvelousdesigner: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Marvelous Designer\")\n    zbrush: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Zbrush\")\n    equalizer: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"3DEqualizer\")\n    motionbuilder: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Motion Builder\")\n    cinema4d: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Cinema4D\")\n    mochapro: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Mocha Pro\")\n    silhouette: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"BorisFX Silhouette\")\n    loki: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"ShapeFX Loki\")\n    terminal: AppGroup = SettingsField(\n        default_factory=AppGroup,\n        title=\"Terminal\",\n        description=\"Terminal application\")\n    additional_apps: list[AdditionalAppGroup] = SettingsField(\n        default_factory=list, title=\"Additional Applications\")\n\n    @validator(\"additional_apps\")\n    def validate_unique_name(cls, value):\n        ensure_unique_names(value)\n        for item in value:\n            if item.name in DEFAULT_APP_GROUPS:\n                raise BadRequestException(f\"Duplicate name '{item.name}'\")\n        return value\n</code></pre>"}]}