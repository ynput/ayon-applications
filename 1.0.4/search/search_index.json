{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"AYON Applications","text":"<p>Applications addon does care about launch of applications in AYON workspace. It defines and provides API to launch applications.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_applications<ul> <li>action</li> <li>addon</li> <li>constants</li> <li>defs</li> <li>exceptions</li> <li>hooks<ul> <li>prelaunch_shell_windows</li> </ul> </li> <li>manager</li> <li>plugins<ul> <li>launcher_actions<ul> <li>debug_terminal</li> </ul> </li> <li>publish<ul> <li>collect_app_name</li> <li>collect_farm_env_variables</li> </ul> </li> </ul> </li> <li>ui<ul> <li>launch_failed_dialog</li> </ul> </li> <li>utils</li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>_backwards</li> <li>actions</li> <li>constants</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_applications/index.html","title":"ayon_applications","text":""},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.Application","title":"<code>Application</code>","text":"<p>Hold information about application.</p> <p>Object by itself does nothing special.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data for the version containing information about executables, variant label or if is enabled. Only required key is <code>executables</code>.</p> required <code>group</code> <code>ApplicationGroup</code> <p>App group object that created the application and under which application belongs.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class Application:\n    \"\"\"Hold information about application.\n\n    Object by itself does nothing special.\n\n    Args:\n        data (dict): Data for the version containing information about\n            executables, variant label or if is enabled.\n            Only required key is `executables`.\n        group (ApplicationGroup): App group object that created the application\n            and under which application belongs.\n\n    \"\"\"\n    def __init__(self, data, group):\n        self._data = data\n        name = data[\"name\"]\n        label = data[\"label\"] or name\n        enabled = False\n        if group.enabled:\n            enabled = data.get(\"enabled\", True)\n\n        if group.label:\n            full_label = \" \".join((group.label, label))\n        else:\n            full_label = label\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n\n        arguments = data[\"arguments\"]\n        if isinstance(arguments, dict):\n            arguments = arguments.get(platform.system().lower())\n\n        if not arguments:\n            arguments = []\n\n        _executables = data[\"executables\"].get(platform.system().lower(), [])\n        executables = [\n            ApplicationExecutable(executable)\n            for executable in _executables\n        ]\n\n        self.group = group\n\n        self.name = name\n        self.label = label\n        self.enabled = enabled\n        self.use_python_2 = data.get(\"use_python_2\", False)\n\n        self.full_name = \"/\".join((group.name, name))\n        self.full_label = full_label\n        self.arguments = arguments\n        self.executables = executables\n        self._environment = env\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.full_name)\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n\n    @property\n    def manager(self):\n        return self.group.manager\n\n    @property\n    def host_name(self):\n        return self.group.host_name\n\n    @property\n    def icon(self):\n        return self.group.icon\n\n    @property\n    def is_host(self):\n        return self.group.is_host\n\n    def find_executable(self):\n        \"\"\"Try to find existing executable for application.\n\n        Returns (str): Path to executable from `executables` or None if any\n            exists.\n        \"\"\"\n        for executable in self.executables:\n            if executable.exists():\n                return executable\n        return None\n\n    def launch(self, *args, **kwargs):\n        \"\"\"Launch the application.\n\n        For this purpose is used manager's launch method to keep logic at one\n        place.\n\n        Arguments must match with manager's launch method. That's why *args\n        **kwargs are used.\n\n        Returns:\n            subprocess.Popen: Return executed process as Popen object.\n        \"\"\"\n        return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.Application.find_executable","title":"<code>find_executable()</code>","text":"<p>Try to find existing executable for application.</p> <p>Returns (str): Path to executable from <code>executables</code> or None if any     exists.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def find_executable(self):\n    \"\"\"Try to find existing executable for application.\n\n    Returns (str): Path to executable from `executables` or None if any\n        exists.\n    \"\"\"\n    for executable in self.executables:\n        if executable.exists():\n            return executable\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.Application.launch","title":"<code>launch(*args, **kwargs)</code>","text":"<p>Launch the application.</p> <p>For this purpose is used manager's launch method to keep logic at one place.</p> <p>Arguments must match with manager's launch method. That's why args *kwargs are used.</p> <p>Returns:</p> Type Description <p>subprocess.Popen: Return executed process as Popen object.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def launch(self, *args, **kwargs):\n    \"\"\"Launch the application.\n\n    For this purpose is used manager's launch method to keep logic at one\n    place.\n\n    Arguments must match with manager's launch method. That's why *args\n    **kwargs are used.\n\n    Returns:\n        subprocess.Popen: Return executed process as Popen object.\n    \"\"\"\n    return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationExecutable","title":"<code>ApplicationExecutable</code>","text":"<p>Representation of executable loaded from settings.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationExecutable:\n    \"\"\"Representation of executable loaded from settings.\"\"\"\n\n    def __init__(self, executable):\n        # Try to format executable with environments\n        try:\n            executable = executable.format(**os.environ)\n        except Exception:\n            pass\n\n        # On MacOS check if exists path to executable when ends with `.app`\n        # - it is common that path will lead to \"/Applications/Blender\" but\n        #   real path is \"/Applications/Blender.app\"\n        if platform.system().lower() == \"darwin\":\n            executable = self.macos_executable_prep(executable)\n\n        self.executable_path = executable\n\n    def __str__(self):\n        return self.executable_path\n\n    def __repr__(self):\n        return \"&lt;{}&gt; {}\".format(self.__class__.__name__, self.executable_path)\n\n    @staticmethod\n    def macos_executable_prep(executable):\n        \"\"\"Try to find full path to executable file.\n\n        Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n        Having path to '*.app' gives ability to read it's plist info and\n        use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n        Plist is stored in '*.app/Contents/Info.plist'.\n\n        This is because some '*.app' directories don't have same permissions\n        as real executable.\n        \"\"\"\n        # Try to find if there is `.app` file\n        if not os.path.exists(executable):\n            _executable = executable + \".app\"\n            if os.path.exists(_executable):\n                executable = _executable\n\n        # Try to find real executable if executable has `Contents` subfolder\n        contents_dir = os.path.join(executable, \"Contents\")\n        if os.path.exists(contents_dir):\n            executable_filename = None\n            # Load plist file and check for bundle executable\n            plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n            if os.path.exists(plist_filepath):\n                import plistlib\n\n                if hasattr(plistlib, \"load\"):\n                    with open(plist_filepath, \"rb\") as stream:\n                        parsed_plist = plistlib.load(stream)\n                else:\n                    parsed_plist = plistlib.readPlist(plist_filepath)\n                executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n            if executable_filename:\n                executable = os.path.join(\n                    contents_dir, \"MacOS\", executable_filename\n                )\n\n        return executable\n\n    def as_args(self):\n        return [self.executable_path]\n\n    def _realpath(self):\n        \"\"\"Check if path is valid executable path.\"\"\"\n        # Check for executable in PATH\n        result = find_executable(self.executable_path)\n        if result is not None:\n            return result\n\n        # This is not 100% validation but it is better than remove ability to\n        #   launch .bat, .sh or extentionless files\n        if os.path.exists(self.executable_path):\n            return self.executable_path\n        return None\n\n    def exists(self):\n        if not self.executable_path:\n            return False\n        return bool(self._realpath())\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationExecutable.macos_executable_prep","title":"<code>macos_executable_prep(executable)</code>  <code>staticmethod</code>","text":"<p>Try to find full path to executable file.</p> <p>Real executable is stored in '*.app/Contents/MacOS/'. <p>Having path to '*.app' gives ability to read it's plist info and use \"CFBundleExecutable\" key from plist to know what is \"executable.\"</p> <p>Plist is stored in '*.app/Contents/Info.plist'.</p> <p>This is because some '*.app' directories don't have same permissions as real executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>@staticmethod\ndef macos_executable_prep(executable):\n    \"\"\"Try to find full path to executable file.\n\n    Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n    Having path to '*.app' gives ability to read it's plist info and\n    use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n    Plist is stored in '*.app/Contents/Info.plist'.\n\n    This is because some '*.app' directories don't have same permissions\n    as real executable.\n    \"\"\"\n    # Try to find if there is `.app` file\n    if not os.path.exists(executable):\n        _executable = executable + \".app\"\n        if os.path.exists(_executable):\n            executable = _executable\n\n    # Try to find real executable if executable has `Contents` subfolder\n    contents_dir = os.path.join(executable, \"Contents\")\n    if os.path.exists(contents_dir):\n        executable_filename = None\n        # Load plist file and check for bundle executable\n        plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n        if os.path.exists(plist_filepath):\n            import plistlib\n\n            if hasattr(plistlib, \"load\"):\n                with open(plist_filepath, \"rb\") as stream:\n                    parsed_plist = plistlib.load(stream)\n            else:\n                parsed_plist = plistlib.readPlist(plist_filepath)\n            executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n        if executable_filename:\n            executable = os.path.join(\n                contents_dir, \"MacOS\", executable_filename\n            )\n\n    return executable\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationExecutableNotFound","title":"<code>ApplicationExecutableNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Defined executable paths are not available on the machine.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationExecutableNotFound(Exception):\n    \"\"\"Defined executable paths are not available on the machine.\"\"\"\n\n    def __init__(self, application):\n        self.application = application\n        details = None\n        if not application.executables:\n            msg = (\n                \"Executable paths for application \\\"{}\\\"({}) are not set.\"\n            )\n        else:\n            msg = (\n                \"Defined executable paths for application \\\"{}\\\"({})\"\n                \" are not available on this machine.\"\n            )\n            details = \"Defined paths:\"\n            for executable in application.executables:\n                details += \"\\n- \" + executable.executable_path\n\n        self.msg = msg.format(application.full_label, application.full_name)\n        self.details = details\n\n        exc_mgs = str(self.msg)\n        if details:\n            # Is good idea to pass new line symbol to exception message?\n            exc_mgs += \"\\n\\n\" + details\n        self.exc_msg = exc_mgs\n        super().__init__(exc_mgs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationGroup","title":"<code>ApplicationGroup</code>","text":"<p>Hold information about application group.</p> <p>Application group wraps different versions(variants) of application. e.g. \"maya\" is group and \"maya_2020\" is variant.</p> <p>Group hold <code>host_name</code> which is implementation name used in AYON. Also holds <code>enabled</code> if whole app group is enabled or <code>icon</code> for application icon path in resources.</p> <p>Group has also <code>environment</code> which hold same environments for all variants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Groups' name.</p> required <code>data</code> <code>dict</code> <p>Group defying data loaded from settings.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that created the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationGroup:\n    \"\"\"Hold information about application group.\n\n    Application group wraps different versions(variants) of application.\n    e.g. \"maya\" is group and \"maya_2020\" is variant.\n\n    Group hold `host_name` which is implementation name used in AYON. Also\n    holds `enabled` if whole app group is enabled or `icon` for application\n    icon path in resources.\n\n    Group has also `environment` which hold same environments for all variants.\n\n    Args:\n        name (str): Groups' name.\n        data (dict): Group defying data loaded from settings.\n        manager (ApplicationManager): Manager that created the group.\n    \"\"\"\n    def __init__(self, name, data, manager):\n        icon = ICONS_BY_GROUP_NAME.get(name)\n        if not icon:\n            icon = data.get(\"icon\")\n\n        label = LABELS_BY_GROUP_NAME.get(name)\n        if not label:\n            label = data.get(\"label\")\n\n        self.name = name\n        self.manager = manager\n        self._data = data\n\n        self.enabled = data[\"enabled\"]\n        self.label = label\n        self.icon = icon\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = env\n\n        host_name = data[\"host_name\"] or None\n        self.is_host = host_name is not None\n        self.host_name = host_name\n\n        settings_variants = data[\"variants\"]\n        variants = {}\n        for variant_data in settings_variants:\n            app_variant = Application(variant_data, self)\n            variants[app_variant.name] = app_variant\n\n        self.variants = variants\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.name)\n\n    def __iter__(self):\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext","title":"<code>ApplicationLaunchContext</code>","text":"<p>Context of launching application.</p> <p>Main purpose of context is to prepare launch arguments and keyword arguments for new process. Most important part of keyword arguments preparations are environment variables.</p> <p>During the whole process is possible to use <code>data</code> attribute to store object usable in multiple places.</p> <p>Launch arguments are strings in list. It is possible to \"chain\" argument when order of them matters. That is possible to do with adding list where order is right and should not change. NOTE: This is recommendation, not requirement. e.g.: <code>[\"nuke.exe\", \"--NukeX\"]</code> -&gt; In this case any part of process may insert argument between <code>nuke.exe</code> and <code>--NukeX</code>. To keep them together it is better to wrap them in another list: <code>[[\"nuke.exe\", \"--NukeX\"]]</code>.</p> Notes <p>It is possible to use launch context only to prepare environment     variables. In that case <code>executable</code> may be None and can be used     'run_prelaunch_hooks' method to run prelaunch hooks which prepare     them.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Application</code> <p>Application definition.</p> required <code>executable</code> <code>ApplicationExecutable</code> <p>Object with path to executable.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment variable group. If not set 'DEFAULT_ENV_SUBGROUP' is used.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type. If not set 'local' is used.</p> <code>None</code> <code>**data</code> <code>dict</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationLaunchContext:\n    \"\"\"Context of launching application.\n\n    Main purpose of context is to prepare launch arguments and keyword\n    arguments for new process. Most important part of keyword arguments\n    preparations are environment variables.\n\n    During the whole process is possible to use `data` attribute to store\n    object usable in multiple places.\n\n    Launch arguments are strings in list. It is possible to \"chain\" argument\n    when order of them matters. That is possible to do with adding list where\n    order is right and should not change.\n    NOTE: This is recommendation, not requirement.\n    e.g.: `[\"nuke.exe\", \"--NukeX\"]` -&gt; In this case any part of process may\n    insert argument between `nuke.exe` and `--NukeX`. To keep them together\n    it is better to wrap them in another list: `[[\"nuke.exe\", \"--NukeX\"]]`.\n\n    Notes:\n        It is possible to use launch context only to prepare environment\n            variables. In that case `executable` may be None and can be used\n            'run_prelaunch_hooks' method to run prelaunch hooks which prepare\n            them.\n\n    Args:\n        application (Application): Application definition.\n        executable (ApplicationExecutable): Object with path to executable.\n        env_group (Optional[str]): Environment variable group. If not set\n            'DEFAULT_ENV_SUBGROUP' is used.\n        launch_type (Optional[str]): Launch type. If not set 'local' is used.\n        **data (dict): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n    \"\"\"\n\n    def __init__(\n        self,\n        application,\n        executable,\n        env_group=None,\n        launch_type=None,\n        **data\n    ):\n        # Application object\n        self.application = application\n\n        self.addons_manager = AddonsManager()\n\n        # Logger\n        logger_name = \"{}-{}\".format(self.__class__.__name__,\n                                     self.application.full_name)\n        self.log = Logger.get_logger(logger_name)\n\n        self.executable = executable\n\n        if launch_type is None:\n            launch_type = LaunchTypes.local\n        self.launch_type = launch_type\n\n        if env_group is None:\n            env_group = DEFAULT_ENV_SUBGROUP\n\n        self.env_group = env_group\n\n        self.data = dict(data)\n\n        launch_args = []\n        if executable is not None:\n            launch_args = executable.as_args()\n        # subprocess.Popen launch arguments (first argument in constructor)\n        self.launch_args = launch_args\n        self.launch_args.extend(application.arguments)\n        if self.data.get(\"app_args\"):\n            self.launch_args.extend(self.data.pop(\"app_args\"))\n\n        # Handle launch environemtns\n        src_env = self.data.pop(\"env\", None)\n        if src_env is not None and not isinstance(src_env, dict):\n            self.log.warning((\n                \"Passed `env` kwarg has invalid type: {}. Expected: `dict`.\"\n                \" Using `os.environ` instead.\"\n            ).format(str(type(src_env))))\n            src_env = None\n\n        if src_env is None:\n            src_env = os.environ\n\n        ignored_env = {\"QT_API\", }\n        env = {\n            key: str(value)\n            for key, value in src_env.items()\n            if key not in ignored_env\n        }\n        # subprocess.Popen keyword arguments\n        self.kwargs = {\"env\": env}\n\n        if platform.system().lower() == \"windows\":\n            # Detach new process from currently running process on Windows\n            flags = (\n                subprocess.CREATE_NEW_PROCESS_GROUP\n                | subprocess.DETACHED_PROCESS\n            )\n            self.kwargs[\"creationflags\"] = flags\n\n        if not sys.stdout:\n            self.kwargs[\"stdout\"] = subprocess.DEVNULL\n            self.kwargs[\"stderr\"] = subprocess.DEVNULL\n\n        self.prelaunch_hooks = None\n        self.postlaunch_hooks = None\n\n        self.process = None\n        self._prelaunch_hooks_executed = False\n\n    @property\n    def env(self):\n        if (\n            \"env\" not in self.kwargs\n            or self.kwargs[\"env\"] is None\n        ):\n            self.kwargs[\"env\"] = {}\n        return self.kwargs[\"env\"]\n\n    @env.setter\n    def env(self, value):\n        if not isinstance(value, dict):\n            raise ValueError(\n                \"'env' attribute expect 'dict' object. Got: {}\".format(\n                    str(type(value))\n                )\n            )\n        self.kwargs[\"env\"] = value\n\n    @property\n    def modules_manager(self):\n        \"\"\"\n        Deprecated:\n            Use 'addons_manager' instead.\n\n        \"\"\"\n        return self.addons_manager\n\n    def _collect_addons_launch_hook_paths(self):\n        \"\"\"Helper to collect application launch hooks from addons.\n\n        Module have to have implemented 'get_launch_hook_paths' method which\n        can expect application as argument or nothing.\n\n        Returns:\n            List[str]: Paths to launch hook directories.\n        \"\"\"\n\n        expected_types = (list, tuple, set)\n\n        output = []\n        for module in self.addons_manager.get_enabled_addons():\n            # Skip module if does not have implemented 'get_launch_hook_paths'\n            func = getattr(module, \"get_launch_hook_paths\", None)\n            if func is None:\n                continue\n\n            func = module.get_launch_hook_paths\n            if hasattr(inspect, \"signature\"):\n                sig = inspect.signature(func)\n                expect_args = len(sig.parameters) &gt; 0\n            else:\n                expect_args = len(inspect.getargspec(func)[0]) &gt; 0\n\n            # Pass application argument if method expect it.\n            try:\n                if expect_args:\n                    hook_paths = func(self.application)\n                else:\n                    hook_paths = func()\n            except Exception:\n                self.log.warning(\n                    \"Failed to call 'get_launch_hook_paths'\",\n                    exc_info=True\n                )\n                continue\n\n            if not hook_paths:\n                continue\n\n            # Convert string to list\n            if isinstance(hook_paths, str):\n                hook_paths = [hook_paths]\n\n            # Skip invalid types\n            if not isinstance(hook_paths, expected_types):\n                self.log.warning((\n                    \"Result of `get_launch_hook_paths`\"\n                    \" has invalid type {}. Expected {}\"\n                ).format(type(hook_paths), expected_types))\n                continue\n\n            output.extend(hook_paths)\n        return output\n\n    def paths_to_launch_hooks(self):\n        \"\"\"Directory paths where to look for launch hooks.\"\"\"\n        # This method has potential to be part of application manager (maybe).\n        paths = []\n\n        # TODO load additional studio paths from settings\n        global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n        hooks_dirs = [\n            global_hooks_dir\n        ]\n        if self.host_name:\n            # If host requires launch hooks and is module then launch hooks\n            #   should be collected using 'collect_launch_hook_paths'\n            #   - module have to implement 'get_launch_hook_paths'\n            host_module = self.addons_manager.get_host_addon(self.host_name)\n            if not host_module:\n                hooks_dirs.append(os.path.join(\n                    AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n                ))\n\n        for path in hooks_dirs:\n            if (\n                os.path.exists(path)\n                and os.path.isdir(path)\n                and path not in paths\n            ):\n                paths.append(path)\n\n        # Load modules paths\n        paths.extend(self._collect_addons_launch_hook_paths())\n\n        return paths\n\n    def discover_launch_hooks(self, force=False):\n        \"\"\"Load and prepare launch hooks.\"\"\"\n        if (\n            self.prelaunch_hooks is not None\n            or self.postlaunch_hooks is not None\n        ):\n            if not force:\n                self.log.info(\"Launch hooks were already discovered.\")\n                return\n\n            self.prelaunch_hooks.clear()\n            self.postlaunch_hooks.clear()\n\n        self.log.debug(\"Discovery of launch hooks started.\")\n\n        paths = self.paths_to_launch_hooks()\n        self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n            \"\\n\".join(\"- {}\".format(path) for path in paths)\n        ))\n\n        all_classes = {\n            \"pre\": [],\n            \"post\": []\n        }\n        for path in paths:\n            if not os.path.exists(path):\n                self.log.info(\n                    \"Path to launch hooks does not exist: \\\"{}\\\"\".format(path)\n                )\n                continue\n\n            modules, _crashed = modules_from_path(path)\n            for _filepath, module in modules:\n                all_classes[\"pre\"].extend(\n                    classes_from_module(PreLaunchHook, module)\n                )\n                all_classes[\"post\"].extend(\n                    classes_from_module(PostLaunchHook, module)\n                )\n\n        for launch_type, classes in all_classes.items():\n            hooks_with_order = []\n            hooks_without_order = []\n            for klass in classes:\n                try:\n                    hook = klass(self)\n                    if not hook.is_valid:\n                        self.log.debug(\n                            \"Skipped hook invalid for current launch context: \"\n                            \"{}\".format(klass.__name__)\n                        )\n                        continue\n\n                    if inspect.isabstract(hook):\n                        self.log.debug(\"Skipped abstract hook: {}\".format(\n                            klass.__name__\n                        ))\n                        continue\n\n                    # Separate hooks by pre/post class\n                    if hook.order is None:\n                        hooks_without_order.append(hook)\n                    else:\n                        hooks_with_order.append(hook)\n\n                except Exception:\n                    self.log.warning(\n                        \"Initialization of hook failed: \"\n                        \"{}\".format(klass.__name__),\n                        exc_info=True\n                    )\n\n            # Sort hooks with order by order\n            ordered_hooks = list(sorted(\n                hooks_with_order, key=lambda obj: obj.order\n            ))\n            # Extend ordered hooks with hooks without defined order\n            ordered_hooks.extend(hooks_without_order)\n\n            if launch_type == \"pre\":\n                self.prelaunch_hooks = ordered_hooks\n            else:\n                self.postlaunch_hooks = ordered_hooks\n\n        self.log.debug(\"Found {} prelaunch and {} postlaunch hooks.\".format(\n            len(self.prelaunch_hooks), len(self.postlaunch_hooks)\n        ))\n\n    @property\n    def app_name(self):\n        return self.application.name\n\n    @property\n    def host_name(self):\n        return self.application.host_name\n\n    @property\n    def app_group(self):\n        return self.application.group\n\n    @property\n    def manager(self):\n        return self.application.manager\n\n    def _run_process(self):\n        # Windows and MacOS have easier process start\n        low_platform = platform.system().lower()\n        if low_platform in (\"windows\", \"darwin\"):\n            return subprocess.Popen(self.launch_args, **self.kwargs)\n\n        # Linux uses mid process\n        # - it is possible that the mid process executable is not\n        #   available for this version of AYON in that case use standard\n        #   launch\n        launch_args = get_linux_launcher_args()\n        if launch_args is None:\n            return subprocess.Popen(self.launch_args, **self.kwargs)\n\n        # Prepare data that will be passed to midprocess\n        # - store arguments to a json and pass path to json as last argument\n        # - pass environments to set\n        app_env = self.kwargs.pop(\"env\", {})\n        json_data = {\n            \"args\": self.launch_args,\n            \"env\": app_env\n        }\n        if app_env:\n            # Filter environments of subprocess\n            self.kwargs[\"env\"] = {\n                key: value\n                for key, value in os.environ.items()\n                if key in app_env\n            }\n\n        # Create temp file\n        json_temp = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"op_app_args\", suffix=\".json\", delete=False\n        )\n        json_temp.close()\n        json_temp_filpath = json_temp.name\n        with open(json_temp_filpath, \"w\") as stream:\n            json.dump(json_data, stream)\n\n        launch_args.append(json_temp_filpath)\n\n        # Create mid-process which will launch application\n        process = subprocess.Popen(launch_args, **self.kwargs)\n        # Wait until the process finishes\n        #   - This is important! The process would stay in \"open\" state.\n        process.wait()\n        # Remove the temp file\n        os.remove(json_temp_filpath)\n        # Return process which is already terminated\n        return process\n\n    def run_prelaunch_hooks(self):\n        \"\"\"Run prelaunch hooks.\n\n        This method will be executed only once, any future calls will skip\n            the processing.\n        \"\"\"\n\n        if self._prelaunch_hooks_executed:\n            self.log.warning(\"Prelaunch hooks were already executed.\")\n            return\n        # Discover launch hooks\n        self.discover_launch_hooks()\n\n        # Execute prelaunch hooks\n        for prelaunch_hook in self.prelaunch_hooks:\n            self.log.debug(\"Executing prelaunch hook: {}\".format(\n                str(prelaunch_hook.__class__.__name__)\n            ))\n            prelaunch_hook.execute()\n        self._prelaunch_hooks_executed = True\n\n    def launch(self):\n        \"\"\"Collect data for new process and then create it.\n\n        This method must not be executed more than once.\n\n        Returns:\n            subprocess.Popen: Created process as Popen object.\n        \"\"\"\n        if self.process is not None:\n            self.log.warning(\"Application was already launched.\")\n            return\n\n        if not self._prelaunch_hooks_executed:\n            self.run_prelaunch_hooks()\n\n        self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n        # Prepare subprocess args\n        args_len_str = \"\"\n        if isinstance(self.launch_args, str):\n            args = self.launch_args\n        else:\n            args = self.clear_launch_args(self.launch_args)\n            args_len_str = \" ({})\".format(len(args))\n        self.log.info(\n            \"Launching \\\"{}\\\" with args{}: {}\".format(\n                self.application.full_name, args_len_str, args\n            )\n        )\n        self.launch_args = args\n\n        # Run process\n        self.process = self._run_process()\n\n        # Process post launch hooks\n        for postlaunch_hook in self.postlaunch_hooks:\n            self.log.debug(\"Executing postlaunch hook: {}\".format(\n                str(postlaunch_hook.__class__.__name__)\n            ))\n\n            # TODO how to handle errors?\n            # - store to variable to let them accessible?\n            try:\n                postlaunch_hook.execute()\n\n            except Exception:\n                self.log.warning(\n                    \"After launch procedures were not successful.\",\n                    exc_info=True\n                )\n\n        self.log.debug(\"Launch of {} finished.\".format(\n            self.application.full_name\n        ))\n\n        return self.process\n\n    @staticmethod\n    def clear_launch_args(args):\n        \"\"\"Collect launch arguments to final order.\n\n        Launch argument should be list that may contain another lists this\n        function will upack inner lists and keep ordering.\n\n        ```\n        # source\n        [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n        # result\n        [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n        Args:\n            args (list): Source arguments in list may contain inner lists.\n\n        Return:\n            list: Unpacked arguments.\n        \"\"\"\n        if isinstance(args, str):\n            return args\n        all_cleared = False\n        while not all_cleared:\n            all_cleared = True\n            new_args = []\n            for arg in args:\n                if isinstance(arg, (list, tuple, set)):\n                    all_cleared = False\n                    for _arg in arg:\n                        new_args.append(_arg)\n                else:\n                    new_args.append(arg)\n            args = new_args\n\n        return args\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.modules_manager","title":"<code>modules_manager</code>  <code>property</code>","text":"Deprecated <p>Use 'addons_manager' instead.</p>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.clear_launch_args","title":"<code>clear_launch_args(args)</code>  <code>staticmethod</code>","text":"<p>Collect launch arguments to final order.</p> <p>Launch argument should be list that may contain another lists this function will upack inner lists and keep ordering.</p> <p>```</p>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.clear_launch_args--source","title":"source","text":"<p>[ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]</p>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.clear_launch_args--result","title":"result","text":"<p>[ arg1, arg2, arg3, arg4, arg5, arg6]</p> <p>Args:     args (list): Source arguments in list may contain inner lists.</p> <p>Return:     list: Unpacked arguments.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>@staticmethod\ndef clear_launch_args(args):\n    \"\"\"Collect launch arguments to final order.\n\n    Launch argument should be list that may contain another lists this\n    function will upack inner lists and keep ordering.\n\n    ```\n    # source\n    [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n    # result\n    [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n    Args:\n        args (list): Source arguments in list may contain inner lists.\n\n    Return:\n        list: Unpacked arguments.\n    \"\"\"\n    if isinstance(args, str):\n        return args\n    all_cleared = False\n    while not all_cleared:\n        all_cleared = True\n        new_args = []\n        for arg in args:\n            if isinstance(arg, (list, tuple, set)):\n                all_cleared = False\n                for _arg in arg:\n                    new_args.append(_arg)\n            else:\n                new_args.append(arg)\n        args = new_args\n\n    return args\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.discover_launch_hooks","title":"<code>discover_launch_hooks(force=False)</code>","text":"<p>Load and prepare launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def discover_launch_hooks(self, force=False):\n    \"\"\"Load and prepare launch hooks.\"\"\"\n    if (\n        self.prelaunch_hooks is not None\n        or self.postlaunch_hooks is not None\n    ):\n        if not force:\n            self.log.info(\"Launch hooks were already discovered.\")\n            return\n\n        self.prelaunch_hooks.clear()\n        self.postlaunch_hooks.clear()\n\n    self.log.debug(\"Discovery of launch hooks started.\")\n\n    paths = self.paths_to_launch_hooks()\n    self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n        \"\\n\".join(\"- {}\".format(path) for path in paths)\n    ))\n\n    all_classes = {\n        \"pre\": [],\n        \"post\": []\n    }\n    for path in paths:\n        if not os.path.exists(path):\n            self.log.info(\n                \"Path to launch hooks does not exist: \\\"{}\\\"\".format(path)\n            )\n            continue\n\n        modules, _crashed = modules_from_path(path)\n        for _filepath, module in modules:\n            all_classes[\"pre\"].extend(\n                classes_from_module(PreLaunchHook, module)\n            )\n            all_classes[\"post\"].extend(\n                classes_from_module(PostLaunchHook, module)\n            )\n\n    for launch_type, classes in all_classes.items():\n        hooks_with_order = []\n        hooks_without_order = []\n        for klass in classes:\n            try:\n                hook = klass(self)\n                if not hook.is_valid:\n                    self.log.debug(\n                        \"Skipped hook invalid for current launch context: \"\n                        \"{}\".format(klass.__name__)\n                    )\n                    continue\n\n                if inspect.isabstract(hook):\n                    self.log.debug(\"Skipped abstract hook: {}\".format(\n                        klass.__name__\n                    ))\n                    continue\n\n                # Separate hooks by pre/post class\n                if hook.order is None:\n                    hooks_without_order.append(hook)\n                else:\n                    hooks_with_order.append(hook)\n\n            except Exception:\n                self.log.warning(\n                    \"Initialization of hook failed: \"\n                    \"{}\".format(klass.__name__),\n                    exc_info=True\n                )\n\n        # Sort hooks with order by order\n        ordered_hooks = list(sorted(\n            hooks_with_order, key=lambda obj: obj.order\n        ))\n        # Extend ordered hooks with hooks without defined order\n        ordered_hooks.extend(hooks_without_order)\n\n        if launch_type == \"pre\":\n            self.prelaunch_hooks = ordered_hooks\n        else:\n            self.postlaunch_hooks = ordered_hooks\n\n    self.log.debug(\"Found {} prelaunch and {} postlaunch hooks.\".format(\n        len(self.prelaunch_hooks), len(self.postlaunch_hooks)\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.launch","title":"<code>launch()</code>","text":"<p>Collect data for new process and then create it.</p> <p>This method must not be executed more than once.</p> <p>Returns:</p> Type Description <p>subprocess.Popen: Created process as Popen object.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self):\n    \"\"\"Collect data for new process and then create it.\n\n    This method must not be executed more than once.\n\n    Returns:\n        subprocess.Popen: Created process as Popen object.\n    \"\"\"\n    if self.process is not None:\n        self.log.warning(\"Application was already launched.\")\n        return\n\n    if not self._prelaunch_hooks_executed:\n        self.run_prelaunch_hooks()\n\n    self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n    # Prepare subprocess args\n    args_len_str = \"\"\n    if isinstance(self.launch_args, str):\n        args = self.launch_args\n    else:\n        args = self.clear_launch_args(self.launch_args)\n        args_len_str = \" ({})\".format(len(args))\n    self.log.info(\n        \"Launching \\\"{}\\\" with args{}: {}\".format(\n            self.application.full_name, args_len_str, args\n        )\n    )\n    self.launch_args = args\n\n    # Run process\n    self.process = self._run_process()\n\n    # Process post launch hooks\n    for postlaunch_hook in self.postlaunch_hooks:\n        self.log.debug(\"Executing postlaunch hook: {}\".format(\n            str(postlaunch_hook.__class__.__name__)\n        ))\n\n        # TODO how to handle errors?\n        # - store to variable to let them accessible?\n        try:\n            postlaunch_hook.execute()\n\n        except Exception:\n            self.log.warning(\n                \"After launch procedures were not successful.\",\n                exc_info=True\n            )\n\n    self.log.debug(\"Launch of {} finished.\".format(\n        self.application.full_name\n    ))\n\n    return self.process\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.paths_to_launch_hooks","title":"<code>paths_to_launch_hooks()</code>","text":"<p>Directory paths where to look for launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def paths_to_launch_hooks(self):\n    \"\"\"Directory paths where to look for launch hooks.\"\"\"\n    # This method has potential to be part of application manager (maybe).\n    paths = []\n\n    # TODO load additional studio paths from settings\n    global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n    hooks_dirs = [\n        global_hooks_dir\n    ]\n    if self.host_name:\n        # If host requires launch hooks and is module then launch hooks\n        #   should be collected using 'collect_launch_hook_paths'\n        #   - module have to implement 'get_launch_hook_paths'\n        host_module = self.addons_manager.get_host_addon(self.host_name)\n        if not host_module:\n            hooks_dirs.append(os.path.join(\n                AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n            ))\n\n    for path in hooks_dirs:\n        if (\n            os.path.exists(path)\n            and os.path.isdir(path)\n            and path not in paths\n        ):\n            paths.append(path)\n\n    # Load modules paths\n    paths.extend(self._collect_addons_launch_hook_paths())\n\n    return paths\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchContext.run_prelaunch_hooks","title":"<code>run_prelaunch_hooks()</code>","text":"<p>Run prelaunch hooks.</p> <p>This method will be executed only once, any future calls will skip     the processing.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def run_prelaunch_hooks(self):\n    \"\"\"Run prelaunch hooks.\n\n    This method will be executed only once, any future calls will skip\n        the processing.\n    \"\"\"\n\n    if self._prelaunch_hooks_executed:\n        self.log.warning(\"Prelaunch hooks were already executed.\")\n        return\n    # Discover launch hooks\n    self.discover_launch_hooks()\n\n    # Execute prelaunch hooks\n    for prelaunch_hook in self.prelaunch_hooks:\n        self.log.debug(\"Executing prelaunch hook: {}\".format(\n            str(prelaunch_hook.__class__.__name__)\n        ))\n        prelaunch_hook.execute()\n    self._prelaunch_hooks_executed = True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationLaunchFailed","title":"<code>ApplicationLaunchFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application launch failed due to known reason.</p> <p>Message should be self explanatory as traceback won't be shown.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationLaunchFailed(Exception):\n    \"\"\"Application launch failed due to known reason.\n\n    Message should be self explanatory as traceback won't be shown.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager","title":"<code>ApplicationManager</code>","text":"<p>Load applications and tools and store them by their full name.</p> <p>Parameters:</p> Name Type Description Default <code>studio_settings</code> <code>dict</code> <p>Preloaded studio settings. When passed manager will always use these values. Gives ability to create manager using different settings.</p> <code>None</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationManager:\n    \"\"\"Load applications and tools and store them by their full name.\n\n    Args:\n        studio_settings (dict): Preloaded studio settings. When passed manager\n            will always use these values. Gives ability to create manager\n            using different settings.\n    \"\"\"\n\n    def __init__(self, studio_settings=None):\n        self.log = Logger.get_logger(self.__class__.__name__)\n\n        self.app_groups = {}\n        self.applications = {}\n        self.tool_groups = {}\n        self.tools = {}\n\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def set_studio_settings(self, studio_settings):\n        \"\"\"Ability to change init system settings.\n\n        This will trigger refresh of manager.\n        \"\"\"\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def refresh(self):\n        \"\"\"Refresh applications from settings.\"\"\"\n        self.app_groups.clear()\n        self.applications.clear()\n        self.tool_groups.clear()\n        self.tools.clear()\n\n        if self._studio_settings is not None:\n            settings = copy.deepcopy(self._studio_settings)\n        else:\n            settings = get_studio_settings(\n                clear_metadata=False, exclude_locals=False\n            )\n\n        applications_addon_settings = settings[\"applications\"]\n\n        # Prepare known applications\n        app_defs = applications_addon_settings[\"applications\"]\n        additional_apps = app_defs.pop(\"additional_apps\")\n        for additional_app in additional_apps:\n            app_name = additional_app.pop(\"name\")\n            if app_name in app_defs:\n                self.log.warning((\n                    \"Additional application '{}' is already\"\n                    \" in built-in applications.\"\n                ).format(app_name))\n            app_defs[app_name] = additional_app\n\n        for group_name, variant_defs in app_defs.items():\n            group = ApplicationGroup(group_name, variant_defs, self)\n            self.app_groups[group_name] = group\n            for app in group:\n                self.applications[app.full_name] = app\n\n        tools_definitions = applications_addon_settings[\"tool_groups\"]\n        for tool_group_data in tools_definitions:\n            group = EnvironmentToolGroup(tool_group_data, self)\n            self.tool_groups[group.name] = group\n            for tool in group:\n                self.tools[tool.full_name] = tool\n\n    def find_latest_available_variant_for_group(self, group_name):\n        group = self.app_groups.get(group_name)\n        if group is None or not group.enabled:\n            return None\n\n        output = None\n        for _, variant in reversed(sorted(group.variants.items())):\n            executable = variant.find_executable()\n            if executable:\n                output = variant\n                break\n        return output\n\n    def create_launch_context(self, app_name, **data):\n        \"\"\"Prepare launch context for application.\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n\n        Returns:\n            ApplicationLaunchContext: Launch context for application.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered name.\n        \"\"\"\n\n        app = self.applications.get(app_name)\n        if not app:\n            raise ApplicationNotFound(app_name)\n\n        executable = app.find_executable()\n\n        return ApplicationLaunchContext(\n            app, executable, **data\n        )\n\n    def launch_with_context(self, launch_context):\n        \"\"\"Launch application using existing launch context.\n\n        Args:\n            launch_context (ApplicationLaunchContext): Prepared launch\n                context.\n        \"\"\"\n\n        if not launch_context.executable:\n            raise ApplicationExecutableNotFound(launch_context.application)\n        return launch_context.launch()\n\n    def launch(self, app_name, **data):\n        \"\"\"Launch procedure.\n\n        For host application it's expected to contain \"project_name\",\n        \"folder_path\" and \"task_name\".\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n                preparation to store objects usable in multiple places.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered\n                argument `app_name`.\n            ApplicationExecutableNotFound: Executables in application definition\n                were not found on this machine.\n            ApplicationLaunchFailed: Something important for application launch\n                failed. Exception should contain explanation message,\n                traceback should not be needed.\n        \"\"\"\n\n        context = self.create_launch_context(app_name, **data)\n        return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.create_launch_context","title":"<code>create_launch_context(app_name, **data)</code>","text":"<p>Prepare launch context for application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ApplicationLaunchContext</code> <p>Launch context for application.</p> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered name.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def create_launch_context(self, app_name, **data):\n    \"\"\"Prepare launch context for application.\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n\n    Returns:\n        ApplicationLaunchContext: Launch context for application.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered name.\n    \"\"\"\n\n    app = self.applications.get(app_name)\n    if not app:\n        raise ApplicationNotFound(app_name)\n\n    executable = app.find_executable()\n\n    return ApplicationLaunchContext(\n        app, executable, **data\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.launch","title":"<code>launch(app_name, **data)</code>","text":"<p>Launch procedure.</p> <p>For host application it's expected to contain \"project_name\", \"folder_path\" and \"task_name\".</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered argument <code>app_name</code>.</p> <code>ApplicationExecutableNotFound</code> <p>Executables in application definition were not found on this machine.</p> <code>ApplicationLaunchFailed</code> <p>Something important for application launch failed. Exception should contain explanation message, traceback should not be needed.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self, app_name, **data):\n    \"\"\"Launch procedure.\n\n    For host application it's expected to contain \"project_name\",\n    \"folder_path\" and \"task_name\".\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered\n            argument `app_name`.\n        ApplicationExecutableNotFound: Executables in application definition\n            were not found on this machine.\n        ApplicationLaunchFailed: Something important for application launch\n            failed. Exception should contain explanation message,\n            traceback should not be needed.\n    \"\"\"\n\n    context = self.create_launch_context(app_name, **data)\n    return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.launch_with_context","title":"<code>launch_with_context(launch_context)</code>","text":"<p>Launch application using existing launch context.</p> <p>Parameters:</p> Name Type Description Default <code>launch_context</code> <code>ApplicationLaunchContext</code> <p>Prepared launch context.</p> required Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch_with_context(self, launch_context):\n    \"\"\"Launch application using existing launch context.\n\n    Args:\n        launch_context (ApplicationLaunchContext): Prepared launch\n            context.\n    \"\"\"\n\n    if not launch_context.executable:\n        raise ApplicationExecutableNotFound(launch_context.application)\n    return launch_context.launch()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.refresh","title":"<code>refresh()</code>","text":"<p>Refresh applications from settings.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def refresh(self):\n    \"\"\"Refresh applications from settings.\"\"\"\n    self.app_groups.clear()\n    self.applications.clear()\n    self.tool_groups.clear()\n    self.tools.clear()\n\n    if self._studio_settings is not None:\n        settings = copy.deepcopy(self._studio_settings)\n    else:\n        settings = get_studio_settings(\n            clear_metadata=False, exclude_locals=False\n        )\n\n    applications_addon_settings = settings[\"applications\"]\n\n    # Prepare known applications\n    app_defs = applications_addon_settings[\"applications\"]\n    additional_apps = app_defs.pop(\"additional_apps\")\n    for additional_app in additional_apps:\n        app_name = additional_app.pop(\"name\")\n        if app_name in app_defs:\n            self.log.warning((\n                \"Additional application '{}' is already\"\n                \" in built-in applications.\"\n            ).format(app_name))\n        app_defs[app_name] = additional_app\n\n    for group_name, variant_defs in app_defs.items():\n        group = ApplicationGroup(group_name, variant_defs, self)\n        self.app_groups[group_name] = group\n        for app in group:\n            self.applications[app.full_name] = app\n\n    tools_definitions = applications_addon_settings[\"tool_groups\"]\n    for tool_group_data in tools_definitions:\n        group = EnvironmentToolGroup(tool_group_data, self)\n        self.tool_groups[group.name] = group\n        for tool in group:\n            self.tools[tool.full_name] = tool\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationManager.set_studio_settings","title":"<code>set_studio_settings(studio_settings)</code>","text":"<p>Ability to change init system settings.</p> <p>This will trigger refresh of manager.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def set_studio_settings(self, studio_settings):\n    \"\"\"Ability to change init system settings.\n\n    This will trigger refresh of manager.\n    \"\"\"\n    self._studio_settings = studio_settings\n\n    self.refresh()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationNotFound","title":"<code>ApplicationNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application was not found in ApplicationManager by name.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationNotFound(Exception):\n    \"\"\"Application was not found in ApplicationManager by name.\"\"\"\n\n    def __init__(self, app_name):\n        self.app_name = app_name\n        super().__init__(\n            \"Application \\\"{}\\\" was not found.\".format(app_name)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IPluginPaths</code></p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>class ApplicationsAddon(AYONAddon, IPluginPaths):\n    name = \"applications\"\n    version = __version__\n\n    def initialize(self, settings):\n        # TODO remove when addon is removed from ayon-core\n        self.enabled = self.name in settings\n\n    def get_app_environments_for_context(\n        self,\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=None,\n        launch_type=None,\n        env=None,\n    ):\n        \"\"\"Calculate environment variables for launch context.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            full_app_name (str): Full application name.\n            env_group (Optional[str]): Environment group.\n            launch_type (Optional[str]): Launch type.\n            env (Optional[dict[str, str]]): Environment variables to update.\n\n        Returns:\n            dict[str, str]: Environment variables for context.\n\n        \"\"\"\n        from ayon_applications.utils import get_app_environments_for_context\n\n        if not full_app_name:\n            return {}\n\n        return get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=launch_type,\n            env=env,\n            addons_manager=self.manager\n        )\n\n    def get_farm_publish_environment_variables(\n        self,\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name=None,\n        env_group=None,\n    ):\n        \"\"\"Calculate environment variables for farm publish.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            env_group (Optional[str]): Environment group.\n            full_app_name (Optional[str]): Full application name. Value from\n                environment variable 'AYON_APP_NAME' is used if 'None' is\n                passed.\n\n        Returns:\n            dict[str, str]: Environment variables for farm publish.\n\n        \"\"\"\n        if full_app_name is None:\n            full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n        return self.get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=LaunchTypes.farm_publish\n        )\n\n    def get_applications_manager(self, settings=None):\n        \"\"\"Get applications manager.\n\n        Args:\n            settings (Optional[dict]): Studio/project settings.\n\n        Returns:\n            ApplicationManager: Applications manager.\n\n        \"\"\"\n        return ApplicationManager(settings)\n\n    def get_plugin_paths(self):\n        plugins_dir = os.path.join(APPLICATIONS_ADDON_ROOT, \"plugins\")\n        return {\n            \"actions\": [os.path.join(plugins_dir, \"launcher_actions\")],\n            \"publish\": [os.path.join(plugins_dir, \"publish\")]\n        }\n\n    def get_launch_hook_paths(self, app):\n        return [\n            os.path.join(APPLICATIONS_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_app_icon_path(self, icon_filename):\n        \"\"\"Get icon path.\n\n        Args:\n            icon_filename (str): Icon filename.\n\n        Returns:\n            Union[str, None]: Icon path or None if not found.\n\n        \"\"\"\n        return get_app_icon_path(icon_filename)\n\n    def get_app_icon_url(self, icon_filename, server=False):\n        \"\"\"Get icon path.\n\n        Method does not validate if icon filename exist on server.\n\n        Args:\n            icon_filename (str): Icon name.\n            server (Optional[bool]): Return url to AYON server.\n\n        Returns:\n            Union[str, None]: Icon path or None is server url is not\n                available.\n\n        \"\"\"\n        if not icon_filename:\n            return None\n        icon_name = os.path.basename(icon_filename)\n        if server:\n            base_url = ayon_api.get_base_url()\n            return (\n                f\"{base_url}/addons/{self.name}/{self.version}\"\n                f\"/public/icons/{icon_name}\"\n            )\n        server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n        if not server_url:\n            return None\n        return \"/\".join([\n            server_url, \"addons\", self.name, \"icons\", icon_name\n        ])\n\n    def get_applications_action_classes(self):\n        \"\"\"Get application action classes for launcher tool.\n\n        This method should be used only by launcher tool. Please do not use it\n        in other places as its implementation is not optimal, and might\n        change or be removed.\n\n        Returns:\n            list[ApplicationAction]: List of application action classes.\n\n        \"\"\"\n        from .action import ApplicationAction\n\n        actions = []\n\n        manager = self.get_applications_manager()\n        for full_name, application in manager.applications.items():\n            if not application.enabled:\n                continue\n\n            icon = self.get_app_icon_path(application.icon)\n\n            action = type(\n                \"app_{}\".format(full_name),\n                (ApplicationAction,),\n                {\n                    \"identifier\": \"application.{}\".format(full_name),\n                    \"application\": application,\n                    \"name\": application.name,\n                    \"label\": application.group.label,\n                    \"label_variant\": application.label,\n                    \"group\": None,\n                    \"icon\": icon,\n                    \"color\": getattr(application, \"color\", None),\n                    \"order\": getattr(application, \"order\", None) or 0,\n                    \"data\": {}\n                }\n            )\n            actions.append(action)\n        return actions\n\n    def launch_application(\n        self, app_name, project_name, folder_path, task_name\n    ):\n        \"\"\"Launch application.\n\n        Args:\n            app_name (str): Full application name e.g. 'maya/2024'.\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n\n        \"\"\"\n        ensure_addons_are_process_ready(\n            addon_name=self.name,\n            addon_version=self.version,\n            project_name=project_name,\n        )\n        headless = is_headless_mode_enabled()\n\n        # TODO handle raise errors\n        failed = True\n        message = None\n        detail = None\n        try:\n            app_manager = self.get_applications_manager()\n            app_manager.launch(\n                app_name,\n                project_name=project_name,\n                folder_path=folder_path,\n                task_name=task_name,\n            )\n            failed = False\n\n        except (\n            ApplicationLaunchFailed,\n            ApplicationExecutableNotFound,\n            ApplicationNotFound,\n        ) as exc:\n            message = str(exc)\n            self.log.warning(f\"Application launch failed: {message}\")\n\n        except Exception as exc:\n            message = \"An unexpected error happened\"\n            detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n            self.log.warning(\n                f\"Application launch failed: {str(exc)}\",\n                exc_info=True\n            )\n\n        if not failed:\n            return\n\n        if not headless:\n            self._show_launch_error_dialog(message, detail)\n        sys.exit(1)\n\n    def webserver_initialization(self, manager):\n        \"\"\"Initialize webserver.\n\n        Args:\n            manager (WebServerManager): Webserver manager.\n\n        \"\"\"\n        static_prefix = f\"/addons/{self.name}/icons\"\n        manager.add_static(\n            static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n        )\n\n    # --- CLI ---\n    def cli(self, addon_click_group):\n        main_group = click_wrap.group(\n            self._cli_main, name=self.name, help=\"Applications addon\"\n        )\n        (\n            main_group.command(\n                self._cli_extract_environments,\n                name=\"extractenvironments\",\n                help=(\n                    \"Extract environment variables for context into json file\"\n                )\n            )\n            .argument(\"output_json_path\")\n            .option(\"--project\", help=\"Project name\", default=None)\n            .option(\"--folder\", help=\"Folder path\", default=None)\n            .option(\"--task\", help=\"Task name\", default=None)\n            .option(\"--app\", help=\"Full application name\", default=None)\n            .option(\n                \"--envgroup\",\n                help=\"Environment group (e.g. \\\"farm\\\")\",\n                default=None\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_context_names,\n                name=\"launch\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--folder\", required=True, help=\"Folder path\")\n            .option(\"--task\", required=True, help=\"Task name\")\n        )\n        # Convert main command to click object and add it to parent group\n        (\n            main_group.command(\n                self._cli_launch_with_task_id,\n                name=\"launch-by-id\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--task-id\", required=True, help=\"Task id\")\n        )\n        # Convert main command to click object and add it to parent group\n        addon_click_group.add_command(\n            main_group.to_click_obj()\n        )\n\n    def _cli_main(self):\n        pass\n\n    def _cli_extract_environments(\n        self, output_json_path, project, folder, task, app, envgroup\n    ):\n        \"\"\"Produces json file with environment based on project and app.\n\n        Called by farm integration to propagate environment into farm jobs.\n\n        Args:\n            output_json_path (str): Output json file path.\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n            envgroup (str): Environment group.\n\n        \"\"\"\n        if all((project, folder, task, app)):\n            env = self.get_farm_publish_environment_variables(\n                project, folder, task, app, env_group=envgroup,\n            )\n        else:\n            env = os.environ.copy()\n\n        output_dir = os.path.dirname(output_json_path)\n        os.makedirs(output_dir, exist_ok=True)\n\n        with open(output_json_path, \"w\") as file_stream:\n            json.dump(env, file_stream, indent=4)\n\n    def _cli_launch_context_names(self, project, folder, task, app):\n        \"\"\"Launch application.\n\n        Args:\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n\n        \"\"\"\n        self.launch_application(app, project, folder, task)\n\n\n    def _cli_launch_with_task_id(self, project, task_id, app):\n        \"\"\"Launch application.\n\n        Args:\n            project (str): Project name.\n            task_id (str): Task id.\n            app (str): Full application name e.g. 'maya/2024'.\n\n        \"\"\"\n        task_entity = ayon_api.get_task_by_id(\n            project, task_id, fields={\"name\", \"folderId\"}\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project, task_entity[\"folderId\"], fields={\"path\"}\n        )\n        self.launch_application(\n            app, project, folder_entity[\"path\"], task_entity[\"name\"]\n        )\n\n    def _show_launch_error_dialog(self, message, detail):\n        script_path = os.path.join(\n            APPLICATIONS_ADDON_ROOT, \"ui\", \"launch_failed_dialog.py\"\n        )\n        with tempfile.NamedTemporaryFile(\"w\", delete=False) as tmp:\n            tmp_path = tmp.name\n            json.dump(\n                {\"message\": message, \"detail\": detail},\n                tmp.file\n            )\n\n        try:\n            run_ayon_launcher_process(\n                \"--skip-bootstrap\",\n                script_path,\n                tmp_path,\n                add_sys_paths=True,\n                creationflags=0,\n            )\n\n        finally:\n            os.remove(tmp_path)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_app_environments_for_context","title":"<code>get_app_environments_for_context(project_name, folder_path, task_name, full_app_name, env_group=None, launch_type=None, env=None)</code>","text":"<p>Calculate environment variables for launch context.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>full_app_name</code> <code>str</code> <p>Full application name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type.</p> <code>None</code> <code>env</code> <code>Optional[dict[str, str]]</code> <p>Environment variables to update.</p> <code>None</code> <p>Returns:</p> Type Description <p>dict[str, str]: Environment variables for context.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_environments_for_context(\n    self,\n    project_name,\n    folder_path,\n    task_name,\n    full_app_name,\n    env_group=None,\n    launch_type=None,\n    env=None,\n):\n    \"\"\"Calculate environment variables for launch context.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        full_app_name (str): Full application name.\n        env_group (Optional[str]): Environment group.\n        launch_type (Optional[str]): Launch type.\n        env (Optional[dict[str, str]]): Environment variables to update.\n\n    Returns:\n        dict[str, str]: Environment variables for context.\n\n    \"\"\"\n    from ayon_applications.utils import get_app_environments_for_context\n\n    if not full_app_name:\n        return {}\n\n    return get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=launch_type,\n        env=env,\n        addons_manager=self.manager\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_app_icon_path","title":"<code>get_app_icon_path(icon_filename)</code>","text":"<p>Get icon path.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon filename.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Icon path or None if not found.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_path(self, icon_filename):\n    \"\"\"Get icon path.\n\n    Args:\n        icon_filename (str): Icon filename.\n\n    Returns:\n        Union[str, None]: Icon path or None if not found.\n\n    \"\"\"\n    return get_app_icon_path(icon_filename)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_app_icon_url","title":"<code>get_app_icon_url(icon_filename, server=False)</code>","text":"<p>Get icon path.</p> <p>Method does not validate if icon filename exist on server.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon name.</p> required <code>server</code> <code>Optional[bool]</code> <p>Return url to AYON server.</p> <code>False</code> <p>Returns:</p> Type Description <p>Union[str, None]: Icon path or None is server url is not available.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_url(self, icon_filename, server=False):\n    \"\"\"Get icon path.\n\n    Method does not validate if icon filename exist on server.\n\n    Args:\n        icon_filename (str): Icon name.\n        server (Optional[bool]): Return url to AYON server.\n\n    Returns:\n        Union[str, None]: Icon path or None is server url is not\n            available.\n\n    \"\"\"\n    if not icon_filename:\n        return None\n    icon_name = os.path.basename(icon_filename)\n    if server:\n        base_url = ayon_api.get_base_url()\n        return (\n            f\"{base_url}/addons/{self.name}/{self.version}\"\n            f\"/public/icons/{icon_name}\"\n        )\n    server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n    if not server_url:\n        return None\n    return \"/\".join([\n        server_url, \"addons\", self.name, \"icons\", icon_name\n    ])\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_applications_action_classes","title":"<code>get_applications_action_classes()</code>","text":"<p>Get application action classes for launcher tool.</p> <p>This method should be used only by launcher tool. Please do not use it in other places as its implementation is not optimal, and might change or be removed.</p> <p>Returns:</p> Type Description <p>list[ApplicationAction]: List of application action classes.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_applications_action_classes(self):\n    \"\"\"Get application action classes for launcher tool.\n\n    This method should be used only by launcher tool. Please do not use it\n    in other places as its implementation is not optimal, and might\n    change or be removed.\n\n    Returns:\n        list[ApplicationAction]: List of application action classes.\n\n    \"\"\"\n    from .action import ApplicationAction\n\n    actions = []\n\n    manager = self.get_applications_manager()\n    for full_name, application in manager.applications.items():\n        if not application.enabled:\n            continue\n\n        icon = self.get_app_icon_path(application.icon)\n\n        action = type(\n            \"app_{}\".format(full_name),\n            (ApplicationAction,),\n            {\n                \"identifier\": \"application.{}\".format(full_name),\n                \"application\": application,\n                \"name\": application.name,\n                \"label\": application.group.label,\n                \"label_variant\": application.label,\n                \"group\": None,\n                \"icon\": icon,\n                \"color\": getattr(application, \"color\", None),\n                \"order\": getattr(application, \"order\", None) or 0,\n                \"data\": {}\n            }\n        )\n        actions.append(action)\n    return actions\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_applications_manager","title":"<code>get_applications_manager(settings=None)</code>","text":"<p>Get applications manager.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Optional[dict]</code> <p>Studio/project settings.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ApplicationManager</code> <p>Applications manager.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_applications_manager(self, settings=None):\n    \"\"\"Get applications manager.\n\n    Args:\n        settings (Optional[dict]): Studio/project settings.\n\n    Returns:\n        ApplicationManager: Applications manager.\n\n    \"\"\"\n    return ApplicationManager(settings)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.get_farm_publish_environment_variables","title":"<code>get_farm_publish_environment_variables(project_name, folder_path, task_name, full_app_name=None, env_group=None)</code>","text":"<p>Calculate environment variables for farm publish.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>full_app_name</code> <code>Optional[str]</code> <p>Full application name. Value from environment variable 'AYON_APP_NAME' is used if 'None' is passed.</p> <code>None</code> <p>Returns:</p> Type Description <p>dict[str, str]: Environment variables for farm publish.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_farm_publish_environment_variables(\n    self,\n    project_name,\n    folder_path,\n    task_name,\n    full_app_name=None,\n    env_group=None,\n):\n    \"\"\"Calculate environment variables for farm publish.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        env_group (Optional[str]): Environment group.\n        full_app_name (Optional[str]): Full application name. Value from\n            environment variable 'AYON_APP_NAME' is used if 'None' is\n            passed.\n\n    Returns:\n        dict[str, str]: Environment variables for farm publish.\n\n    \"\"\"\n    if full_app_name is None:\n        full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n    return self.get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=LaunchTypes.farm_publish\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.launch_application","title":"<code>launch_application(app_name, project_name, folder_path, task_name)</code>","text":"<p>Launch application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Full application name e.g. 'maya/2024'.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def launch_application(\n    self, app_name, project_name, folder_path, task_name\n):\n    \"\"\"Launch application.\n\n    Args:\n        app_name (str): Full application name e.g. 'maya/2024'.\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n\n    \"\"\"\n    ensure_addons_are_process_ready(\n        addon_name=self.name,\n        addon_version=self.version,\n        project_name=project_name,\n    )\n    headless = is_headless_mode_enabled()\n\n    # TODO handle raise errors\n    failed = True\n    message = None\n    detail = None\n    try:\n        app_manager = self.get_applications_manager()\n        app_manager.launch(\n            app_name,\n            project_name=project_name,\n            folder_path=folder_path,\n            task_name=task_name,\n        )\n        failed = False\n\n    except (\n        ApplicationLaunchFailed,\n        ApplicationExecutableNotFound,\n        ApplicationNotFound,\n    ) as exc:\n        message = str(exc)\n        self.log.warning(f\"Application launch failed: {message}\")\n\n    except Exception as exc:\n        message = \"An unexpected error happened\"\n        detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n        self.log.warning(\n            f\"Application launch failed: {str(exc)}\",\n            exc_info=True\n        )\n\n    if not failed:\n        return\n\n    if not headless:\n        self._show_launch_error_dialog(message, detail)\n    sys.exit(1)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.ApplicationsAddon.webserver_initialization","title":"<code>webserver_initialization(manager)</code>","text":"<p>Initialize webserver.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>WebServerManager</code> <p>Webserver manager.</p> required Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def webserver_initialization(self, manager):\n    \"\"\"Initialize webserver.\n\n    Args:\n        manager (WebServerManager): Webserver manager.\n\n    \"\"\"\n    static_prefix = f\"/addons/{self.name}/icons\"\n    manager.add_static(\n        static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.EnvironmentTool","title":"<code>EnvironmentTool</code>","text":"<p>Hold information about application tool.</p> <p>Structure of tool information.</p> <p>Parameters:</p> Name Type Description Default <code>variant_data</code> <code>dict</code> <p>Variant data with environments and host and app variant filters.</p> required <code>group</code> <code>EnvironmentToolGroup</code> <p>Name of group which wraps tool.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentTool:\n    \"\"\"Hold information about application tool.\n\n    Structure of tool information.\n\n    Args:\n        variant_data (dict): Variant data with environments and\n            host and app variant filters.\n        group (EnvironmentToolGroup): Name of group which wraps tool.\n    \"\"\"\n\n    def __init__(self, variant_data, group):\n        # Backwards compatibility 3.9.1 - 3.9.2\n        # - 'variant_data' contained only environments but contain also host\n        #   and application variant filters\n        name = variant_data[\"name\"]\n        label = variant_data[\"label\"]\n        host_names = variant_data[\"host_names\"]\n        app_variants = variant_data[\"app_variants\"]\n\n        environment = {}\n        try:\n            environment = json.loads(variant_data[\"environment\"])\n        except Exception:\n            pass\n\n        self.host_names = host_names\n        self.app_variants = app_variants\n        self.name = name\n        self.variant_label = label\n        self.label = \" \".join((group.label, label))\n        self.group = group\n\n        self._environment = environment\n        self.full_name = \"/\".join((group.name, name))\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.full_name)\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n\n    def is_valid_for_app(self, app):\n        \"\"\"Is tool valid for application.\n\n        Args:\n            app (Application): Application for which are prepared environments.\n        \"\"\"\n        if self.app_variants and app.full_name not in self.app_variants:\n            return False\n\n        if self.host_names and app.host_name not in self.host_names:\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.EnvironmentTool.is_valid_for_app","title":"<code>is_valid_for_app(app)</code>","text":"<p>Is tool valid for application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>Application for which are prepared environments.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def is_valid_for_app(self, app):\n    \"\"\"Is tool valid for application.\n\n    Args:\n        app (Application): Application for which are prepared environments.\n    \"\"\"\n    if self.app_variants and app.full_name not in self.app_variants:\n        return False\n\n    if self.host_names and app.host_name not in self.host_names:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.EnvironmentToolGroup","title":"<code>EnvironmentToolGroup</code>","text":"<p>Hold information about environment tool group.</p> <p>Environment tool group may hold different variants of same tool and set environments that are same for all of them.</p> <p>e.g. \"mtoa\" may have different versions but all environments except one     are same.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Group information with variants.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that creates the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentToolGroup:\n    \"\"\"Hold information about environment tool group.\n\n    Environment tool group may hold different variants of same tool and set\n    environments that are same for all of them.\n\n    e.g. \"mtoa\" may have different versions but all environments except one\n        are same.\n\n    Args:\n        data (dict): Group information with variants.\n        manager (ApplicationManager): Manager that creates the group.\n    \"\"\"\n\n    def __init__(self, data, manager):\n        name = data[\"name\"]\n        label = data[\"label\"]\n\n        self.name = name\n        self.label = label\n        self._data = data\n        self.manager = manager\n\n        environment = {}\n        try:\n            environment = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = environment\n\n        variants = data.get(\"variants\") or []\n        variants_by_name = {}\n        for variant_data in variants:\n            tool = EnvironmentTool(variant_data, self)\n            variants_by_name[tool.name] = tool\n        self.variants = variants_by_name\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.name)\n\n    def __iter__(self):\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.LaunchTypes","title":"<code>LaunchTypes</code>","text":"<p>Launch types are filters for pre/post-launch hooks.</p> <p>Please use these variables in case they'll change values.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class LaunchTypes:\n    \"\"\"Launch types are filters for pre/post-launch hooks.\n\n    Please use these variables in case they'll change values.\n    \"\"\"\n\n    # Local launch - application is launched on local machine\n    local = \"local\"\n    # Farm render job - application is on farm\n    farm_render = \"farm-render\"\n    # Farm publish job - integration post-render job\n    farm_publish = \"farm-publish\"\n    # Remote launch - application is launched on remote machine from which\n    #     can be started publishing\n    remote = \"remote\"\n    # Automated launch - application is launched with automated publishing\n    automated = \"automated\"\n</code></pre>"},{"location":"autoapi/client/ayon_applications/index.html#client.ayon_applications.UndefinedApplicationExecutable","title":"<code>UndefinedApplicationExecutable</code>","text":"<p>               Bases: <code>ApplicationExecutable</code></p> <p>Some applications do not require executable path from settings.</p> <p>In that case this class is used to \"fake\" existing executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class UndefinedApplicationExecutable(ApplicationExecutable):\n    \"\"\"Some applications do not require executable path from settings.\n\n    In that case this class is used to \"fake\" existing executable.\n    \"\"\"\n    def __init__(self):\n        pass\n\n    def __str__(self):\n        return self.__class__.__name__\n\n    def __repr__(self):\n        return \"&lt;{}&gt;\".format(self.__class__.__name__)\n\n    def as_args(self):\n        return []\n\n    def exists(self):\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_applications/action.html#client.ayon_applications.action.ApplicationAction","title":"<code>ApplicationAction</code>","text":"<p>               Bases: <code>LauncherAction</code></p> <p>Action to launch an application.</p> <p>Application action based on 'ApplicationManager' system.</p> <p>Handling of applications in launcher is not ideal and should be completely redone from scratch. This is just a temporary solution to keep backwards compatibility with AYON launcher.</p> Todos <p>Move handling of errors to frontend.</p> Source code in <code>client/ayon_applications/action.py</code> <pre><code>class ApplicationAction(LauncherAction):\n    \"\"\"Action to launch an application.\n\n    Application action based on 'ApplicationManager' system.\n\n    Handling of applications in launcher is not ideal and should be completely\n    redone from scratch. This is just a temporary solution to keep backwards\n    compatibility with AYON launcher.\n\n    Todos:\n        Move handling of errors to frontend.\n    \"\"\"\n\n    # Application object\n    application = None\n    # Action attributes\n    name = None\n    label = None\n    label_variant = None\n    group = None\n    icon = None\n    color = None\n    order = 0\n    data = {}\n    project_settings = {}\n    project_entities = {}\n\n    _log = None\n\n    # --- For compatibility for combinations of new and old ayon-core ---\n    project_settings_cache = NestedCacheItem(\n        levels=1, default_factory=dict, lifetime=20\n    )\n    project_entities_cache = NestedCacheItem(\n        levels=1, default_factory=dict, lifetime=20\n    )\n\n    @classmethod\n    def _app_get_project_settings(cls, selection):\n        project_name = selection.project_name\n        if project_name in ApplicationAction.project_settings:\n            return ApplicationAction.project_settings[project_name]\n\n        if hasattr(selection, \"get_project_settings\"):\n            return selection.get_project_settings()\n\n        cache = ApplicationAction.project_settings_cache[project_name]\n        if not cache.is_valid:\n            if project_name:\n                settings = get_project_settings(project_name)\n            else:\n                settings = get_studio_settings()\n            cache.update_data(settings)\n        return copy.deepcopy(cache.get_data())\n\n    @property\n    def log(self):\n        if self._log is None:\n            self._log = Logger.get_logger(self.__class__.__name__)\n        return self._log\n\n    def is_compatible(self, selection):\n        if not selection.is_task_selected:\n            return False\n\n        project_settings = self._app_get_project_settings(selection)\n        apps = get_applications_for_context(\n            selection.project_name,\n            selection.get_folder_entity(),\n            selection.get_task_entity(),\n            project_settings=project_settings,\n            project_entity=selection.get_project_entity(),\n        )\n        if self.application.full_name not in apps:\n            return False\n\n        only_available = project_settings[\"applications\"][\"only_available\"]\n        if only_available and not self.application.find_executable():\n            return False\n        return True\n\n    def _show_message_box(self, title, message, details=None):\n        from qtpy import QtWidgets, QtGui\n        from ayon_core import style\n\n        dialog = QtWidgets.QMessageBox()\n        icon = QtGui.QIcon(resources.get_ayon_icon_filepath())\n        dialog.setWindowIcon(icon)\n        dialog.setStyleSheet(style.load_stylesheet())\n        dialog.setWindowTitle(title)\n        dialog.setText(message)\n        if details:\n            dialog.setDetailedText(details)\n        dialog.exec_()\n\n    def process(self, selection, **kwargs):\n        \"\"\"Process the full Application action\"\"\"\n        try:\n            self.application.launch(\n                project_name=selection.project_name,\n                folder_path=selection.folder_path,\n                task_name=selection.task_name,\n                **self.data\n            )\n\n        except ApplicationExecutableNotFound as exc:\n            details = exc.details\n            msg = exc.msg\n            log_msg = str(msg)\n            if details:\n                log_msg += \"\\n\" + details\n            self.log.warning(log_msg)\n            self._show_message_box(\n                \"Application executable not found\", msg, details\n            )\n\n        except ApplicationLaunchFailed as exc:\n            msg = str(exc)\n            self.log.warning(msg, exc_info=True)\n            self._show_message_box(\"Application launch failed\", msg)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/action.html#client.ayon_applications.action.ApplicationAction.process","title":"<code>process(selection, **kwargs)</code>","text":"<p>Process the full Application action</p> Source code in <code>client/ayon_applications/action.py</code> <pre><code>def process(self, selection, **kwargs):\n    \"\"\"Process the full Application action\"\"\"\n    try:\n        self.application.launch(\n            project_name=selection.project_name,\n            folder_path=selection.folder_path,\n            task_name=selection.task_name,\n            **self.data\n        )\n\n    except ApplicationExecutableNotFound as exc:\n        details = exc.details\n        msg = exc.msg\n        log_msg = str(msg)\n        if details:\n            log_msg += \"\\n\" + details\n        self.log.warning(log_msg)\n        self._show_message_box(\n            \"Application executable not found\", msg, details\n        )\n\n    except ApplicationLaunchFailed as exc:\n        msg = str(exc)\n        self.log.warning(msg, exc_info=True)\n        self._show_message_box(\"Application launch failed\", msg)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IPluginPaths</code></p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>class ApplicationsAddon(AYONAddon, IPluginPaths):\n    name = \"applications\"\n    version = __version__\n\n    def initialize(self, settings):\n        # TODO remove when addon is removed from ayon-core\n        self.enabled = self.name in settings\n\n    def get_app_environments_for_context(\n        self,\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=None,\n        launch_type=None,\n        env=None,\n    ):\n        \"\"\"Calculate environment variables for launch context.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            full_app_name (str): Full application name.\n            env_group (Optional[str]): Environment group.\n            launch_type (Optional[str]): Launch type.\n            env (Optional[dict[str, str]]): Environment variables to update.\n\n        Returns:\n            dict[str, str]: Environment variables for context.\n\n        \"\"\"\n        from ayon_applications.utils import get_app_environments_for_context\n\n        if not full_app_name:\n            return {}\n\n        return get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=launch_type,\n            env=env,\n            addons_manager=self.manager\n        )\n\n    def get_farm_publish_environment_variables(\n        self,\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name=None,\n        env_group=None,\n    ):\n        \"\"\"Calculate environment variables for farm publish.\n\n        Args:\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n            env_group (Optional[str]): Environment group.\n            full_app_name (Optional[str]): Full application name. Value from\n                environment variable 'AYON_APP_NAME' is used if 'None' is\n                passed.\n\n        Returns:\n            dict[str, str]: Environment variables for farm publish.\n\n        \"\"\"\n        if full_app_name is None:\n            full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n        return self.get_app_environments_for_context(\n            project_name,\n            folder_path,\n            task_name,\n            full_app_name,\n            env_group=env_group,\n            launch_type=LaunchTypes.farm_publish\n        )\n\n    def get_applications_manager(self, settings=None):\n        \"\"\"Get applications manager.\n\n        Args:\n            settings (Optional[dict]): Studio/project settings.\n\n        Returns:\n            ApplicationManager: Applications manager.\n\n        \"\"\"\n        return ApplicationManager(settings)\n\n    def get_plugin_paths(self):\n        plugins_dir = os.path.join(APPLICATIONS_ADDON_ROOT, \"plugins\")\n        return {\n            \"actions\": [os.path.join(plugins_dir, \"launcher_actions\")],\n            \"publish\": [os.path.join(plugins_dir, \"publish\")]\n        }\n\n    def get_launch_hook_paths(self, app):\n        return [\n            os.path.join(APPLICATIONS_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_app_icon_path(self, icon_filename):\n        \"\"\"Get icon path.\n\n        Args:\n            icon_filename (str): Icon filename.\n\n        Returns:\n            Union[str, None]: Icon path or None if not found.\n\n        \"\"\"\n        return get_app_icon_path(icon_filename)\n\n    def get_app_icon_url(self, icon_filename, server=False):\n        \"\"\"Get icon path.\n\n        Method does not validate if icon filename exist on server.\n\n        Args:\n            icon_filename (str): Icon name.\n            server (Optional[bool]): Return url to AYON server.\n\n        Returns:\n            Union[str, None]: Icon path or None is server url is not\n                available.\n\n        \"\"\"\n        if not icon_filename:\n            return None\n        icon_name = os.path.basename(icon_filename)\n        if server:\n            base_url = ayon_api.get_base_url()\n            return (\n                f\"{base_url}/addons/{self.name}/{self.version}\"\n                f\"/public/icons/{icon_name}\"\n            )\n        server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n        if not server_url:\n            return None\n        return \"/\".join([\n            server_url, \"addons\", self.name, \"icons\", icon_name\n        ])\n\n    def get_applications_action_classes(self):\n        \"\"\"Get application action classes for launcher tool.\n\n        This method should be used only by launcher tool. Please do not use it\n        in other places as its implementation is not optimal, and might\n        change or be removed.\n\n        Returns:\n            list[ApplicationAction]: List of application action classes.\n\n        \"\"\"\n        from .action import ApplicationAction\n\n        actions = []\n\n        manager = self.get_applications_manager()\n        for full_name, application in manager.applications.items():\n            if not application.enabled:\n                continue\n\n            icon = self.get_app_icon_path(application.icon)\n\n            action = type(\n                \"app_{}\".format(full_name),\n                (ApplicationAction,),\n                {\n                    \"identifier\": \"application.{}\".format(full_name),\n                    \"application\": application,\n                    \"name\": application.name,\n                    \"label\": application.group.label,\n                    \"label_variant\": application.label,\n                    \"group\": None,\n                    \"icon\": icon,\n                    \"color\": getattr(application, \"color\", None),\n                    \"order\": getattr(application, \"order\", None) or 0,\n                    \"data\": {}\n                }\n            )\n            actions.append(action)\n        return actions\n\n    def launch_application(\n        self, app_name, project_name, folder_path, task_name\n    ):\n        \"\"\"Launch application.\n\n        Args:\n            app_name (str): Full application name e.g. 'maya/2024'.\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n\n        \"\"\"\n        ensure_addons_are_process_ready(\n            addon_name=self.name,\n            addon_version=self.version,\n            project_name=project_name,\n        )\n        headless = is_headless_mode_enabled()\n\n        # TODO handle raise errors\n        failed = True\n        message = None\n        detail = None\n        try:\n            app_manager = self.get_applications_manager()\n            app_manager.launch(\n                app_name,\n                project_name=project_name,\n                folder_path=folder_path,\n                task_name=task_name,\n            )\n            failed = False\n\n        except (\n            ApplicationLaunchFailed,\n            ApplicationExecutableNotFound,\n            ApplicationNotFound,\n        ) as exc:\n            message = str(exc)\n            self.log.warning(f\"Application launch failed: {message}\")\n\n        except Exception as exc:\n            message = \"An unexpected error happened\"\n            detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n            self.log.warning(\n                f\"Application launch failed: {str(exc)}\",\n                exc_info=True\n            )\n\n        if not failed:\n            return\n\n        if not headless:\n            self._show_launch_error_dialog(message, detail)\n        sys.exit(1)\n\n    def webserver_initialization(self, manager):\n        \"\"\"Initialize webserver.\n\n        Args:\n            manager (WebServerManager): Webserver manager.\n\n        \"\"\"\n        static_prefix = f\"/addons/{self.name}/icons\"\n        manager.add_static(\n            static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n        )\n\n    # --- CLI ---\n    def cli(self, addon_click_group):\n        main_group = click_wrap.group(\n            self._cli_main, name=self.name, help=\"Applications addon\"\n        )\n        (\n            main_group.command(\n                self._cli_extract_environments,\n                name=\"extractenvironments\",\n                help=(\n                    \"Extract environment variables for context into json file\"\n                )\n            )\n            .argument(\"output_json_path\")\n            .option(\"--project\", help=\"Project name\", default=None)\n            .option(\"--folder\", help=\"Folder path\", default=None)\n            .option(\"--task\", help=\"Task name\", default=None)\n            .option(\"--app\", help=\"Full application name\", default=None)\n            .option(\n                \"--envgroup\",\n                help=\"Environment group (e.g. \\\"farm\\\")\",\n                default=None\n            )\n        )\n        (\n            main_group.command(\n                self._cli_launch_context_names,\n                name=\"launch\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--folder\", required=True, help=\"Folder path\")\n            .option(\"--task\", required=True, help=\"Task name\")\n        )\n        # Convert main command to click object and add it to parent group\n        (\n            main_group.command(\n                self._cli_launch_with_task_id,\n                name=\"launch-by-id\",\n                help=\"Launch application\"\n            )\n            .option(\"--app\", required=True, help=\"Full application name\")\n            .option(\"--project\", required=True, help=\"Project name\")\n            .option(\"--task-id\", required=True, help=\"Task id\")\n        )\n        # Convert main command to click object and add it to parent group\n        addon_click_group.add_command(\n            main_group.to_click_obj()\n        )\n\n    def _cli_main(self):\n        pass\n\n    def _cli_extract_environments(\n        self, output_json_path, project, folder, task, app, envgroup\n    ):\n        \"\"\"Produces json file with environment based on project and app.\n\n        Called by farm integration to propagate environment into farm jobs.\n\n        Args:\n            output_json_path (str): Output json file path.\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n            envgroup (str): Environment group.\n\n        \"\"\"\n        if all((project, folder, task, app)):\n            env = self.get_farm_publish_environment_variables(\n                project, folder, task, app, env_group=envgroup,\n            )\n        else:\n            env = os.environ.copy()\n\n        output_dir = os.path.dirname(output_json_path)\n        os.makedirs(output_dir, exist_ok=True)\n\n        with open(output_json_path, \"w\") as file_stream:\n            json.dump(env, file_stream, indent=4)\n\n    def _cli_launch_context_names(self, project, folder, task, app):\n        \"\"\"Launch application.\n\n        Args:\n            project (str): Project name.\n            folder (str): Folder path.\n            task (str): Task name.\n            app (str): Full application name e.g. 'maya/2024'.\n\n        \"\"\"\n        self.launch_application(app, project, folder, task)\n\n\n    def _cli_launch_with_task_id(self, project, task_id, app):\n        \"\"\"Launch application.\n\n        Args:\n            project (str): Project name.\n            task_id (str): Task id.\n            app (str): Full application name e.g. 'maya/2024'.\n\n        \"\"\"\n        task_entity = ayon_api.get_task_by_id(\n            project, task_id, fields={\"name\", \"folderId\"}\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project, task_entity[\"folderId\"], fields={\"path\"}\n        )\n        self.launch_application(\n            app, project, folder_entity[\"path\"], task_entity[\"name\"]\n        )\n\n    def _show_launch_error_dialog(self, message, detail):\n        script_path = os.path.join(\n            APPLICATIONS_ADDON_ROOT, \"ui\", \"launch_failed_dialog.py\"\n        )\n        with tempfile.NamedTemporaryFile(\"w\", delete=False) as tmp:\n            tmp_path = tmp.name\n            json.dump(\n                {\"message\": message, \"detail\": detail},\n                tmp.file\n            )\n\n        try:\n            run_ayon_launcher_process(\n                \"--skip-bootstrap\",\n                script_path,\n                tmp_path,\n                add_sys_paths=True,\n                creationflags=0,\n            )\n\n        finally:\n            os.remove(tmp_path)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_app_environments_for_context","title":"<code>get_app_environments_for_context(project_name, folder_path, task_name, full_app_name, env_group=None, launch_type=None, env=None)</code>","text":"<p>Calculate environment variables for launch context.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>full_app_name</code> <code>str</code> <p>Full application name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type.</p> <code>None</code> <code>env</code> <code>Optional[dict[str, str]]</code> <p>Environment variables to update.</p> <code>None</code> <p>Returns:</p> Type Description <p>dict[str, str]: Environment variables for context.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_environments_for_context(\n    self,\n    project_name,\n    folder_path,\n    task_name,\n    full_app_name,\n    env_group=None,\n    launch_type=None,\n    env=None,\n):\n    \"\"\"Calculate environment variables for launch context.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        full_app_name (str): Full application name.\n        env_group (Optional[str]): Environment group.\n        launch_type (Optional[str]): Launch type.\n        env (Optional[dict[str, str]]): Environment variables to update.\n\n    Returns:\n        dict[str, str]: Environment variables for context.\n\n    \"\"\"\n    from ayon_applications.utils import get_app_environments_for_context\n\n    if not full_app_name:\n        return {}\n\n    return get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=launch_type,\n        env=env,\n        addons_manager=self.manager\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_app_icon_path","title":"<code>get_app_icon_path(icon_filename)</code>","text":"<p>Get icon path.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon filename.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Icon path or None if not found.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_path(self, icon_filename):\n    \"\"\"Get icon path.\n\n    Args:\n        icon_filename (str): Icon filename.\n\n    Returns:\n        Union[str, None]: Icon path or None if not found.\n\n    \"\"\"\n    return get_app_icon_path(icon_filename)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_app_icon_url","title":"<code>get_app_icon_url(icon_filename, server=False)</code>","text":"<p>Get icon path.</p> <p>Method does not validate if icon filename exist on server.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon name.</p> required <code>server</code> <code>Optional[bool]</code> <p>Return url to AYON server.</p> <code>False</code> <p>Returns:</p> Type Description <p>Union[str, None]: Icon path or None is server url is not available.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_app_icon_url(self, icon_filename, server=False):\n    \"\"\"Get icon path.\n\n    Method does not validate if icon filename exist on server.\n\n    Args:\n        icon_filename (str): Icon name.\n        server (Optional[bool]): Return url to AYON server.\n\n    Returns:\n        Union[str, None]: Icon path or None is server url is not\n            available.\n\n    \"\"\"\n    if not icon_filename:\n        return None\n    icon_name = os.path.basename(icon_filename)\n    if server:\n        base_url = ayon_api.get_base_url()\n        return (\n            f\"{base_url}/addons/{self.name}/{self.version}\"\n            f\"/public/icons/{icon_name}\"\n        )\n    server_url = os.getenv(\"AYON_WEBSERVER_URL\")\n    if not server_url:\n        return None\n    return \"/\".join([\n        server_url, \"addons\", self.name, \"icons\", icon_name\n    ])\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_applications_action_classes","title":"<code>get_applications_action_classes()</code>","text":"<p>Get application action classes for launcher tool.</p> <p>This method should be used only by launcher tool. Please do not use it in other places as its implementation is not optimal, and might change or be removed.</p> <p>Returns:</p> Type Description <p>list[ApplicationAction]: List of application action classes.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_applications_action_classes(self):\n    \"\"\"Get application action classes for launcher tool.\n\n    This method should be used only by launcher tool. Please do not use it\n    in other places as its implementation is not optimal, and might\n    change or be removed.\n\n    Returns:\n        list[ApplicationAction]: List of application action classes.\n\n    \"\"\"\n    from .action import ApplicationAction\n\n    actions = []\n\n    manager = self.get_applications_manager()\n    for full_name, application in manager.applications.items():\n        if not application.enabled:\n            continue\n\n        icon = self.get_app_icon_path(application.icon)\n\n        action = type(\n            \"app_{}\".format(full_name),\n            (ApplicationAction,),\n            {\n                \"identifier\": \"application.{}\".format(full_name),\n                \"application\": application,\n                \"name\": application.name,\n                \"label\": application.group.label,\n                \"label_variant\": application.label,\n                \"group\": None,\n                \"icon\": icon,\n                \"color\": getattr(application, \"color\", None),\n                \"order\": getattr(application, \"order\", None) or 0,\n                \"data\": {}\n            }\n        )\n        actions.append(action)\n    return actions\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_applications_manager","title":"<code>get_applications_manager(settings=None)</code>","text":"<p>Get applications manager.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Optional[dict]</code> <p>Studio/project settings.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ApplicationManager</code> <p>Applications manager.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_applications_manager(self, settings=None):\n    \"\"\"Get applications manager.\n\n    Args:\n        settings (Optional[dict]): Studio/project settings.\n\n    Returns:\n        ApplicationManager: Applications manager.\n\n    \"\"\"\n    return ApplicationManager(settings)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.get_farm_publish_environment_variables","title":"<code>get_farm_publish_environment_variables(project_name, folder_path, task_name, full_app_name=None, env_group=None)</code>","text":"<p>Calculate environment variables for farm publish.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment group.</p> <code>None</code> <code>full_app_name</code> <code>Optional[str]</code> <p>Full application name. Value from environment variable 'AYON_APP_NAME' is used if 'None' is passed.</p> <code>None</code> <p>Returns:</p> Type Description <p>dict[str, str]: Environment variables for farm publish.</p> Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def get_farm_publish_environment_variables(\n    self,\n    project_name,\n    folder_path,\n    task_name,\n    full_app_name=None,\n    env_group=None,\n):\n    \"\"\"Calculate environment variables for farm publish.\n\n    Args:\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n        env_group (Optional[str]): Environment group.\n        full_app_name (Optional[str]): Full application name. Value from\n            environment variable 'AYON_APP_NAME' is used if 'None' is\n            passed.\n\n    Returns:\n        dict[str, str]: Environment variables for farm publish.\n\n    \"\"\"\n    if full_app_name is None:\n        full_app_name = os.getenv(\"AYON_APP_NAME\")\n\n    return self.get_app_environments_for_context(\n        project_name,\n        folder_path,\n        task_name,\n        full_app_name,\n        env_group=env_group,\n        launch_type=LaunchTypes.farm_publish\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.launch_application","title":"<code>launch_application(app_name, project_name, folder_path, task_name)</code>","text":"<p>Launch application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Full application name e.g. 'maya/2024'.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def launch_application(\n    self, app_name, project_name, folder_path, task_name\n):\n    \"\"\"Launch application.\n\n    Args:\n        app_name (str): Full application name e.g. 'maya/2024'.\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (str): Task name.\n\n    \"\"\"\n    ensure_addons_are_process_ready(\n        addon_name=self.name,\n        addon_version=self.version,\n        project_name=project_name,\n    )\n    headless = is_headless_mode_enabled()\n\n    # TODO handle raise errors\n    failed = True\n    message = None\n    detail = None\n    try:\n        app_manager = self.get_applications_manager()\n        app_manager.launch(\n            app_name,\n            project_name=project_name,\n            folder_path=folder_path,\n            task_name=task_name,\n        )\n        failed = False\n\n    except (\n        ApplicationLaunchFailed,\n        ApplicationExecutableNotFound,\n        ApplicationNotFound,\n    ) as exc:\n        message = str(exc)\n        self.log.warning(f\"Application launch failed: {message}\")\n\n    except Exception as exc:\n        message = \"An unexpected error happened\"\n        detail = \"\".join(traceback.format_exception(*sys.exc_info()))\n        self.log.warning(\n            f\"Application launch failed: {str(exc)}\",\n            exc_info=True\n        )\n\n    if not failed:\n        return\n\n    if not headless:\n        self._show_launch_error_dialog(message, detail)\n    sys.exit(1)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/addon.html#client.ayon_applications.addon.ApplicationsAddon.webserver_initialization","title":"<code>webserver_initialization(manager)</code>","text":"<p>Initialize webserver.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>WebServerManager</code> <p>Webserver manager.</p> required Source code in <code>client/ayon_applications/addon.py</code> <pre><code>def webserver_initialization(self, manager):\n    \"\"\"Initialize webserver.\n\n    Args:\n        manager (WebServerManager): Webserver manager.\n\n    \"\"\"\n    static_prefix = f\"/addons/{self.name}/icons\"\n    manager.add_static(\n        static_prefix, os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\")\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/constants.html","title":"constants","text":""},{"location":"autoapi/client/ayon_applications/defs.html","title":"defs","text":""},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.Application","title":"<code>Application</code>","text":"<p>Hold information about application.</p> <p>Object by itself does nothing special.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data for the version containing information about executables, variant label or if is enabled. Only required key is <code>executables</code>.</p> required <code>group</code> <code>ApplicationGroup</code> <p>App group object that created the application and under which application belongs.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class Application:\n    \"\"\"Hold information about application.\n\n    Object by itself does nothing special.\n\n    Args:\n        data (dict): Data for the version containing information about\n            executables, variant label or if is enabled.\n            Only required key is `executables`.\n        group (ApplicationGroup): App group object that created the application\n            and under which application belongs.\n\n    \"\"\"\n    def __init__(self, data, group):\n        self._data = data\n        name = data[\"name\"]\n        label = data[\"label\"] or name\n        enabled = False\n        if group.enabled:\n            enabled = data.get(\"enabled\", True)\n\n        if group.label:\n            full_label = \" \".join((group.label, label))\n        else:\n            full_label = label\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n\n        arguments = data[\"arguments\"]\n        if isinstance(arguments, dict):\n            arguments = arguments.get(platform.system().lower())\n\n        if not arguments:\n            arguments = []\n\n        _executables = data[\"executables\"].get(platform.system().lower(), [])\n        executables = [\n            ApplicationExecutable(executable)\n            for executable in _executables\n        ]\n\n        self.group = group\n\n        self.name = name\n        self.label = label\n        self.enabled = enabled\n        self.use_python_2 = data.get(\"use_python_2\", False)\n\n        self.full_name = \"/\".join((group.name, name))\n        self.full_label = full_label\n        self.arguments = arguments\n        self.executables = executables\n        self._environment = env\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.full_name)\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n\n    @property\n    def manager(self):\n        return self.group.manager\n\n    @property\n    def host_name(self):\n        return self.group.host_name\n\n    @property\n    def icon(self):\n        return self.group.icon\n\n    @property\n    def is_host(self):\n        return self.group.is_host\n\n    def find_executable(self):\n        \"\"\"Try to find existing executable for application.\n\n        Returns (str): Path to executable from `executables` or None if any\n            exists.\n        \"\"\"\n        for executable in self.executables:\n            if executable.exists():\n                return executable\n        return None\n\n    def launch(self, *args, **kwargs):\n        \"\"\"Launch the application.\n\n        For this purpose is used manager's launch method to keep logic at one\n        place.\n\n        Arguments must match with manager's launch method. That's why *args\n        **kwargs are used.\n\n        Returns:\n            subprocess.Popen: Return executed process as Popen object.\n        \"\"\"\n        return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.Application.find_executable","title":"<code>find_executable()</code>","text":"<p>Try to find existing executable for application.</p> <p>Returns (str): Path to executable from <code>executables</code> or None if any     exists.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def find_executable(self):\n    \"\"\"Try to find existing executable for application.\n\n    Returns (str): Path to executable from `executables` or None if any\n        exists.\n    \"\"\"\n    for executable in self.executables:\n        if executable.exists():\n            return executable\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.Application.launch","title":"<code>launch(*args, **kwargs)</code>","text":"<p>Launch the application.</p> <p>For this purpose is used manager's launch method to keep logic at one place.</p> <p>Arguments must match with manager's launch method. That's why args *kwargs are used.</p> <p>Returns:</p> Type Description <p>subprocess.Popen: Return executed process as Popen object.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def launch(self, *args, **kwargs):\n    \"\"\"Launch the application.\n\n    For this purpose is used manager's launch method to keep logic at one\n    place.\n\n    Arguments must match with manager's launch method. That's why *args\n    **kwargs are used.\n\n    Returns:\n        subprocess.Popen: Return executed process as Popen object.\n    \"\"\"\n    return self.manager.launch(self.full_name, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.ApplicationExecutable","title":"<code>ApplicationExecutable</code>","text":"<p>Representation of executable loaded from settings.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationExecutable:\n    \"\"\"Representation of executable loaded from settings.\"\"\"\n\n    def __init__(self, executable):\n        # Try to format executable with environments\n        try:\n            executable = executable.format(**os.environ)\n        except Exception:\n            pass\n\n        # On MacOS check if exists path to executable when ends with `.app`\n        # - it is common that path will lead to \"/Applications/Blender\" but\n        #   real path is \"/Applications/Blender.app\"\n        if platform.system().lower() == \"darwin\":\n            executable = self.macos_executable_prep(executable)\n\n        self.executable_path = executable\n\n    def __str__(self):\n        return self.executable_path\n\n    def __repr__(self):\n        return \"&lt;{}&gt; {}\".format(self.__class__.__name__, self.executable_path)\n\n    @staticmethod\n    def macos_executable_prep(executable):\n        \"\"\"Try to find full path to executable file.\n\n        Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n        Having path to '*.app' gives ability to read it's plist info and\n        use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n        Plist is stored in '*.app/Contents/Info.plist'.\n\n        This is because some '*.app' directories don't have same permissions\n        as real executable.\n        \"\"\"\n        # Try to find if there is `.app` file\n        if not os.path.exists(executable):\n            _executable = executable + \".app\"\n            if os.path.exists(_executable):\n                executable = _executable\n\n        # Try to find real executable if executable has `Contents` subfolder\n        contents_dir = os.path.join(executable, \"Contents\")\n        if os.path.exists(contents_dir):\n            executable_filename = None\n            # Load plist file and check for bundle executable\n            plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n            if os.path.exists(plist_filepath):\n                import plistlib\n\n                if hasattr(plistlib, \"load\"):\n                    with open(plist_filepath, \"rb\") as stream:\n                        parsed_plist = plistlib.load(stream)\n                else:\n                    parsed_plist = plistlib.readPlist(plist_filepath)\n                executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n            if executable_filename:\n                executable = os.path.join(\n                    contents_dir, \"MacOS\", executable_filename\n                )\n\n        return executable\n\n    def as_args(self):\n        return [self.executable_path]\n\n    def _realpath(self):\n        \"\"\"Check if path is valid executable path.\"\"\"\n        # Check for executable in PATH\n        result = find_executable(self.executable_path)\n        if result is not None:\n            return result\n\n        # This is not 100% validation but it is better than remove ability to\n        #   launch .bat, .sh or extentionless files\n        if os.path.exists(self.executable_path):\n            return self.executable_path\n        return None\n\n    def exists(self):\n        if not self.executable_path:\n            return False\n        return bool(self._realpath())\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.ApplicationExecutable.macos_executable_prep","title":"<code>macos_executable_prep(executable)</code>  <code>staticmethod</code>","text":"<p>Try to find full path to executable file.</p> <p>Real executable is stored in '*.app/Contents/MacOS/'. <p>Having path to '*.app' gives ability to read it's plist info and use \"CFBundleExecutable\" key from plist to know what is \"executable.\"</p> <p>Plist is stored in '*.app/Contents/Info.plist'.</p> <p>This is because some '*.app' directories don't have same permissions as real executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>@staticmethod\ndef macos_executable_prep(executable):\n    \"\"\"Try to find full path to executable file.\n\n    Real executable is stored in '*.app/Contents/MacOS/&lt;executable&gt;'.\n\n    Having path to '*.app' gives ability to read it's plist info and\n    use \"CFBundleExecutable\" key from plist to know what is \"executable.\"\n\n    Plist is stored in '*.app/Contents/Info.plist'.\n\n    This is because some '*.app' directories don't have same permissions\n    as real executable.\n    \"\"\"\n    # Try to find if there is `.app` file\n    if not os.path.exists(executable):\n        _executable = executable + \".app\"\n        if os.path.exists(_executable):\n            executable = _executable\n\n    # Try to find real executable if executable has `Contents` subfolder\n    contents_dir = os.path.join(executable, \"Contents\")\n    if os.path.exists(contents_dir):\n        executable_filename = None\n        # Load plist file and check for bundle executable\n        plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n        if os.path.exists(plist_filepath):\n            import plistlib\n\n            if hasattr(plistlib, \"load\"):\n                with open(plist_filepath, \"rb\") as stream:\n                    parsed_plist = plistlib.load(stream)\n            else:\n                parsed_plist = plistlib.readPlist(plist_filepath)\n            executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n\n        if executable_filename:\n            executable = os.path.join(\n                contents_dir, \"MacOS\", executable_filename\n            )\n\n    return executable\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.ApplicationGroup","title":"<code>ApplicationGroup</code>","text":"<p>Hold information about application group.</p> <p>Application group wraps different versions(variants) of application. e.g. \"maya\" is group and \"maya_2020\" is variant.</p> <p>Group hold <code>host_name</code> which is implementation name used in AYON. Also holds <code>enabled</code> if whole app group is enabled or <code>icon</code> for application icon path in resources.</p> <p>Group has also <code>environment</code> which hold same environments for all variants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Groups' name.</p> required <code>data</code> <code>dict</code> <p>Group defying data loaded from settings.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that created the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class ApplicationGroup:\n    \"\"\"Hold information about application group.\n\n    Application group wraps different versions(variants) of application.\n    e.g. \"maya\" is group and \"maya_2020\" is variant.\n\n    Group hold `host_name` which is implementation name used in AYON. Also\n    holds `enabled` if whole app group is enabled or `icon` for application\n    icon path in resources.\n\n    Group has also `environment` which hold same environments for all variants.\n\n    Args:\n        name (str): Groups' name.\n        data (dict): Group defying data loaded from settings.\n        manager (ApplicationManager): Manager that created the group.\n    \"\"\"\n    def __init__(self, name, data, manager):\n        icon = ICONS_BY_GROUP_NAME.get(name)\n        if not icon:\n            icon = data.get(\"icon\")\n\n        label = LABELS_BY_GROUP_NAME.get(name)\n        if not label:\n            label = data.get(\"label\")\n\n        self.name = name\n        self.manager = manager\n        self._data = data\n\n        self.enabled = data[\"enabled\"]\n        self.label = label\n        self.icon = icon\n        env = {}\n        try:\n            env = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = env\n\n        host_name = data[\"host_name\"] or None\n        self.is_host = host_name is not None\n        self.host_name = host_name\n\n        settings_variants = data[\"variants\"]\n        variants = {}\n        for variant_data in settings_variants:\n            app_variant = Application(variant_data, self)\n            variants[app_variant.name] = app_variant\n\n        self.variants = variants\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.name)\n\n    def __iter__(self):\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.EnvironmentTool","title":"<code>EnvironmentTool</code>","text":"<p>Hold information about application tool.</p> <p>Structure of tool information.</p> <p>Parameters:</p> Name Type Description Default <code>variant_data</code> <code>dict</code> <p>Variant data with environments and host and app variant filters.</p> required <code>group</code> <code>EnvironmentToolGroup</code> <p>Name of group which wraps tool.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentTool:\n    \"\"\"Hold information about application tool.\n\n    Structure of tool information.\n\n    Args:\n        variant_data (dict): Variant data with environments and\n            host and app variant filters.\n        group (EnvironmentToolGroup): Name of group which wraps tool.\n    \"\"\"\n\n    def __init__(self, variant_data, group):\n        # Backwards compatibility 3.9.1 - 3.9.2\n        # - 'variant_data' contained only environments but contain also host\n        #   and application variant filters\n        name = variant_data[\"name\"]\n        label = variant_data[\"label\"]\n        host_names = variant_data[\"host_names\"]\n        app_variants = variant_data[\"app_variants\"]\n\n        environment = {}\n        try:\n            environment = json.loads(variant_data[\"environment\"])\n        except Exception:\n            pass\n\n        self.host_names = host_names\n        self.app_variants = app_variants\n        self.name = name\n        self.variant_label = label\n        self.label = \" \".join((group.label, label))\n        self.group = group\n\n        self._environment = environment\n        self.full_name = \"/\".join((group.name, name))\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.full_name)\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n\n    def is_valid_for_app(self, app):\n        \"\"\"Is tool valid for application.\n\n        Args:\n            app (Application): Application for which are prepared environments.\n        \"\"\"\n        if self.app_variants and app.full_name not in self.app_variants:\n            return False\n\n        if self.host_names and app.host_name not in self.host_names:\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.EnvironmentTool.is_valid_for_app","title":"<code>is_valid_for_app(app)</code>","text":"<p>Is tool valid for application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>Application for which are prepared environments.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>def is_valid_for_app(self, app):\n    \"\"\"Is tool valid for application.\n\n    Args:\n        app (Application): Application for which are prepared environments.\n    \"\"\"\n    if self.app_variants and app.full_name not in self.app_variants:\n        return False\n\n    if self.host_names and app.host_name not in self.host_names:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.EnvironmentToolGroup","title":"<code>EnvironmentToolGroup</code>","text":"<p>Hold information about environment tool group.</p> <p>Environment tool group may hold different variants of same tool and set environments that are same for all of them.</p> <p>e.g. \"mtoa\" may have different versions but all environments except one     are same.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Group information with variants.</p> required <code>manager</code> <code>ApplicationManager</code> <p>Manager that creates the group.</p> required Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class EnvironmentToolGroup:\n    \"\"\"Hold information about environment tool group.\n\n    Environment tool group may hold different variants of same tool and set\n    environments that are same for all of them.\n\n    e.g. \"mtoa\" may have different versions but all environments except one\n        are same.\n\n    Args:\n        data (dict): Group information with variants.\n        manager (ApplicationManager): Manager that creates the group.\n    \"\"\"\n\n    def __init__(self, data, manager):\n        name = data[\"name\"]\n        label = data[\"label\"]\n\n        self.name = name\n        self.label = label\n        self._data = data\n        self.manager = manager\n\n        environment = {}\n        try:\n            environment = json.loads(data[\"environment\"])\n        except Exception:\n            pass\n        self._environment = environment\n\n        variants = data.get(\"variants\") or []\n        variants_by_name = {}\n        for variant_data in variants:\n            tool = EnvironmentTool(variant_data, self)\n            variants_by_name[tool.name] = tool\n        self.variants = variants_by_name\n\n    def __repr__(self):\n        return \"&lt;{}&gt; - {}\".format(self.__class__.__name__, self.name)\n\n    def __iter__(self):\n        for variant in self.variants.values():\n            yield variant\n\n    @property\n    def environment(self):\n        return copy.deepcopy(self._environment)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.LaunchTypes","title":"<code>LaunchTypes</code>","text":"<p>Launch types are filters for pre/post-launch hooks.</p> <p>Please use these variables in case they'll change values.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class LaunchTypes:\n    \"\"\"Launch types are filters for pre/post-launch hooks.\n\n    Please use these variables in case they'll change values.\n    \"\"\"\n\n    # Local launch - application is launched on local machine\n    local = \"local\"\n    # Farm render job - application is on farm\n    farm_render = \"farm-render\"\n    # Farm publish job - integration post-render job\n    farm_publish = \"farm-publish\"\n    # Remote launch - application is launched on remote machine from which\n    #     can be started publishing\n    remote = \"remote\"\n    # Automated launch - application is launched with automated publishing\n    automated = \"automated\"\n</code></pre>"},{"location":"autoapi/client/ayon_applications/defs.html#client.ayon_applications.defs.UndefinedApplicationExecutable","title":"<code>UndefinedApplicationExecutable</code>","text":"<p>               Bases: <code>ApplicationExecutable</code></p> <p>Some applications do not require executable path from settings.</p> <p>In that case this class is used to \"fake\" existing executable.</p> Source code in <code>client/ayon_applications/defs.py</code> <pre><code>class UndefinedApplicationExecutable(ApplicationExecutable):\n    \"\"\"Some applications do not require executable path from settings.\n\n    In that case this class is used to \"fake\" existing executable.\n    \"\"\"\n    def __init__(self):\n        pass\n\n    def __str__(self):\n        return self.__class__.__name__\n\n    def __repr__(self):\n        return \"&lt;{}&gt;\".format(self.__class__.__name__)\n\n    def as_args(self):\n        return []\n\n    def exists(self):\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/exceptions.html","title":"exceptions","text":""},{"location":"autoapi/client/ayon_applications/exceptions.html#client.ayon_applications.exceptions.ApplicationExecutableNotFound","title":"<code>ApplicationExecutableNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Defined executable paths are not available on the machine.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationExecutableNotFound(Exception):\n    \"\"\"Defined executable paths are not available on the machine.\"\"\"\n\n    def __init__(self, application):\n        self.application = application\n        details = None\n        if not application.executables:\n            msg = (\n                \"Executable paths for application \\\"{}\\\"({}) are not set.\"\n            )\n        else:\n            msg = (\n                \"Defined executable paths for application \\\"{}\\\"({})\"\n                \" are not available on this machine.\"\n            )\n            details = \"Defined paths:\"\n            for executable in application.executables:\n                details += \"\\n- \" + executable.executable_path\n\n        self.msg = msg.format(application.full_label, application.full_name)\n        self.details = details\n\n        exc_mgs = str(self.msg)\n        if details:\n            # Is good idea to pass new line symbol to exception message?\n            exc_mgs += \"\\n\\n\" + details\n        self.exc_msg = exc_mgs\n        super().__init__(exc_mgs)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/exceptions.html#client.ayon_applications.exceptions.ApplicationLaunchFailed","title":"<code>ApplicationLaunchFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application launch failed due to known reason.</p> <p>Message should be self explanatory as traceback won't be shown.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationLaunchFailed(Exception):\n    \"\"\"Application launch failed due to known reason.\n\n    Message should be self explanatory as traceback won't be shown.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_applications/exceptions.html#client.ayon_applications.exceptions.ApplicationNotFound","title":"<code>ApplicationNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Application was not found in ApplicationManager by name.</p> Source code in <code>client/ayon_applications/exceptions.py</code> <pre><code>class ApplicationNotFound(Exception):\n    \"\"\"Application was not found in ApplicationManager by name.\"\"\"\n\n    def __init__(self, app_name):\n        self.app_name = app_name\n        super().__init__(\n            \"Application \\\"{}\\\" was not found.\".format(app_name)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/hooks.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_applications/manager.html","title":"manager","text":""},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext","title":"<code>ApplicationLaunchContext</code>","text":"<p>Context of launching application.</p> <p>Main purpose of context is to prepare launch arguments and keyword arguments for new process. Most important part of keyword arguments preparations are environment variables.</p> <p>During the whole process is possible to use <code>data</code> attribute to store object usable in multiple places.</p> <p>Launch arguments are strings in list. It is possible to \"chain\" argument when order of them matters. That is possible to do with adding list where order is right and should not change. NOTE: This is recommendation, not requirement. e.g.: <code>[\"nuke.exe\", \"--NukeX\"]</code> -&gt; In this case any part of process may insert argument between <code>nuke.exe</code> and <code>--NukeX</code>. To keep them together it is better to wrap them in another list: <code>[[\"nuke.exe\", \"--NukeX\"]]</code>.</p> Notes <p>It is possible to use launch context only to prepare environment     variables. In that case <code>executable</code> may be None and can be used     'run_prelaunch_hooks' method to run prelaunch hooks which prepare     them.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Application</code> <p>Application definition.</p> required <code>executable</code> <code>ApplicationExecutable</code> <p>Object with path to executable.</p> required <code>env_group</code> <code>Optional[str]</code> <p>Environment variable group. If not set 'DEFAULT_ENV_SUBGROUP' is used.</p> <code>None</code> <code>launch_type</code> <code>Optional[str]</code> <p>Launch type. If not set 'local' is used.</p> <code>None</code> <code>**data</code> <code>dict</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationLaunchContext:\n    \"\"\"Context of launching application.\n\n    Main purpose of context is to prepare launch arguments and keyword\n    arguments for new process. Most important part of keyword arguments\n    preparations are environment variables.\n\n    During the whole process is possible to use `data` attribute to store\n    object usable in multiple places.\n\n    Launch arguments are strings in list. It is possible to \"chain\" argument\n    when order of them matters. That is possible to do with adding list where\n    order is right and should not change.\n    NOTE: This is recommendation, not requirement.\n    e.g.: `[\"nuke.exe\", \"--NukeX\"]` -&gt; In this case any part of process may\n    insert argument between `nuke.exe` and `--NukeX`. To keep them together\n    it is better to wrap them in another list: `[[\"nuke.exe\", \"--NukeX\"]]`.\n\n    Notes:\n        It is possible to use launch context only to prepare environment\n            variables. In that case `executable` may be None and can be used\n            'run_prelaunch_hooks' method to run prelaunch hooks which prepare\n            them.\n\n    Args:\n        application (Application): Application definition.\n        executable (ApplicationExecutable): Object with path to executable.\n        env_group (Optional[str]): Environment variable group. If not set\n            'DEFAULT_ENV_SUBGROUP' is used.\n        launch_type (Optional[str]): Launch type. If not set 'local' is used.\n        **data (dict): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n    \"\"\"\n\n    def __init__(\n        self,\n        application,\n        executable,\n        env_group=None,\n        launch_type=None,\n        **data\n    ):\n        # Application object\n        self.application = application\n\n        self.addons_manager = AddonsManager()\n\n        # Logger\n        logger_name = \"{}-{}\".format(self.__class__.__name__,\n                                     self.application.full_name)\n        self.log = Logger.get_logger(logger_name)\n\n        self.executable = executable\n\n        if launch_type is None:\n            launch_type = LaunchTypes.local\n        self.launch_type = launch_type\n\n        if env_group is None:\n            env_group = DEFAULT_ENV_SUBGROUP\n\n        self.env_group = env_group\n\n        self.data = dict(data)\n\n        launch_args = []\n        if executable is not None:\n            launch_args = executable.as_args()\n        # subprocess.Popen launch arguments (first argument in constructor)\n        self.launch_args = launch_args\n        self.launch_args.extend(application.arguments)\n        if self.data.get(\"app_args\"):\n            self.launch_args.extend(self.data.pop(\"app_args\"))\n\n        # Handle launch environemtns\n        src_env = self.data.pop(\"env\", None)\n        if src_env is not None and not isinstance(src_env, dict):\n            self.log.warning((\n                \"Passed `env` kwarg has invalid type: {}. Expected: `dict`.\"\n                \" Using `os.environ` instead.\"\n            ).format(str(type(src_env))))\n            src_env = None\n\n        if src_env is None:\n            src_env = os.environ\n\n        ignored_env = {\"QT_API\", }\n        env = {\n            key: str(value)\n            for key, value in src_env.items()\n            if key not in ignored_env\n        }\n        # subprocess.Popen keyword arguments\n        self.kwargs = {\"env\": env}\n\n        if platform.system().lower() == \"windows\":\n            # Detach new process from currently running process on Windows\n            flags = (\n                subprocess.CREATE_NEW_PROCESS_GROUP\n                | subprocess.DETACHED_PROCESS\n            )\n            self.kwargs[\"creationflags\"] = flags\n\n        if not sys.stdout:\n            self.kwargs[\"stdout\"] = subprocess.DEVNULL\n            self.kwargs[\"stderr\"] = subprocess.DEVNULL\n\n        self.prelaunch_hooks = None\n        self.postlaunch_hooks = None\n\n        self.process = None\n        self._prelaunch_hooks_executed = False\n\n    @property\n    def env(self):\n        if (\n            \"env\" not in self.kwargs\n            or self.kwargs[\"env\"] is None\n        ):\n            self.kwargs[\"env\"] = {}\n        return self.kwargs[\"env\"]\n\n    @env.setter\n    def env(self, value):\n        if not isinstance(value, dict):\n            raise ValueError(\n                \"'env' attribute expect 'dict' object. Got: {}\".format(\n                    str(type(value))\n                )\n            )\n        self.kwargs[\"env\"] = value\n\n    @property\n    def modules_manager(self):\n        \"\"\"\n        Deprecated:\n            Use 'addons_manager' instead.\n\n        \"\"\"\n        return self.addons_manager\n\n    def _collect_addons_launch_hook_paths(self):\n        \"\"\"Helper to collect application launch hooks from addons.\n\n        Module have to have implemented 'get_launch_hook_paths' method which\n        can expect application as argument or nothing.\n\n        Returns:\n            List[str]: Paths to launch hook directories.\n        \"\"\"\n\n        expected_types = (list, tuple, set)\n\n        output = []\n        for module in self.addons_manager.get_enabled_addons():\n            # Skip module if does not have implemented 'get_launch_hook_paths'\n            func = getattr(module, \"get_launch_hook_paths\", None)\n            if func is None:\n                continue\n\n            func = module.get_launch_hook_paths\n            if hasattr(inspect, \"signature\"):\n                sig = inspect.signature(func)\n                expect_args = len(sig.parameters) &gt; 0\n            else:\n                expect_args = len(inspect.getargspec(func)[0]) &gt; 0\n\n            # Pass application argument if method expect it.\n            try:\n                if expect_args:\n                    hook_paths = func(self.application)\n                else:\n                    hook_paths = func()\n            except Exception:\n                self.log.warning(\n                    \"Failed to call 'get_launch_hook_paths'\",\n                    exc_info=True\n                )\n                continue\n\n            if not hook_paths:\n                continue\n\n            # Convert string to list\n            if isinstance(hook_paths, str):\n                hook_paths = [hook_paths]\n\n            # Skip invalid types\n            if not isinstance(hook_paths, expected_types):\n                self.log.warning((\n                    \"Result of `get_launch_hook_paths`\"\n                    \" has invalid type {}. Expected {}\"\n                ).format(type(hook_paths), expected_types))\n                continue\n\n            output.extend(hook_paths)\n        return output\n\n    def paths_to_launch_hooks(self):\n        \"\"\"Directory paths where to look for launch hooks.\"\"\"\n        # This method has potential to be part of application manager (maybe).\n        paths = []\n\n        # TODO load additional studio paths from settings\n        global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n        hooks_dirs = [\n            global_hooks_dir\n        ]\n        if self.host_name:\n            # If host requires launch hooks and is module then launch hooks\n            #   should be collected using 'collect_launch_hook_paths'\n            #   - module have to implement 'get_launch_hook_paths'\n            host_module = self.addons_manager.get_host_addon(self.host_name)\n            if not host_module:\n                hooks_dirs.append(os.path.join(\n                    AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n                ))\n\n        for path in hooks_dirs:\n            if (\n                os.path.exists(path)\n                and os.path.isdir(path)\n                and path not in paths\n            ):\n                paths.append(path)\n\n        # Load modules paths\n        paths.extend(self._collect_addons_launch_hook_paths())\n\n        return paths\n\n    def discover_launch_hooks(self, force=False):\n        \"\"\"Load and prepare launch hooks.\"\"\"\n        if (\n            self.prelaunch_hooks is not None\n            or self.postlaunch_hooks is not None\n        ):\n            if not force:\n                self.log.info(\"Launch hooks were already discovered.\")\n                return\n\n            self.prelaunch_hooks.clear()\n            self.postlaunch_hooks.clear()\n\n        self.log.debug(\"Discovery of launch hooks started.\")\n\n        paths = self.paths_to_launch_hooks()\n        self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n            \"\\n\".join(\"- {}\".format(path) for path in paths)\n        ))\n\n        all_classes = {\n            \"pre\": [],\n            \"post\": []\n        }\n        for path in paths:\n            if not os.path.exists(path):\n                self.log.info(\n                    \"Path to launch hooks does not exist: \\\"{}\\\"\".format(path)\n                )\n                continue\n\n            modules, _crashed = modules_from_path(path)\n            for _filepath, module in modules:\n                all_classes[\"pre\"].extend(\n                    classes_from_module(PreLaunchHook, module)\n                )\n                all_classes[\"post\"].extend(\n                    classes_from_module(PostLaunchHook, module)\n                )\n\n        for launch_type, classes in all_classes.items():\n            hooks_with_order = []\n            hooks_without_order = []\n            for klass in classes:\n                try:\n                    hook = klass(self)\n                    if not hook.is_valid:\n                        self.log.debug(\n                            \"Skipped hook invalid for current launch context: \"\n                            \"{}\".format(klass.__name__)\n                        )\n                        continue\n\n                    if inspect.isabstract(hook):\n                        self.log.debug(\"Skipped abstract hook: {}\".format(\n                            klass.__name__\n                        ))\n                        continue\n\n                    # Separate hooks by pre/post class\n                    if hook.order is None:\n                        hooks_without_order.append(hook)\n                    else:\n                        hooks_with_order.append(hook)\n\n                except Exception:\n                    self.log.warning(\n                        \"Initialization of hook failed: \"\n                        \"{}\".format(klass.__name__),\n                        exc_info=True\n                    )\n\n            # Sort hooks with order by order\n            ordered_hooks = list(sorted(\n                hooks_with_order, key=lambda obj: obj.order\n            ))\n            # Extend ordered hooks with hooks without defined order\n            ordered_hooks.extend(hooks_without_order)\n\n            if launch_type == \"pre\":\n                self.prelaunch_hooks = ordered_hooks\n            else:\n                self.postlaunch_hooks = ordered_hooks\n\n        self.log.debug(\"Found {} prelaunch and {} postlaunch hooks.\".format(\n            len(self.prelaunch_hooks), len(self.postlaunch_hooks)\n        ))\n\n    @property\n    def app_name(self):\n        return self.application.name\n\n    @property\n    def host_name(self):\n        return self.application.host_name\n\n    @property\n    def app_group(self):\n        return self.application.group\n\n    @property\n    def manager(self):\n        return self.application.manager\n\n    def _run_process(self):\n        # Windows and MacOS have easier process start\n        low_platform = platform.system().lower()\n        if low_platform in (\"windows\", \"darwin\"):\n            return subprocess.Popen(self.launch_args, **self.kwargs)\n\n        # Linux uses mid process\n        # - it is possible that the mid process executable is not\n        #   available for this version of AYON in that case use standard\n        #   launch\n        launch_args = get_linux_launcher_args()\n        if launch_args is None:\n            return subprocess.Popen(self.launch_args, **self.kwargs)\n\n        # Prepare data that will be passed to midprocess\n        # - store arguments to a json and pass path to json as last argument\n        # - pass environments to set\n        app_env = self.kwargs.pop(\"env\", {})\n        json_data = {\n            \"args\": self.launch_args,\n            \"env\": app_env\n        }\n        if app_env:\n            # Filter environments of subprocess\n            self.kwargs[\"env\"] = {\n                key: value\n                for key, value in os.environ.items()\n                if key in app_env\n            }\n\n        # Create temp file\n        json_temp = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"op_app_args\", suffix=\".json\", delete=False\n        )\n        json_temp.close()\n        json_temp_filpath = json_temp.name\n        with open(json_temp_filpath, \"w\") as stream:\n            json.dump(json_data, stream)\n\n        launch_args.append(json_temp_filpath)\n\n        # Create mid-process which will launch application\n        process = subprocess.Popen(launch_args, **self.kwargs)\n        # Wait until the process finishes\n        #   - This is important! The process would stay in \"open\" state.\n        process.wait()\n        # Remove the temp file\n        os.remove(json_temp_filpath)\n        # Return process which is already terminated\n        return process\n\n    def run_prelaunch_hooks(self):\n        \"\"\"Run prelaunch hooks.\n\n        This method will be executed only once, any future calls will skip\n            the processing.\n        \"\"\"\n\n        if self._prelaunch_hooks_executed:\n            self.log.warning(\"Prelaunch hooks were already executed.\")\n            return\n        # Discover launch hooks\n        self.discover_launch_hooks()\n\n        # Execute prelaunch hooks\n        for prelaunch_hook in self.prelaunch_hooks:\n            self.log.debug(\"Executing prelaunch hook: {}\".format(\n                str(prelaunch_hook.__class__.__name__)\n            ))\n            prelaunch_hook.execute()\n        self._prelaunch_hooks_executed = True\n\n    def launch(self):\n        \"\"\"Collect data for new process and then create it.\n\n        This method must not be executed more than once.\n\n        Returns:\n            subprocess.Popen: Created process as Popen object.\n        \"\"\"\n        if self.process is not None:\n            self.log.warning(\"Application was already launched.\")\n            return\n\n        if not self._prelaunch_hooks_executed:\n            self.run_prelaunch_hooks()\n\n        self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n        # Prepare subprocess args\n        args_len_str = \"\"\n        if isinstance(self.launch_args, str):\n            args = self.launch_args\n        else:\n            args = self.clear_launch_args(self.launch_args)\n            args_len_str = \" ({})\".format(len(args))\n        self.log.info(\n            \"Launching \\\"{}\\\" with args{}: {}\".format(\n                self.application.full_name, args_len_str, args\n            )\n        )\n        self.launch_args = args\n\n        # Run process\n        self.process = self._run_process()\n\n        # Process post launch hooks\n        for postlaunch_hook in self.postlaunch_hooks:\n            self.log.debug(\"Executing postlaunch hook: {}\".format(\n                str(postlaunch_hook.__class__.__name__)\n            ))\n\n            # TODO how to handle errors?\n            # - store to variable to let them accessible?\n            try:\n                postlaunch_hook.execute()\n\n            except Exception:\n                self.log.warning(\n                    \"After launch procedures were not successful.\",\n                    exc_info=True\n                )\n\n        self.log.debug(\"Launch of {} finished.\".format(\n            self.application.full_name\n        ))\n\n        return self.process\n\n    @staticmethod\n    def clear_launch_args(args):\n        \"\"\"Collect launch arguments to final order.\n\n        Launch argument should be list that may contain another lists this\n        function will upack inner lists and keep ordering.\n\n        ```\n        # source\n        [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n        # result\n        [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n        Args:\n            args (list): Source arguments in list may contain inner lists.\n\n        Return:\n            list: Unpacked arguments.\n        \"\"\"\n        if isinstance(args, str):\n            return args\n        all_cleared = False\n        while not all_cleared:\n            all_cleared = True\n            new_args = []\n            for arg in args:\n                if isinstance(arg, (list, tuple, set)):\n                    all_cleared = False\n                    for _arg in arg:\n                        new_args.append(_arg)\n                else:\n                    new_args.append(arg)\n            args = new_args\n\n        return args\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.modules_manager","title":"<code>modules_manager</code>  <code>property</code>","text":"Deprecated <p>Use 'addons_manager' instead.</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.clear_launch_args","title":"<code>clear_launch_args(args)</code>  <code>staticmethod</code>","text":"<p>Collect launch arguments to final order.</p> <p>Launch argument should be list that may contain another lists this function will upack inner lists and keep ordering.</p> <p>```</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.clear_launch_args--source","title":"source","text":"<p>[ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]</p>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.clear_launch_args--result","title":"result","text":"<p>[ arg1, arg2, arg3, arg4, arg5, arg6]</p> <p>Args:     args (list): Source arguments in list may contain inner lists.</p> <p>Return:     list: Unpacked arguments.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>@staticmethod\ndef clear_launch_args(args):\n    \"\"\"Collect launch arguments to final order.\n\n    Launch argument should be list that may contain another lists this\n    function will upack inner lists and keep ordering.\n\n    ```\n    # source\n    [ [ arg1, [ arg2, arg3 ] ], arg4, [arg5, arg6]]\n    # result\n    [ arg1, arg2, arg3, arg4, arg5, arg6]\n\n    Args:\n        args (list): Source arguments in list may contain inner lists.\n\n    Return:\n        list: Unpacked arguments.\n    \"\"\"\n    if isinstance(args, str):\n        return args\n    all_cleared = False\n    while not all_cleared:\n        all_cleared = True\n        new_args = []\n        for arg in args:\n            if isinstance(arg, (list, tuple, set)):\n                all_cleared = False\n                for _arg in arg:\n                    new_args.append(_arg)\n            else:\n                new_args.append(arg)\n        args = new_args\n\n    return args\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.discover_launch_hooks","title":"<code>discover_launch_hooks(force=False)</code>","text":"<p>Load and prepare launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def discover_launch_hooks(self, force=False):\n    \"\"\"Load and prepare launch hooks.\"\"\"\n    if (\n        self.prelaunch_hooks is not None\n        or self.postlaunch_hooks is not None\n    ):\n        if not force:\n            self.log.info(\"Launch hooks were already discovered.\")\n            return\n\n        self.prelaunch_hooks.clear()\n        self.postlaunch_hooks.clear()\n\n    self.log.debug(\"Discovery of launch hooks started.\")\n\n    paths = self.paths_to_launch_hooks()\n    self.log.debug(\"Paths searched for launch hooks:\\n{}\".format(\n        \"\\n\".join(\"- {}\".format(path) for path in paths)\n    ))\n\n    all_classes = {\n        \"pre\": [],\n        \"post\": []\n    }\n    for path in paths:\n        if not os.path.exists(path):\n            self.log.info(\n                \"Path to launch hooks does not exist: \\\"{}\\\"\".format(path)\n            )\n            continue\n\n        modules, _crashed = modules_from_path(path)\n        for _filepath, module in modules:\n            all_classes[\"pre\"].extend(\n                classes_from_module(PreLaunchHook, module)\n            )\n            all_classes[\"post\"].extend(\n                classes_from_module(PostLaunchHook, module)\n            )\n\n    for launch_type, classes in all_classes.items():\n        hooks_with_order = []\n        hooks_without_order = []\n        for klass in classes:\n            try:\n                hook = klass(self)\n                if not hook.is_valid:\n                    self.log.debug(\n                        \"Skipped hook invalid for current launch context: \"\n                        \"{}\".format(klass.__name__)\n                    )\n                    continue\n\n                if inspect.isabstract(hook):\n                    self.log.debug(\"Skipped abstract hook: {}\".format(\n                        klass.__name__\n                    ))\n                    continue\n\n                # Separate hooks by pre/post class\n                if hook.order is None:\n                    hooks_without_order.append(hook)\n                else:\n                    hooks_with_order.append(hook)\n\n            except Exception:\n                self.log.warning(\n                    \"Initialization of hook failed: \"\n                    \"{}\".format(klass.__name__),\n                    exc_info=True\n                )\n\n        # Sort hooks with order by order\n        ordered_hooks = list(sorted(\n            hooks_with_order, key=lambda obj: obj.order\n        ))\n        # Extend ordered hooks with hooks without defined order\n        ordered_hooks.extend(hooks_without_order)\n\n        if launch_type == \"pre\":\n            self.prelaunch_hooks = ordered_hooks\n        else:\n            self.postlaunch_hooks = ordered_hooks\n\n    self.log.debug(\"Found {} prelaunch and {} postlaunch hooks.\".format(\n        len(self.prelaunch_hooks), len(self.postlaunch_hooks)\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.launch","title":"<code>launch()</code>","text":"<p>Collect data for new process and then create it.</p> <p>This method must not be executed more than once.</p> <p>Returns:</p> Type Description <p>subprocess.Popen: Created process as Popen object.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self):\n    \"\"\"Collect data for new process and then create it.\n\n    This method must not be executed more than once.\n\n    Returns:\n        subprocess.Popen: Created process as Popen object.\n    \"\"\"\n    if self.process is not None:\n        self.log.warning(\"Application was already launched.\")\n        return\n\n    if not self._prelaunch_hooks_executed:\n        self.run_prelaunch_hooks()\n\n    self.log.debug(\"All prelaunch hook executed. Starting new process.\")\n\n    # Prepare subprocess args\n    args_len_str = \"\"\n    if isinstance(self.launch_args, str):\n        args = self.launch_args\n    else:\n        args = self.clear_launch_args(self.launch_args)\n        args_len_str = \" ({})\".format(len(args))\n    self.log.info(\n        \"Launching \\\"{}\\\" with args{}: {}\".format(\n            self.application.full_name, args_len_str, args\n        )\n    )\n    self.launch_args = args\n\n    # Run process\n    self.process = self._run_process()\n\n    # Process post launch hooks\n    for postlaunch_hook in self.postlaunch_hooks:\n        self.log.debug(\"Executing postlaunch hook: {}\".format(\n            str(postlaunch_hook.__class__.__name__)\n        ))\n\n        # TODO how to handle errors?\n        # - store to variable to let them accessible?\n        try:\n            postlaunch_hook.execute()\n\n        except Exception:\n            self.log.warning(\n                \"After launch procedures were not successful.\",\n                exc_info=True\n            )\n\n    self.log.debug(\"Launch of {} finished.\".format(\n        self.application.full_name\n    ))\n\n    return self.process\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.paths_to_launch_hooks","title":"<code>paths_to_launch_hooks()</code>","text":"<p>Directory paths where to look for launch hooks.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def paths_to_launch_hooks(self):\n    \"\"\"Directory paths where to look for launch hooks.\"\"\"\n    # This method has potential to be part of application manager (maybe).\n    paths = []\n\n    # TODO load additional studio paths from settings\n    global_hooks_dir = os.path.join(AYON_CORE_ROOT, \"hooks\")\n\n    hooks_dirs = [\n        global_hooks_dir\n    ]\n    if self.host_name:\n        # If host requires launch hooks and is module then launch hooks\n        #   should be collected using 'collect_launch_hook_paths'\n        #   - module have to implement 'get_launch_hook_paths'\n        host_module = self.addons_manager.get_host_addon(self.host_name)\n        if not host_module:\n            hooks_dirs.append(os.path.join(\n                AYON_CORE_ROOT, \"hosts\", self.host_name, \"hooks\"\n            ))\n\n    for path in hooks_dirs:\n        if (\n            os.path.exists(path)\n            and os.path.isdir(path)\n            and path not in paths\n        ):\n            paths.append(path)\n\n    # Load modules paths\n    paths.extend(self._collect_addons_launch_hook_paths())\n\n    return paths\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationLaunchContext.run_prelaunch_hooks","title":"<code>run_prelaunch_hooks()</code>","text":"<p>Run prelaunch hooks.</p> <p>This method will be executed only once, any future calls will skip     the processing.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def run_prelaunch_hooks(self):\n    \"\"\"Run prelaunch hooks.\n\n    This method will be executed only once, any future calls will skip\n        the processing.\n    \"\"\"\n\n    if self._prelaunch_hooks_executed:\n        self.log.warning(\"Prelaunch hooks were already executed.\")\n        return\n    # Discover launch hooks\n    self.discover_launch_hooks()\n\n    # Execute prelaunch hooks\n    for prelaunch_hook in self.prelaunch_hooks:\n        self.log.debug(\"Executing prelaunch hook: {}\".format(\n            str(prelaunch_hook.__class__.__name__)\n        ))\n        prelaunch_hook.execute()\n    self._prelaunch_hooks_executed = True\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager","title":"<code>ApplicationManager</code>","text":"<p>Load applications and tools and store them by their full name.</p> <p>Parameters:</p> Name Type Description Default <code>studio_settings</code> <code>dict</code> <p>Preloaded studio settings. When passed manager will always use these values. Gives ability to create manager using different settings.</p> <code>None</code> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>class ApplicationManager:\n    \"\"\"Load applications and tools and store them by their full name.\n\n    Args:\n        studio_settings (dict): Preloaded studio settings. When passed manager\n            will always use these values. Gives ability to create manager\n            using different settings.\n    \"\"\"\n\n    def __init__(self, studio_settings=None):\n        self.log = Logger.get_logger(self.__class__.__name__)\n\n        self.app_groups = {}\n        self.applications = {}\n        self.tool_groups = {}\n        self.tools = {}\n\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def set_studio_settings(self, studio_settings):\n        \"\"\"Ability to change init system settings.\n\n        This will trigger refresh of manager.\n        \"\"\"\n        self._studio_settings = studio_settings\n\n        self.refresh()\n\n    def refresh(self):\n        \"\"\"Refresh applications from settings.\"\"\"\n        self.app_groups.clear()\n        self.applications.clear()\n        self.tool_groups.clear()\n        self.tools.clear()\n\n        if self._studio_settings is not None:\n            settings = copy.deepcopy(self._studio_settings)\n        else:\n            settings = get_studio_settings(\n                clear_metadata=False, exclude_locals=False\n            )\n\n        applications_addon_settings = settings[\"applications\"]\n\n        # Prepare known applications\n        app_defs = applications_addon_settings[\"applications\"]\n        additional_apps = app_defs.pop(\"additional_apps\")\n        for additional_app in additional_apps:\n            app_name = additional_app.pop(\"name\")\n            if app_name in app_defs:\n                self.log.warning((\n                    \"Additional application '{}' is already\"\n                    \" in built-in applications.\"\n                ).format(app_name))\n            app_defs[app_name] = additional_app\n\n        for group_name, variant_defs in app_defs.items():\n            group = ApplicationGroup(group_name, variant_defs, self)\n            self.app_groups[group_name] = group\n            for app in group:\n                self.applications[app.full_name] = app\n\n        tools_definitions = applications_addon_settings[\"tool_groups\"]\n        for tool_group_data in tools_definitions:\n            group = EnvironmentToolGroup(tool_group_data, self)\n            self.tool_groups[group.name] = group\n            for tool in group:\n                self.tools[tool.full_name] = tool\n\n    def find_latest_available_variant_for_group(self, group_name):\n        group = self.app_groups.get(group_name)\n        if group is None or not group.enabled:\n            return None\n\n        output = None\n        for _, variant in reversed(sorted(group.variants.items())):\n            executable = variant.find_executable()\n            if executable:\n                output = variant\n                break\n        return output\n\n    def create_launch_context(self, app_name, **data):\n        \"\"\"Prepare launch context for application.\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n\n        Returns:\n            ApplicationLaunchContext: Launch context for application.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered name.\n        \"\"\"\n\n        app = self.applications.get(app_name)\n        if not app:\n            raise ApplicationNotFound(app_name)\n\n        executable = app.find_executable()\n\n        return ApplicationLaunchContext(\n            app, executable, **data\n        )\n\n    def launch_with_context(self, launch_context):\n        \"\"\"Launch application using existing launch context.\n\n        Args:\n            launch_context (ApplicationLaunchContext): Prepared launch\n                context.\n        \"\"\"\n\n        if not launch_context.executable:\n            raise ApplicationExecutableNotFound(launch_context.application)\n        return launch_context.launch()\n\n    def launch(self, app_name, **data):\n        \"\"\"Launch procedure.\n\n        For host application it's expected to contain \"project_name\",\n        \"folder_path\" and \"task_name\".\n\n        Args:\n            app_name (str): Name of application that should be launched.\n            **data (Any): Any additional data. Data may be used during\n                preparation to store objects usable in multiple places.\n\n        Raises:\n            ApplicationNotFound: Application was not found by entered\n                argument `app_name`.\n            ApplicationExecutableNotFound: Executables in application definition\n                were not found on this machine.\n            ApplicationLaunchFailed: Something important for application launch\n                failed. Exception should contain explanation message,\n                traceback should not be needed.\n        \"\"\"\n\n        context = self.create_launch_context(app_name, **data)\n        return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.create_launch_context","title":"<code>create_launch_context(app_name, **data)</code>","text":"<p>Prepare launch context for application.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ApplicationLaunchContext</code> <p>Launch context for application.</p> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered name.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def create_launch_context(self, app_name, **data):\n    \"\"\"Prepare launch context for application.\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n\n    Returns:\n        ApplicationLaunchContext: Launch context for application.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered name.\n    \"\"\"\n\n    app = self.applications.get(app_name)\n    if not app:\n        raise ApplicationNotFound(app_name)\n\n    executable = app.find_executable()\n\n    return ApplicationLaunchContext(\n        app, executable, **data\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.launch","title":"<code>launch(app_name, **data)</code>","text":"<p>Launch procedure.</p> <p>For host application it's expected to contain \"project_name\", \"folder_path\" and \"task_name\".</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Name of application that should be launched.</p> required <code>**data</code> <code>Any</code> <p>Any additional data. Data may be used during preparation to store objects usable in multiple places.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ApplicationNotFound</code> <p>Application was not found by entered argument <code>app_name</code>.</p> <code>ApplicationExecutableNotFound</code> <p>Executables in application definition were not found on this machine.</p> <code>ApplicationLaunchFailed</code> <p>Something important for application launch failed. Exception should contain explanation message, traceback should not be needed.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch(self, app_name, **data):\n    \"\"\"Launch procedure.\n\n    For host application it's expected to contain \"project_name\",\n    \"folder_path\" and \"task_name\".\n\n    Args:\n        app_name (str): Name of application that should be launched.\n        **data (Any): Any additional data. Data may be used during\n            preparation to store objects usable in multiple places.\n\n    Raises:\n        ApplicationNotFound: Application was not found by entered\n            argument `app_name`.\n        ApplicationExecutableNotFound: Executables in application definition\n            were not found on this machine.\n        ApplicationLaunchFailed: Something important for application launch\n            failed. Exception should contain explanation message,\n            traceback should not be needed.\n    \"\"\"\n\n    context = self.create_launch_context(app_name, **data)\n    return self.launch_with_context(context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.launch_with_context","title":"<code>launch_with_context(launch_context)</code>","text":"<p>Launch application using existing launch context.</p> <p>Parameters:</p> Name Type Description Default <code>launch_context</code> <code>ApplicationLaunchContext</code> <p>Prepared launch context.</p> required Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def launch_with_context(self, launch_context):\n    \"\"\"Launch application using existing launch context.\n\n    Args:\n        launch_context (ApplicationLaunchContext): Prepared launch\n            context.\n    \"\"\"\n\n    if not launch_context.executable:\n        raise ApplicationExecutableNotFound(launch_context.application)\n    return launch_context.launch()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.refresh","title":"<code>refresh()</code>","text":"<p>Refresh applications from settings.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def refresh(self):\n    \"\"\"Refresh applications from settings.\"\"\"\n    self.app_groups.clear()\n    self.applications.clear()\n    self.tool_groups.clear()\n    self.tools.clear()\n\n    if self._studio_settings is not None:\n        settings = copy.deepcopy(self._studio_settings)\n    else:\n        settings = get_studio_settings(\n            clear_metadata=False, exclude_locals=False\n        )\n\n    applications_addon_settings = settings[\"applications\"]\n\n    # Prepare known applications\n    app_defs = applications_addon_settings[\"applications\"]\n    additional_apps = app_defs.pop(\"additional_apps\")\n    for additional_app in additional_apps:\n        app_name = additional_app.pop(\"name\")\n        if app_name in app_defs:\n            self.log.warning((\n                \"Additional application '{}' is already\"\n                \" in built-in applications.\"\n            ).format(app_name))\n        app_defs[app_name] = additional_app\n\n    for group_name, variant_defs in app_defs.items():\n        group = ApplicationGroup(group_name, variant_defs, self)\n        self.app_groups[group_name] = group\n        for app in group:\n            self.applications[app.full_name] = app\n\n    tools_definitions = applications_addon_settings[\"tool_groups\"]\n    for tool_group_data in tools_definitions:\n        group = EnvironmentToolGroup(tool_group_data, self)\n        self.tool_groups[group.name] = group\n        for tool in group:\n            self.tools[tool.full_name] = tool\n</code></pre>"},{"location":"autoapi/client/ayon_applications/manager.html#client.ayon_applications.manager.ApplicationManager.set_studio_settings","title":"<code>set_studio_settings(studio_settings)</code>","text":"<p>Ability to change init system settings.</p> <p>This will trigger refresh of manager.</p> Source code in <code>client/ayon_applications/manager.py</code> <pre><code>def set_studio_settings(self, studio_settings):\n    \"\"\"Ability to change init system settings.\n\n    This will trigger refresh of manager.\n    \"\"\"\n    self._studio_settings = studio_settings\n\n    self.refresh()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.EnvironmentPrepData","title":"<code>EnvironmentPrepData</code>","text":"<p>               Bases: <code>dict</code></p> <p>Helper dictionary for storin temp data during environment prep.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data must contain required keys.</p> required Source code in <code>client/ayon_applications/utils.py</code> <pre><code>class EnvironmentPrepData(dict):\n    \"\"\"Helper dictionary for storin temp data during environment prep.\n\n    Args:\n        data (dict): Data must contain required keys.\n    \"\"\"\n    required_keys = (\n        \"project_entity\", \"folder_entity\", \"task_entity\", \"app\", \"anatomy\"\n    )\n\n    def __init__(self, data):\n        for key in self.required_keys:\n            if key not in data:\n                raise MissingRequiredKey(key)\n\n        if not data.get(\"log\"):\n            data[\"log\"] = Logger.get_logger(\"EnvironmentPrepData\")\n\n        if data.get(\"env\") is None:\n            data[\"env\"] = os.environ.copy()\n\n        project_name = data[\"project_entity\"][\"name\"]\n        if \"project_settings\" not in data:\n            data[\"project_settings\"] = get_project_settings(project_name)\n\n        super(EnvironmentPrepData, self).__init__(data)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.apply_project_environments_value","title":"<code>apply_project_environments_value(project_name, env, project_settings=None, env_group=None)</code>","text":"<p>Apply project specific environments on passed environments.</p> <p>The environments are applied on passed <code>env</code> argument value so it is not required to apply changes back.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project for which environments should be received.</p> required <code>env</code> <code>dict</code> <p>Environment values on which project specific environments will be applied.</p> required <code>project_settings</code> <code>dict</code> <p>Project settings for passed project name. Optional if project settings are already prepared.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Passed env values with applied project environments.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If project settings do not contain keys for project specific environments.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def apply_project_environments_value(\n    project_name, env, project_settings=None, env_group=None\n):\n    \"\"\"Apply project specific environments on passed environments.\n\n    The environments are applied on passed `env` argument value so it is not\n    required to apply changes back.\n\n    Args:\n        project_name (str): Name of project for which environments should be\n            received.\n        env (dict): Environment values on which project specific environments\n            will be applied.\n        project_settings (dict): Project settings for passed project name.\n            Optional if project settings are already prepared.\n\n    Returns:\n        dict: Passed env values with applied project environments.\n\n    Raises:\n        KeyError: If project settings do not contain keys for project specific\n            environments.\n\n    \"\"\"\n    if project_settings is None:\n        project_settings = get_project_settings(project_name)\n\n    env_value = project_settings[\"core\"][\"project_environments\"]\n    if env_value:\n        env_value = json.loads(env_value)\n        parsed_value = parse_environments(env_value, env_group)\n        env.update(compute_env_variables_structure(\n            merge_env_variables(parsed_value, env)\n        ))\n    return env\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_app_environments_for_context","title":"<code>get_app_environments_for_context(project_name, folder_path, task_name, app_name, env_group=None, launch_type=None, env=None, addons_manager=None)</code>","text":"<p>Prepare environment variables by context. Args:     project_name (str): Name of project.     folder_path (str): Folder path.     task_name (str): Name of task.     app_name (str): Name of application that is launched and can be found         by ApplicationManager.     env_group (Optional[str]): Name of environment group. If not passed         default group is used.     launch_type (Optional[str]): Type for which prelaunch hooks are         executed.     env (Optional[dict[str, str]]): Initial environment variables.         <code>os.environ</code> is used when not passed.     addons_manager (Optional[AddonsManager]): Initialized modules         manager.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Environments for passed context and application.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_app_environments_for_context(\n    project_name,\n    folder_path,\n    task_name,\n    app_name,\n    env_group=None,\n    launch_type=None,\n    env=None,\n    addons_manager=None\n):\n    \"\"\"Prepare environment variables by context.\n    Args:\n        project_name (str): Name of project.\n        folder_path (str): Folder path.\n        task_name (str): Name of task.\n        app_name (str): Name of application that is launched and can be found\n            by ApplicationManager.\n        env_group (Optional[str]): Name of environment group. If not passed\n            default group is used.\n        launch_type (Optional[str]): Type for which prelaunch hooks are\n            executed.\n        env (Optional[dict[str, str]]): Initial environment variables.\n            `os.environ` is used when not passed.\n        addons_manager (Optional[AddonsManager]): Initialized modules\n            manager.\n\n    Returns:\n        dict: Environments for passed context and application.\n    \"\"\"\n\n    # Prepare app object which can be obtained only from ApplicationManager\n    app_manager = ApplicationManager()\n    context = app_manager.create_launch_context(\n        app_name,\n        project_name=project_name,\n        folder_path=folder_path,\n        task_name=task_name,\n        env_group=env_group,\n        launch_type=launch_type,\n        env=env,\n        addons_manager=addons_manager,\n        modules_manager=addons_manager,\n    )\n    context.run_prelaunch_hooks()\n    return context.env\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_app_icon_path","title":"<code>get_app_icon_path(icon_filename)</code>","text":"<p>Get icon path.</p> <p>Parameters:</p> Name Type Description Default <code>icon_filename</code> <code>str</code> <p>Icon filename.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Icon path or None if not found.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_app_icon_path(icon_filename):\n    \"\"\"Get icon path.\n\n    Args:\n        icon_filename (str): Icon filename.\n\n    Returns:\n        Union[str, None]: Icon path or None if not found.\n\n    \"\"\"\n    if not icon_filename:\n        return None\n    icon_name = os.path.basename(icon_filename)\n    path = os.path.join(APPLICATIONS_ADDON_ROOT, \"icons\", icon_name)\n    if os.path.exists(path):\n        return path\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_applications_for_context","title":"<code>get_applications_for_context(project_name, folder_entity, task_entity, project_settings=None, project_entity=None)</code>","text":"<p>Get applications for context based on project settings.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project.</p> required <code>folder_entity</code> <code>dict</code> <p>Folder entity.</p> required <code>task_entity</code> <code>dict</code> <p>Task entity.</p> required <code>project_settings</code> <code>Optional[dict]</code> <p>Project settings.</p> <code>None</code> <code>project_entity</code> <code>Optional[dict]</code> <p>Project entity.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[str]: List of applications that can be used in given context.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_applications_for_context(\n    project_name,\n    folder_entity,\n    task_entity,\n    project_settings=None,\n    project_entity=None,\n):\n    \"\"\"Get applications for context based on project settings.\n\n    Args:\n        project_name (str): Name of project.\n        folder_entity (dict): Folder entity.\n        task_entity (dict): Task entity.\n        project_settings (Optional[dict]): Project settings.\n        project_entity (Optional[dict]): Project entity.\n\n    Returns:\n        List[str]: List of applications that can be used in given context.\n\n    \"\"\"\n    if project_settings is None:\n        project_settings = get_project_settings(project_name)\n    apps_settings = project_settings[\"applications\"]\n\n    # Use attributes to get available applications\n    # - this is older source of the information, will be deprecated in future\n    project_applications = apps_settings[\"project_applications\"]\n    if not project_applications[\"enabled\"]:\n        if project_entity is None:\n            project_entity = ayon_api.get_project(project_name)\n        apps = project_entity[\"attrib\"].get(\"applications\")\n        return apps or []\n\n    task_type = None\n    if task_entity:\n        task_type = task_entity[\"taskType\"]\n\n    profile = filter_profiles(\n        project_applications[\"profiles\"],\n        {\"task_types\": task_type}\n    )\n    if profile:\n        if profile[\"allow_type\"] == \"applications\":\n            return profile[\"applications\"]\n        return _get_app_full_names_from_settings(apps_settings)\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.get_tools_for_context","title":"<code>get_tools_for_context(project_name, folder_entity, task_entity, project_settings=None)</code>","text":"<p>Get tools for context based on project settings.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project.</p> required <code>folder_entity</code> <code>dict</code> <p>Folder entity.</p> required <code>task_entity</code> <code>dict</code> <p>Task entity.</p> required <code>project_settings</code> <code>Optional[dict]</code> <p>Project settings.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[str]: List of applications that can be used in given context.</p> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def get_tools_for_context(\n    project_name,\n    folder_entity,\n    task_entity,\n    project_settings=None,\n):\n    \"\"\"Get tools for context based on project settings.\n\n    Args:\n        project_name (str): Name of project.\n        folder_entity (dict): Folder entity.\n        task_entity (dict): Task entity.\n        project_settings (Optional[dict]): Project settings.\n\n    Returns:\n        List[str]: List of applications that can be used in given context.\n\n    \"\"\"\n    if project_settings is None:\n        project_settings = get_project_settings(project_name)\n    apps_settings = project_settings[\"applications\"]\n\n    project_tools = apps_settings[\"project_tools\"]\n    # Use attributes to get available tools\n    # - this is older source of the information, will be deprecated in future\n    if not project_tools[\"enabled\"]:\n        tools = None\n        if task_entity:\n            tools = task_entity[\"attrib\"].get(\"tools\")\n\n        if tools is None and folder_entity:\n            tools = folder_entity[\"attrib\"].get(\"tools\")\n\n        return tools or []\n\n    folder_path = task_type = task_name = None\n    if folder_entity:\n        folder_path = folder_entity[\"path\"]\n    if task_entity:\n        task_type = task_entity[\"taskType\"]\n        task_name = task_entity[\"name\"]\n\n    profile = filter_profiles(\n        project_tools[\"profiles\"],\n        {\n            \"folder_paths\": folder_path,\n            \"task_types\": task_type,\n            \"task_names\": task_name,\n        },\n        keys_order=[\"folder_paths\", \"task_names\", \"task_types\"]\n    )\n    if profile:\n        return profile[\"tools\"]\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.parse_environments","title":"<code>parse_environments(env_data, env_group=None, platform_name=None)</code>","text":"<p>Parse environment values from settings byt group and platform.</p> <p>Data may contain up to 2 hierarchical levels of dictionaries. At the end of the last level must be string or list. List is joined using platform specific joiner (';' for windows and ':' for linux and mac).</p> <p>Hierarchical levels can contain keys for subgroups and platform name. Platform specific values must be always last level of dictionary. Platform names are \"windows\" (MS Windows), \"linux\" (any linux distribution) and \"darwin\" (any MacOS distribution).</p> <p>Subgroups are helpers added mainly for standard and on farm usage. Farm may require different environments for e.g. licence related values or plugins. Default subgroup is \"standard\".</p> <p>Examples:</p> <pre><code>{\n    # Unchanged value\n    \"ENV_KEY1\": \"value\",\n    # Empty values are kept (unset environment variable)\n    \"ENV_KEY2\": \"\",\n\n    # Join list values with ':' or ';'\n    \"ENV_KEY3\": [\"value1\", \"value2\"],\n\n    # Environment groups\n    \"ENV_KEY4\": {\n        \"standard\": \"DEMO_SERVER_URL\",\n        \"farm\": \"LICENCE_SERVER_URL\"\n    },\n\n    # Platform specific (and only for windows and mac)\n    \"ENV_KEY5\": {\n        \"windows\": \"windows value\",\n        \"darwin\": [\"value 1\", \"value 2\"]\n    },\n\n    # Environment groups and platform combination\n    \"ENV_KEY6\": {\n        \"farm\": \"FARM_VALUE\",\n        \"standard\": {\n            \"windows\": [\"value1\", \"value2\"],\n            \"linux\": \"value1\",\n            \"darwin\": \"\"\n        }\n    }\n}\n</code></pre> Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def parse_environments(env_data, env_group=None, platform_name=None):\n    \"\"\"Parse environment values from settings byt group and platform.\n\n    Data may contain up to 2 hierarchical levels of dictionaries. At the end\n    of the last level must be string or list. List is joined using platform\n    specific joiner (';' for windows and ':' for linux and mac).\n\n    Hierarchical levels can contain keys for subgroups and platform name.\n    Platform specific values must be always last level of dictionary. Platform\n    names are \"windows\" (MS Windows), \"linux\" (any linux distribution) and\n    \"darwin\" (any MacOS distribution).\n\n    Subgroups are helpers added mainly for standard and on farm usage. Farm\n    may require different environments for e.g. licence related values or\n    plugins. Default subgroup is \"standard\".\n\n    Examples:\n    ```\n    {\n        # Unchanged value\n        \"ENV_KEY1\": \"value\",\n        # Empty values are kept (unset environment variable)\n        \"ENV_KEY2\": \"\",\n\n        # Join list values with ':' or ';'\n        \"ENV_KEY3\": [\"value1\", \"value2\"],\n\n        # Environment groups\n        \"ENV_KEY4\": {\n            \"standard\": \"DEMO_SERVER_URL\",\n            \"farm\": \"LICENCE_SERVER_URL\"\n        },\n\n        # Platform specific (and only for windows and mac)\n        \"ENV_KEY5\": {\n            \"windows\": \"windows value\",\n            \"darwin\": [\"value 1\", \"value 2\"]\n        },\n\n        # Environment groups and platform combination\n        \"ENV_KEY6\": {\n            \"farm\": \"FARM_VALUE\",\n            \"standard\": {\n                \"windows\": [\"value1\", \"value2\"],\n                \"linux\": \"value1\",\n                \"darwin\": \"\"\n            }\n        }\n    }\n    ```\n    \"\"\"\n    output = {}\n    if not env_data:\n        return output\n\n    if not env_group:\n        env_group = DEFAULT_ENV_SUBGROUP\n\n    if not platform_name:\n        platform_name = platform.system().lower()\n\n    for key, value in env_data.items():\n        if isinstance(value, dict):\n            # Look if any key is platform key\n            #   - expect that represents environment group if does not contain\n            #   platform keys\n            if not PLATFORM_NAMES.intersection(set(value.keys())):\n                # Skip the key if group is not available\n                if env_group not in value:\n                    continue\n                value = value[env_group]\n\n        # Check again if value is dictionary\n        #   - this time there should be only platform keys\n        if isinstance(value, dict):\n            value = value.get(platform_name)\n\n        # Check if value is list and join it's values\n        # QUESTION Should empty values be skipped?\n        if isinstance(value, (list, tuple)):\n            value = os.pathsep.join(value)\n\n        # Set key to output if value is string\n        if isinstance(value, str):\n            output[key] = value\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.prepare_app_environments","title":"<code>prepare_app_environments(data, env_group=None, implementation_envs=True, addons_manager=None)</code>","text":"<p>Modify launch environments based on launched app and context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EnvironmentPrepData</code> <p>Dictionary where result and intermediate result will be stored.</p> required Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def prepare_app_environments(\n    data, env_group=None, implementation_envs=True, addons_manager=None\n):\n    \"\"\"Modify launch environments based on launched app and context.\n\n    Args:\n        data (EnvironmentPrepData): Dictionary where result and intermediate\n            result will be stored.\n\n    \"\"\"\n    app = data[\"app\"]\n    log = data[\"log\"]\n    source_env = data[\"env\"].copy()\n\n    if addons_manager is None:\n        addons_manager = AddonsManager()\n\n    _add_python_version_paths(app, source_env, log, addons_manager)\n\n    # Use environments from local settings\n    filtered_local_envs = {}\n    # NOTE Overrides for environment variables are not implemented in AYON.\n    # project_settings = data[\"project_settings\"]\n    # whitelist_envs = project_settings[\"general\"].get(\"local_env_white_list\")\n    # if whitelist_envs:\n    #     local_settings = get_local_settings()\n    #     local_envs = local_settings.get(\"environments\") or {}\n    #     filtered_local_envs = {\n    #         key: value\n    #         for key, value in local_envs.items()\n    #         if key in whitelist_envs\n    #     }\n\n    # Apply local environment variables for already existing values\n    for key, value in filtered_local_envs.items():\n        if key in source_env:\n            source_env[key] = value\n\n    # `app_and_tool_labels` has debug purpose\n    app_and_tool_labels = [app.full_name]\n    # Environments for application\n    environments = [\n        app.group.environment,\n        app.environment\n    ]\n\n    tools = get_tools_for_context(\n        data.get(\"project_name\"),\n        data.get(\"folder_entity\"),\n        data.get(\"task_entity\"),\n    )\n\n    # Add tools environments\n    groups_by_name = {}\n    tool_by_group_name = collections.defaultdict(dict)\n    for key in tools:\n        tool = app.manager.tools.get(key)\n        if not tool or not tool.is_valid_for_app(app):\n            continue\n        groups_by_name[tool.group.name] = tool.group\n        tool_by_group_name[tool.group.name][tool.name] = tool\n\n    for group_name in sorted(groups_by_name.keys()):\n        group = groups_by_name[group_name]\n        environments.append(group.environment)\n        for tool_name in sorted(tool_by_group_name[group_name].keys()):\n            tool = tool_by_group_name[group_name][tool_name]\n            environments.append(tool.environment)\n            app_and_tool_labels.append(tool.full_name)\n\n    log.info(\n        \"Will add environments for apps and tools: {}\".format(\n            \", \".join(app_and_tool_labels)\n        )\n    )\n\n    env_values = {}\n    for _env_values in environments:\n        if not _env_values:\n            continue\n\n        # Choose right platform\n        tool_env = parse_environments(_env_values, env_group)\n\n        # Apply local environment variables\n        # - must happen between all values because they may be used during\n        #   merge\n        for key, value in filtered_local_envs.items():\n            if key in tool_env:\n                tool_env[key] = value\n\n        # Merge dictionaries\n        env_values = merge_env_variables(tool_env, env_values)\n\n    merged_env = merge_env_variables(env_values, source_env)\n    loaded_env = compute_env_variables_structure(merged_env)\n\n    final_env = None\n    # Add host specific environments\n    if app.host_name and implementation_envs:\n        host_addon = addons_manager.get_host_addon(app.host_name)\n        add_implementation_envs = None\n        if host_addon:\n            add_implementation_envs = getattr(\n                host_addon, \"add_implementation_envs\", None\n            )\n        if add_implementation_envs:\n            # Function may only modify passed dict without returning value\n            final_env = add_implementation_envs(loaded_env, app)\n\n    if final_env is None:\n        final_env = loaded_env\n\n    keys_to_remove = set(source_env.keys()) - set(final_env.keys())\n\n    # Update env\n    data[\"env\"].update(final_env)\n    for key in keys_to_remove:\n        data[\"env\"].pop(key, None)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/utils.html#client.ayon_applications.utils.prepare_context_environments","title":"<code>prepare_context_environments(data, env_group=None, addons_manager=None)</code>","text":"<p>Modify launch environments with context data for launched host.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EnvironmentPrepData</code> <p>Dictionary where result and intermediate result will be stored.</p> required Source code in <code>client/ayon_applications/utils.py</code> <pre><code>def prepare_context_environments(data, env_group=None, addons_manager=None):\n    \"\"\"Modify launch environments with context data for launched host.\n\n    Args:\n        data (EnvironmentPrepData): Dictionary where result and intermediate\n            result will be stored.\n\n    \"\"\"\n    # Context environments\n    log = data[\"log\"]\n\n    project_entity = data[\"project_entity\"]\n    folder_entity = data[\"folder_entity\"]\n    task_entity = data[\"task_entity\"]\n    if not project_entity:\n        log.info(\n            \"Skipping context environments preparation.\"\n            \" Launch context does not contain required data.\"\n        )\n        return\n\n    # Load project specific environments\n    project_name = project_entity[\"name\"]\n    project_settings = get_project_settings(project_name)\n    data[\"project_settings\"] = project_settings\n\n    app = data[\"app\"]\n    context_env = {\n        \"AYON_PROJECT_NAME\": project_entity[\"name\"],\n        \"AYON_APP_NAME\": app.full_name\n    }\n    if folder_entity:\n        folder_path = folder_entity[\"path\"]\n        context_env[\"AYON_FOLDER_PATH\"] = folder_path\n\n        if task_entity:\n            context_env[\"AYON_TASK_NAME\"] = task_entity[\"name\"]\n\n    log.debug(\n        \"Context environments set:\\n{}\".format(\n            json.dumps(context_env, indent=4)\n        )\n    )\n    data[\"env\"].update(context_env)\n\n    # Apply project specific environments on current env value\n    # - apply them once the context environments are set\n    apply_project_environments_value(\n        project_name, data[\"env\"], project_settings, env_group\n    )\n\n    if not app.is_host:\n        return\n\n    data[\"env\"][\"AYON_HOST_NAME\"] = app.host_name\n\n    if not folder_entity or not task_entity:\n        # QUESTION replace with log.info and skip workfile discovery?\n        # - technically it should be possible to launch host without context\n        raise ApplicationLaunchFailed(\n            \"Host launch require folder and task context.\"\n        )\n\n    workdir_data = get_template_data(\n        project_entity,\n        folder_entity,\n        task_entity,\n        app.host_name,\n        project_settings\n    )\n    data[\"workdir_data\"] = workdir_data\n\n    anatomy = data[\"anatomy\"]\n\n    task_type = workdir_data[\"task\"][\"type\"]\n    # Temp solution how to pass task type to `_prepare_last_workfile`\n    data[\"task_type\"] = task_type\n\n    try:\n        workdir = get_workdir_with_workdir_data(\n            workdir_data,\n            anatomy.project_name,\n            anatomy,\n            project_settings=project_settings\n        )\n\n    except Exception as exc:\n        raise ApplicationLaunchFailed(\n            \"Error in anatomy.format: {}\".format(str(exc))\n        )\n\n    if not os.path.exists(workdir):\n        log.debug(\n            \"Creating workdir folder: \\\"{}\\\"\".format(workdir)\n        )\n        try:\n            os.makedirs(workdir)\n        except Exception as exc:\n            raise ApplicationLaunchFailed(\n                \"Couldn't create workdir because: {}\".format(str(exc))\n            )\n\n    data[\"env\"][\"AYON_WORKDIR\"] = workdir\n\n    _prepare_last_workfile(data, workdir, addons_manager)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/version.html","title":"version","text":"<p>Package declaring AYON addon 'applications' version.</p>"},{"location":"autoapi/client/ayon_applications/hooks/index.html","title":"Index","text":""},{"location":"autoapi/client/ayon_applications/hooks/prelaunch_shell_windows.html","title":"prelaunch_shell_windows","text":""},{"location":"autoapi/client/ayon_applications/hooks/prelaunch_shell_windows.html#client.ayon_applications.hooks.prelaunch_shell_windows.LaunchTerminalWindowsCreationflags","title":"<code>LaunchTerminalWindowsCreationflags</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Avoid running the terminal without new console</p> Source code in <code>client/ayon_applications/hooks/prelaunch_shell_windows.py</code> <pre><code>class LaunchTerminalWindowsCreationflags(PreLaunchHook):\n    \"\"\"Avoid running the terminal without new console\"\"\"\n\n    # Should be as last hook because must change launch arguments to string\n    order = 1000\n    app_groups = {\"terminal\"}\n    platforms = {\"windows\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Change `creationflags` to CREATE_NEW_CONSOLE\n        # - on Windows some apps will create new window using its console\n        # Set `stdout` and `stderr` to None so new created console does not\n        #   have redirected output to DEVNULL in build\n        self.launch_context.kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE,\n            \"stdout\": None,\n            \"stderr\": None\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/index.html","title":"launcher_actions","text":""},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html","title":"debug_terminal","text":""},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html#client.ayon_applications.plugins.launcher_actions.debug_terminal.DebugTerminal","title":"<code>DebugTerminal</code>","text":"<p>               Bases: <code>LauncherAction</code></p> <p>Run any host environment in command line terminal.</p> Source code in <code>client/ayon_applications/plugins/launcher_actions/debug_terminal.py</code> <pre><code>class DebugTerminal(LauncherAction):\n    \"\"\"Run any host environment in command line terminal.\"\"\"\n    name = \"debugterminal\"\n    label = \"Terminal\"\n    icon = {\n        \"type\": \"awesome-font\",\n        \"name\": \"fa.terminal\",\n        \"color\": \"#e8770e\"\n    }\n    order = 10\n\n    def is_compatible(self, selection) -&gt; bool:\n        return selection.is_task_selected\n\n    def process(self, selection, **kwargs):\n        # Get cursor position directly so the menu shows closer to where user\n        # clicked because the get applications logic might take a brief moment\n        pos = QtGui.QCursor.pos()\n        application_manager = ApplicationManager()\n\n        # Choose terminal\n        terminal_applications = self.get_terminal_applications(\n            application_manager)\n        if len(terminal_applications) == 0:\n            raise ValueError(\n                \"Missing application variants for terminal application. \"\n                \"Please configure \"\n                \"'ayon+settings://applications/applications/terminal'\"\n            )\n        elif len(terminal_applications) == 1:\n            # If only one configured shell application, always use that one\n            terminal_app = terminal_applications[0]\n            print(\"Only one terminal application variant is configured. \"\n                  f\"Defaulting to {terminal_app.full_label}\")\n        else:\n            terminal_app = self.choose_app(\n                terminal_applications, pos, show_variant_name_only=True)\n        if not terminal_app:\n            return\n\n        # Get applications\n        applications = self.get_project_applications(\n            application_manager, selection)\n        app = self.choose_app(applications, pos)\n        if not app:\n            return\n\n        print(f\"Retrieving environment for: {app.full_label}..\")\n        env = get_app_environments_for_context(selection.project_name,\n                                               selection.folder_path,\n                                               selection.task_name,\n                                               app.full_name)\n\n        # If an executable is found. Then add the parent folder to PATH\n        # just so we can run the application easily from the command line.\n        exe = app.find_executable()\n        if exe:\n            exe_path = exe._realpath()\n            folder = os.path.dirname(exe_path)\n            print(f\"Appending to PATH: {folder}\")\n            env[\"PATH\"] += os.pathsep + folder\n\n        cwd = env.get(\"AYON_WORKDIR\")\n        if cwd:\n            print(f\"Setting Work Directory: {cwd}\")\n\n        print(f\"Launching terminal in environment of {app.full_label}..\")\n        self.launch_terminal_with_app_context(\n            application_manager,\n            terminal_app,\n            project_name=selection.project_name,\n            folder_path=selection.folder_path,\n            task_name=selection.task_name,\n            env=env,\n            cwd=cwd)\n\n    @staticmethod\n    def choose_app(\n        applications: list[Application],\n        pos: QtCore.QPoint,\n        show_variant_name_only: bool = False\n    ) -&gt; Optional[Application]:\n        \"\"\"Show menu to choose from list of applications\"\"\"\n        menu = QtWidgets.QMenu()\n        menu.setAttribute(QtCore.Qt.WA_DeleteOnClose)  # force garbage collect\n        menu.setStyleSheet(load_stylesheet())\n\n        # Sort applications\n        applications.sort(key=lambda item: item.full_label)\n\n        for app in applications:\n            label = app.label if show_variant_name_only else app.full_label\n            menu_action = QtWidgets.QAction(label, parent=menu)\n            icon = get_application_qt_icon(app)\n            if icon:\n                menu_action.setIcon(icon)\n            menu_action.setData(app)\n            menu.addAction(menu_action)\n\n        result = menu.exec_(pos)\n        if result:\n            return result.data()\n\n    @staticmethod\n    def get_project_applications(\n            application_manager: ApplicationManager,\n            selection: LauncherActionSelection) -&gt; list[Application]:\n        \"\"\"Return the enabled applications for the project\"\"\"\n\n        application_names = get_applications_for_context(\n            project_name=selection.project_name,\n            folder_entity=selection.folder_entity,\n            task_entity=selection.task_entity,\n            project_settings=selection.get_project_settings(),\n            project_entity=selection.project_entity\n        )\n\n        # Filter to apps valid for this current project, with logic from:\n        # `ayon_core.tools.launcher.models.actions.ApplicationAction.is_compatible`  # noqa\n        applications = []\n        for app_name in application_names:\n            app = application_manager.applications.get(app_name)\n            if not app or not app.enabled:\n                continue\n            applications.append(app)\n\n        return applications\n\n    @staticmethod\n    def get_terminal_applications(application_manager) -&gt; list[Application]:\n        \"\"\"Return all configured terminal applications\"\"\"\n        # TODO: Maybe filter out terminal applications not configured for your\n        #  current platform\n        return list(\n            application_manager.app_groups[\"terminal\"].variants.values())\n\n    def launch_terminal_with_app_context(\n        self,\n        application_manager: ApplicationManager,\n        application: Application,\n        project_name: str,\n        folder_path: str,\n        task_name: str,\n        cwd: str,\n        env: dict[str, str]\n    ) -&gt; list[str]:\n        \"\"\"Return the terminal executable to launch.\"\"\"\n        # TODO: Allow customization per user for this via AYON settings\n        launch_context = application_manager.create_launch_context(\n            application.full_name,\n            project_name=project_name,\n            folder_path=folder_path,\n            task_name=task_name,\n            env=env\n        )\n        launch_context.kwargs[\"cwd\"] = cwd\n        return application_manager.launch_with_context(launch_context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html#client.ayon_applications.plugins.launcher_actions.debug_terminal.DebugTerminal.choose_app","title":"<code>choose_app(applications, pos, show_variant_name_only=False)</code>  <code>staticmethod</code>","text":"<p>Show menu to choose from list of applications</p> Source code in <code>client/ayon_applications/plugins/launcher_actions/debug_terminal.py</code> <pre><code>@staticmethod\ndef choose_app(\n    applications: list[Application],\n    pos: QtCore.QPoint,\n    show_variant_name_only: bool = False\n) -&gt; Optional[Application]:\n    \"\"\"Show menu to choose from list of applications\"\"\"\n    menu = QtWidgets.QMenu()\n    menu.setAttribute(QtCore.Qt.WA_DeleteOnClose)  # force garbage collect\n    menu.setStyleSheet(load_stylesheet())\n\n    # Sort applications\n    applications.sort(key=lambda item: item.full_label)\n\n    for app in applications:\n        label = app.label if show_variant_name_only else app.full_label\n        menu_action = QtWidgets.QAction(label, parent=menu)\n        icon = get_application_qt_icon(app)\n        if icon:\n            menu_action.setIcon(icon)\n        menu_action.setData(app)\n        menu.addAction(menu_action)\n\n    result = menu.exec_(pos)\n    if result:\n        return result.data()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html#client.ayon_applications.plugins.launcher_actions.debug_terminal.DebugTerminal.get_project_applications","title":"<code>get_project_applications(application_manager, selection)</code>  <code>staticmethod</code>","text":"<p>Return the enabled applications for the project</p> Source code in <code>client/ayon_applications/plugins/launcher_actions/debug_terminal.py</code> <pre><code>@staticmethod\ndef get_project_applications(\n        application_manager: ApplicationManager,\n        selection: LauncherActionSelection) -&gt; list[Application]:\n    \"\"\"Return the enabled applications for the project\"\"\"\n\n    application_names = get_applications_for_context(\n        project_name=selection.project_name,\n        folder_entity=selection.folder_entity,\n        task_entity=selection.task_entity,\n        project_settings=selection.get_project_settings(),\n        project_entity=selection.project_entity\n    )\n\n    # Filter to apps valid for this current project, with logic from:\n    # `ayon_core.tools.launcher.models.actions.ApplicationAction.is_compatible`  # noqa\n    applications = []\n    for app_name in application_names:\n        app = application_manager.applications.get(app_name)\n        if not app or not app.enabled:\n            continue\n        applications.append(app)\n\n    return applications\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html#client.ayon_applications.plugins.launcher_actions.debug_terminal.DebugTerminal.get_terminal_applications","title":"<code>get_terminal_applications(application_manager)</code>  <code>staticmethod</code>","text":"<p>Return all configured terminal applications</p> Source code in <code>client/ayon_applications/plugins/launcher_actions/debug_terminal.py</code> <pre><code>@staticmethod\ndef get_terminal_applications(application_manager) -&gt; list[Application]:\n    \"\"\"Return all configured terminal applications\"\"\"\n    # TODO: Maybe filter out terminal applications not configured for your\n    #  current platform\n    return list(\n        application_manager.app_groups[\"terminal\"].variants.values())\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html#client.ayon_applications.plugins.launcher_actions.debug_terminal.DebugTerminal.launch_terminal_with_app_context","title":"<code>launch_terminal_with_app_context(application_manager, application, project_name, folder_path, task_name, cwd, env)</code>","text":"<p>Return the terminal executable to launch.</p> Source code in <code>client/ayon_applications/plugins/launcher_actions/debug_terminal.py</code> <pre><code>def launch_terminal_with_app_context(\n    self,\n    application_manager: ApplicationManager,\n    application: Application,\n    project_name: str,\n    folder_path: str,\n    task_name: str,\n    cwd: str,\n    env: dict[str, str]\n) -&gt; list[str]:\n    \"\"\"Return the terminal executable to launch.\"\"\"\n    # TODO: Allow customization per user for this via AYON settings\n    launch_context = application_manager.create_launch_context(\n        application.full_name,\n        project_name=project_name,\n        folder_path=folder_path,\n        task_name=task_name,\n        env=env\n    )\n    launch_context.kwargs[\"cwd\"] = cwd\n    return application_manager.launch_with_context(launch_context)\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/launcher_actions/debug_terminal.html#client.ayon_applications.plugins.launcher_actions.debug_terminal.get_application_qt_icon","title":"<code>get_application_qt_icon(application)</code>","text":"<p>Return QtGui.QIcon for an Application</p> Source code in <code>client/ayon_applications/plugins/launcher_actions/debug_terminal.py</code> <pre><code>def get_application_qt_icon(application: Application) -&gt; Optional[QtGui.QIcon]:\n    \"\"\"Return QtGui.QIcon for an Application\"\"\"\n    icon = application.icon\n    if not icon:\n        return QtGui.QIcon()\n    icon_filepath = get_app_icon_path(icon)\n    if os.path.exists(icon_filepath):\n        return get_qt_icon({\"type\": \"path\", \"path\": icon_filepath})\n    return QtGui.QIcon()\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_app_name.html","title":"collect_app_name","text":"<p>Run after global plugin 'CollectHostName' in ayon_core.</p> Requires <p>None</p> Provides <p>context -&gt; hostName (str) context -&gt; appName (str) context -&gt; appLabel (str)</p>"},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_app_name.html#client.ayon_applications.plugins.publish.collect_app_name.CollectAppName","title":"<code>CollectAppName</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect avalon host name to context.</p> Source code in <code>client/ayon_applications/plugins/publish/collect_app_name.py</code> <pre><code>class CollectAppName(pyblish.api.ContextPlugin):\n    \"\"\"Collect avalon host name to context.\"\"\"\n\n    label = \"Collect App Name\"\n    order = pyblish.api.CollectorOrder - 0.499999\n\n    def process(self, context):\n        host_name = context.data.get(\"hostName\")\n        app_name = context.data.get(\"appName\")\n        app_label = context.data.get(\"appLabel\")\n        # Don't override value if is already set\n        if host_name and app_name and app_label:\n            return\n\n        # Use AYON_APP_NAME to get full app name\n        if not app_name:\n            app_name = os.environ.get(\"AYON_APP_NAME\")\n\n        # Fill missing values based on app full name\n        if (not host_name or not app_label) and app_name:\n            app_manager = ApplicationManager()\n            app = app_manager.applications.get(app_name)\n            if app:\n                if not host_name:\n                    host_name = app.host_name\n                if not app_label:\n                    app_label = app.full_label\n\n        context.data[\"hostName\"] = host_name\n        context.data[\"appName\"] = app_name\n        context.data[\"appLabel\"] = app_label\n</code></pre>"},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_farm_env_variables.html","title":"collect_farm_env_variables","text":""},{"location":"autoapi/client/ayon_applications/plugins/publish/collect_farm_env_variables.html#client.ayon_applications.plugins.publish.collect_farm_env_variables.CollectApplicationsJobEnvVars","title":"<code>CollectApplicationsJobEnvVars</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect set of environment variables for farm jobs</p> Source code in <code>client/ayon_applications/plugins/publish/collect_farm_env_variables.py</code> <pre><code>class CollectApplicationsJobEnvVars(pyblish.api.ContextPlugin):\n    \"\"\"Collect set of environment variables for farm jobs\"\"\"\n    order = pyblish.api.CollectorOrder - 0.45\n    label = \"Collect Applications farm environment variables\"\n    targets = [\"local\"]\n\n    def process(self, context):\n        env = context.data.setdefault(FARM_JOB_ENV_DATA_KEY, {})\n        for key in [\n            \"AYON_APP_NAME\",\n        ]:\n            value = os.getenv(key)\n            if value:\n                self.log.debug(f\"Setting job env: {key}: {value}\")\n                env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_applications/ui/index.html","title":"ui","text":""},{"location":"autoapi/client/ayon_applications/ui/launch_failed_dialog.html","title":"launch_failed_dialog","text":""},{"location":"autoapi/server/index.html","title":"server","text":"<p>Server side of the Applications addon.</p> <p>This module contains the server side of the Applications addon. It is responsible for managing settings and initial setup of addon.</p>"},{"location":"autoapi/server/index.html#server--attributes-backward-compatibility","title":"Attributes backward compatibility","text":"<p>Current and previous versions of applications addon did use AYON attributes to define applications and tools for a project and task.</p> <p>This system was replaced with a new system using settings. This change is not 100% backwards compatible, we need to make sure that older versions of the addon don't break initialization.</p> <p>Older versions of the addon used settings of other versions, but the settings structure did change which can cause that combination of old and new Applications addon on server can cause crashes.</p> <p>First version introduction settings does support both settings and attributes so the handling of older versions is part of the addon, but following versions have to find some clever way how to avoid the issues.</p> <p>Version stored under 'ATTRIBUTES_VERSION_MILESTONE' should be last released version that used only old attribute system.</p>"},{"location":"autoapi/server/index.html#server.ApplicationsAddon","title":"<code>ApplicationsAddon</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> Source code in <code>server/__init__.py</code> <pre><code>class ApplicationsAddon(BaseServerAddon):\n    settings_model = ApplicationsAddonSettings\n    # TODO remove this attribute when attributes support is removed\n    has_attributes = True\n\n    async def get_simple_actions(\n        self,\n        project_name: str | None = None,\n        variant: str = \"production\",\n    ) -&gt; list[\"SimpleActionManifest\"]:\n        return await get_action_manifests(\n            self,\n            project_name=project_name,\n            variant=variant,\n        )\n\n    async def execute_action(\n        self,\n        executor: \"ActionExecutor\",\n    ) -&gt; \"ExecuteResponseModel\":\n        \"\"\"Execute an action provided by the addon\"\"\"\n        app_name = executor.identifier[len(IDENTIFIER_PREFIX):]\n        context = executor.context\n        project_name = context.project_name\n        task_id = context.entity_ids[0]\n\n        return await executor.get_launcher_action_response(\n            args=[\n                \"addon\", \"applications\", \"launch-by-id\",\n                \"--app\", app_name,\n                \"--project\", project_name,\n                \"--task-id\", task_id,\n            ]\n        )\n\n    async def get_default_settings(self):\n        return self.get_settings_model()(**DEFAULT_VALUES)\n\n    async def pre_setup(self):\n        \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        old_addon = app_defs.versions.get(\"0.1.0\")\n        if old_addon is not None:\n            # Override 'create_applications_attribute' for older versions\n            #   - avoid infinite server restart loop\n            old_addon.create_applications_attribute = (\n                self.create_applications_attribute\n            )\n\n        # Update older versions of applications addon to use new\n        #   '_update_enums'\n        # - new function skips newer addon versions without 'has_attributes'\n        version_objs, invalid_versions = parse_versions(app_defs.versions)\n        for addon_version, version_obj in version_objs:\n            # Last release with only old attribute system\n            if version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n                addon = app_defs.versions[addon_version]\n                addon._update_enums = self._update_enums\n\n    async def convert_settings_overrides(\n        self,\n        source_version: str,\n        overrides: dict[str, Any],\n    ) -&gt; dict[str, Any]:\n        overrides = await super().convert_settings_overrides(\n            source_version, overrides\n        )\n        # Since 1.0.0 the project applications and tools are\n        #   using settings instead of attributes.\n        # Disable automatically project applications and tools\n        #   when converting settings of version &lt; 1.0.0 so we don't break\n        #   productions on update\n        if parse_version(source_version) &lt; (1, 0, 0):\n            prj_apps = overrides.setdefault(\"project_applications\", {})\n            prj_apps[\"enabled\"] = False\n            prj_tools = overrides.setdefault(\"project_tools\", {})\n            prj_tools[\"enabled\"] = False\n        return overrides\n\n    # --------------------------------------\n    # Backwards compatibility for attributes\n    # --------------------------------------\n    def _sort_versions(self, addon_versions, reverse=False):\n        version_objs, invalid_versions = parse_versions(addon_versions)\n\n        valid_versions = [\n            addon_version\n            for addon_version, version_obj in (\n                sorted(version_objs, key=lambda x: x[1])\n            )\n        ]\n        sorted_versions = list(sorted(invalid_versions)) + valid_versions\n        if reverse:\n            sorted_versions = reversed(sorted_versions)\n        for addon_version in sorted_versions:\n            yield addon_version\n\n    def _merge_groups(self, output, new_groups):\n        groups_by_name = {\n            o_group[\"name\"]: o_group\n            for o_group in output\n        }\n        extend_groups = []\n        for new_group in new_groups:\n            group_name = new_group[\"name\"]\n            if group_name not in groups_by_name:\n                extend_groups.append(new_group)\n                continue\n            existing_group = groups_by_name[group_name]\n            existing_variants = existing_group[\"variants\"]\n            existing_variants_by_name = {\n                variant[\"name\"]: variant\n                for variant in existing_variants\n            }\n            for new_variant in new_group[\"variants\"]:\n                if new_variant[\"name\"] not in existing_variants_by_name:\n                    existing_variants.append(new_variant)\n\n        output.extend(extend_groups)\n\n    def _get_enum_items_from_groups(self, groups):\n        label_by_name = {}\n        for group in groups:\n            group_name = group[\"name\"]\n            group_label = group.get(\n                \"label\", LABELS_BY_GROUP_NAME.get(group_name)\n            ) or group_name\n            for variant in group[\"variants\"]:\n                variant_name = variant[\"name\"]\n                if not variant_name:\n                    continue\n                variant_label = variant[\"label\"] or variant_name\n                full_name = f\"{group_name}/{variant_name}\"\n                full_label = f\"{group_label} {variant_label}\"\n                label_by_name[full_name] = full_label\n\n        return [\n            {\"value\": full_name, \"label\": label_by_name[full_name]}\n            for full_name in sorted(label_by_name)\n        ]\n\n    def _addon_has_attributes(self, addon, addon_version):\n        version_obj = parse_version(addon_version)\n        if version_obj is None or version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            return True\n\n        return getattr(addon, \"has_attributes\", False)\n\n    async def _update_enums(self):\n        \"\"\"Updates applications and tools enums based on the addon settings.\n        This method is called when the addon is started (after we are sure that the\n        'applications' and 'tools' attributes exist) and when the addon settings are\n        updated (using on_settings_updated method).\n        \"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        all_applications = []\n        all_tools = []\n        for addon_version in self._sort_versions(\n            app_defs.versions.keys(), reverse=True\n        ):\n            addon = app_defs.versions[addon_version]\n            if not self._addon_has_attributes(addon, addon_version):\n                continue\n\n            for variant in (\"production\", \"staging\"):\n                settings_model = await addon.get_studio_settings(variant)\n                studio_settings = settings_model.dict()\n                application_settings = studio_settings[\"applications\"]\n                app_groups = application_settings.pop(\"additional_apps\")\n                for group_name, value in application_settings.items():\n                    value[\"name\"] = group_name\n                    app_groups.append(value)\n                self._merge_groups(all_applications, app_groups)\n                self._merge_groups(all_tools, studio_settings[\"tool_groups\"])\n\n        apps_attrib_name = \"applications\"\n        tools_attrib_name = \"tools\"\n\n        apps_enum = self._get_enum_items_from_groups(all_applications)\n        tools_enum = self._get_enum_items_from_groups(all_tools)\n\n        apps_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Applications\",\n            \"enum\": apps_enum,\n        }\n        tools_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Tools\",\n            \"enum\": tools_enum,\n        }\n\n        apps_scope = [\"project\"]\n        tools_scope = [\"project\", \"folder\", \"task\"]\n\n        apps_matches = False\n        tools_matches = False\n\n        async for row in Postgres.iterate(\n            \"SELECT name, position, scope, data from public.attributes\"\n        ):\n            if row[\"name\"] == apps_attrib_name:\n                # Check if scope is matching ftrack addon requirements\n                if (\n                    set(row[\"scope\"]) == set(apps_scope)\n                    and row[\"data\"].get(\"enum\") == apps_enum\n                ):\n                    apps_matches = True\n\n            elif row[\"name\"] == tools_attrib_name:\n                if (\n                    set(row[\"scope\"]) == set(tools_scope)\n                    and row[\"data\"].get(\"enum\") == tools_enum\n                ):\n                    tools_matches = True\n\n        if apps_matches and tools_matches:\n            return\n\n        if not apps_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                apps_scope,\n                apps_attribute_data,\n                apps_attrib_name,\n            )\n\n        if not tools_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                tools_scope,\n                tools_attribute_data,\n                tools_attrib_name,\n            )\n\n        # Reset attributes cache on server\n        await attribute_library.load()\n</code></pre>"},{"location":"autoapi/server/index.html#server.ApplicationsAddon.execute_action","title":"<code>execute_action(executor)</code>  <code>async</code>","text":"<p>Execute an action provided by the addon</p> Source code in <code>server/__init__.py</code> <pre><code>async def execute_action(\n    self,\n    executor: \"ActionExecutor\",\n) -&gt; \"ExecuteResponseModel\":\n    \"\"\"Execute an action provided by the addon\"\"\"\n    app_name = executor.identifier[len(IDENTIFIER_PREFIX):]\n    context = executor.context\n    project_name = context.project_name\n    task_id = context.entity_ids[0]\n\n    return await executor.get_launcher_action_response(\n        args=[\n            \"addon\", \"applications\", \"launch-by-id\",\n            \"--app\", app_name,\n            \"--project\", project_name,\n            \"--task-id\", task_id,\n        ]\n    )\n</code></pre>"},{"location":"autoapi/server/index.html#server.ApplicationsAddon.pre_setup","title":"<code>pre_setup()</code>  <code>async</code>","text":"<p>Make sure older version of addon use the new way of attributes.</p> Source code in <code>server/__init__.py</code> <pre><code>async def pre_setup(self):\n    \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n    instance = AddonLibrary.getinstance()\n    app_defs = instance.data.get(self.name)\n    old_addon = app_defs.versions.get(\"0.1.0\")\n    if old_addon is not None:\n        # Override 'create_applications_attribute' for older versions\n        #   - avoid infinite server restart loop\n        old_addon.create_applications_attribute = (\n            self.create_applications_attribute\n        )\n\n    # Update older versions of applications addon to use new\n    #   '_update_enums'\n    # - new function skips newer addon versions without 'has_attributes'\n    version_objs, invalid_versions = parse_versions(app_defs.versions)\n    for addon_version, version_obj in version_objs:\n        # Last release with only old attribute system\n        if version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            addon = app_defs.versions[addon_version]\n            addon._update_enums = self._update_enums\n</code></pre>"},{"location":"autoapi/server/_backwards.html","title":"_backwards","text":"<p>Backwards compatibility for applications addon.</p> <p>This should have been backwards compatibility fix for older addons using attributes for applications and tools. But the first release of addon that allows to disable kept the attributes in play and the fix was not needed.</p> <p>This is preparation for following release of applications addon that will completely remove the attributes and use only settings.</p> <p>TODO (Added 2024/08/05). Use this code when attributes are removed from the addon, or remove the file in future if plans changed.</p>"},{"location":"autoapi/server/_backwards.html#server._backwards.ApplicationsLE_0_2","title":"<code>ApplicationsLE_0_2</code>","text":"Source code in <code>server/_backwards.py</code> <pre><code>class ApplicationsLE_0_2:\n    def __init__(self, addon_obj):\n        self._addon_obj = addon_obj\n\n    def _sort_versions(self, addon_versions, reverse=False):\n        version_objs, invalid_versions = parse_versions(addon_versions)\n\n        valid_versions = [\n            addon_version\n            for addon_version, version_obj in (\n                sorted(version_objs, key=lambda x: x[1])\n            )\n            # Skip versions greater than 0.2\n            if (version_obj.major, version_obj.minor) &lt;= (0, 2)\n        ]\n        sorted_versions = list(sorted(invalid_versions)) + valid_versions\n        if reverse:\n            sorted_versions = reversed(sorted_versions)\n        for addon_version in sorted_versions:\n            yield addon_version\n\n    def _merge_groups(self, output, new_groups):\n        groups_by_name = {\n            o_group[\"name\"]: o_group\n            for o_group in output\n        }\n        extend_groups = []\n        for new_group in new_groups:\n            group_name = new_group[\"name\"]\n            if group_name not in groups_by_name:\n                extend_groups.append(new_group)\n                continue\n            existing_group = groups_by_name[group_name]\n            existing_variants = existing_group[\"variants\"]\n            existing_variants_by_name = {\n                variant[\"name\"]: variant\n                for variant in existing_variants\n            }\n            for new_variant in new_group[\"variants\"]:\n                if new_variant[\"name\"] not in existing_variants_by_name:\n                    existing_variants.append(new_variant)\n\n        output.extend(extend_groups)\n\n    def _get_enum_items_from_groups(self, groups):\n        label_by_name = {}\n        for group in groups:\n            group_name = group[\"name\"]\n            group_label = group[\"label\"] or group_name\n            for variant in group[\"variants\"]:\n                variant_name = variant[\"name\"]\n                if not variant_name:\n                    continue\n                variant_label = variant[\"label\"] or variant_name\n                full_name = f\"{group_name}/{variant_name}\"\n                full_label = f\"{group_label} {variant_label}\"\n                label_by_name[full_name] = full_label\n\n        return [\n            {\"value\": full_name, \"label\": label_by_name[full_name]}\n            for full_name in sorted(label_by_name)\n        ]\n\n    def _addon_has_attributes(self, addon, addon_version):\n        version_obj = parse_version(addon_version)\n        if version_obj is None or version_obj &lt; ATTRIBUTES_VERSION_MILESTONE:\n            return True\n        return getattr(addon, \"has_attributes\", False)\n\n    async def _update_enums(self):\n        \"\"\"Updates applications and tools enums based on the addon settings.\n        This method is called when the addon is started (after we are sure that the\n        'applications' and 'tools' attributes exist) and when the addon settings are\n        updated (using on_settings_updated method).\n        \"\"\"\n\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self._addon_obj.name)\n        all_applications = []\n        all_tools = []\n        for addon_version in self._sort_versions(\n            app_defs.versions.keys(), reverse=True\n        ):\n            addon = app_defs.versions[addon_version]\n            if not self._addon_has_attributes(addon):\n                continue\n\n            for variant in (\"production\", \"staging\"):\n                settings_model = await addon.get_studio_settings(variant)\n                studio_settings = settings_model.dict()\n                application_settings = studio_settings[\"applications\"]\n                app_groups = application_settings.pop(\"additional_apps\")\n                for group_name, value in application_settings.items():\n                    value[\"name\"] = group_name\n                    app_groups.append(value)\n                self._merge_groups(all_applications, app_groups)\n                self._merge_groups(all_tools, studio_settings[\"tool_groups\"])\n\n        apps_attrib_name = \"applications\"\n        tools_attrib_name = \"tools\"\n\n        apps_enum = self._get_enum_items_from_groups(all_applications)\n        tools_enum = self._get_enum_items_from_groups(all_tools)\n\n        apps_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Applications\",\n            \"enum\": apps_enum,\n        }\n        tools_attribute_data = {\n            \"type\": \"list_of_strings\",\n            \"title\": \"Tools\",\n            \"enum\": tools_enum,\n        }\n\n        apps_scope = [\"project\"]\n        tools_scope = [\"project\", \"folder\", \"task\"]\n\n        apps_matches = False\n        tools_matches = False\n\n        async for row in Postgres.iterate(\n            \"SELECT name, position, scope, data from public.attributes\"\n        ):\n            if row[\"name\"] == apps_attrib_name:\n                # Check if scope is matching ftrack addon requirements\n                if (\n                    set(row[\"scope\"]) == set(apps_scope)\n                    and row[\"data\"].get(\"enum\") == apps_enum\n                ):\n                    apps_matches = True\n\n            elif row[\"name\"] == tools_attrib_name:\n                if (\n                    set(row[\"scope\"]) == set(tools_scope)\n                    and row[\"data\"].get(\"enum\") == tools_enum\n                ):\n                    tools_matches = True\n\n        if apps_matches and tools_matches:\n            return\n\n        if not apps_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                apps_scope,\n                apps_attribute_data,\n                apps_attrib_name,\n            )\n\n        if not tools_matches:\n            await Postgres.execute(\n                \"\"\"\n                UPDATE attributes SET\n                    scope = $1,\n                    data = $2\n                WHERE\n                    name = $3\n                \"\"\",\n                tools_scope,\n                tools_attribute_data,\n                tools_attrib_name,\n            )\n\n        # Reset attributes cache on server\n        await attribute_library.load()\n</code></pre>"},{"location":"autoapi/server/actions.html","title":"actions","text":""},{"location":"autoapi/server/constants.html","title":"constants","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""},{"location":"autoapi/server/settings.html#server.settings.ApplicationsSettings","title":"<code>ApplicationsSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Applications settings</p> Source code in <code>server/settings.py</code> <pre><code>class ApplicationsSettings(BaseSettingsModel):\n    \"\"\"Applications settings\"\"\"\n\n    maya: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Maya\")\n    adsk_3dsmax: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"3ds Max\")\n    flame: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Flame\")\n    gaffer: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Gaffer\")\n    nuke: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke\")\n    nukeassist: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke Assist\")\n    nukex: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke X\")\n    nukestudio: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Nuke Studio\")\n    hiero: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Hiero\")\n    fusion: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Fusion\")\n    resolve: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Resolve\")\n    houdini: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Houdini\")\n    blender: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Blender\")\n    harmony: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Harmony\")\n    tvpaint: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"TVPaint\")\n    photoshop: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Photoshop\")\n    aftereffects: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"After Effects\")\n    premiere: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Premiere\")\n    celaction: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Celaction 2D\")\n    substancepainter: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Substance Painter\")\n    substancedesigner: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Substance Designer\")\n    speedtree: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Speedtree\")\n    unreal: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Unreal Editor\")\n    wrap: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Wrap\")\n    openrv: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"OpenRV\")\n    zbrush: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Zbrush\")\n    equalizer: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"3DEqualizer\")\n    motionbuilder: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Motion Builder\")\n    cinema4d: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Cinema4D\")\n    mochapro: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"Mocha Pro\")\n    silhouette: AppGroup = SettingsField(\n        default_factory=AppGroup, title=\"BorisFX Silhouette\")\n    terminal: AppGroup = SettingsField(\n        default_factory=AppGroup,\n        title=\"Terminal\",\n        description=\"Terminal application\")\n    additional_apps: list[AdditionalAppGroup] = SettingsField(\n        default_factory=list, title=\"Additional Applications\")\n\n    @validator(\"additional_apps\")\n    def validate_unique_name(cls, value):\n        ensure_unique_names(value)\n        for item in value:\n            if item.name in DEFAULT_APP_GROUPS:\n                raise BadRequestException(f\"Duplicate name '{item.name}'\")\n        return value\n</code></pre>"}]}